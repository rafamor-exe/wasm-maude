==========================================
erewrite in WASM-FILE-MOD : search-with-func-from-file(
    "examples/factorial_valid_br_jump.wat", "$start", 'w:WASMSimTrigger, nil,
    '!, unbounded, 0) .
*********** equation
eq search-with-func-from-file(WASMModFile, Func, ResTerm, Condition,
    SearchType, maxDepth, solNumber) = getFormattedRes(aux-metaSearch(upModule(
    'WASMMOD, false), gen-config(WASMModFile), Func, ResTerm, Condition,
    SearchType, maxDepth, solNumber)) .
WASMModFile --> "examples/factorial_valid_br_jump.wat"
Func --> "$start"
ResTerm --> 'w:WASMSimTrigger
Condition --> (nil).EqCondition
SearchType --> '!
maxDepth --> unbounded
solNumber --> (0).Zero
search-with-func-from-file("examples/factorial_valid_br_jump.wat", "$start",
    'w:WASMSimTrigger, nil, '!, unbounded, 0)
--->
getFormattedRes(aux-metaSearch(upModule('WASMMOD, false), gen-config(
    "examples/factorial_valid_br_jump.wat"), "$start", 'w:WASMSimTrigger, nil,
    '!, unbounded, 0))
*********** equation
(built-in equation for symbol upModule)
upModule('WASMMOD, false)
--->
mod 'WASMMOD is
  including 'BOOL .
  protecting 'WASM-MODULECONTENT-MOD .
  protecting 'WASM-VERIFYFUNCDEF-MOD .
  protecting 'MAP{'ValRef, 'Value} .
  protecting 'LIST{'Map{'ValRef, 'Value}} .
  protecting 'MAP{'String, 'Addr} .
  protecting 'MAP{'Addr, 'GlobalInstance} .
  sorts 'WASMSim ; 'WasmTrigger ; 'WASMSimTrigger ; 'WASMTypeFuncGlobalSim ;
    'WASMTypeFuncGlobalIndSim ; 'WASMFuncGlobalSim ; 'WASMFuncGlobalIndSim ;
    'GlobalInventory ; 'WASMGlobalSim ; 'WASMGlobalIndSim ; 'WASMLocalSim ;
    'WASMLocalIndSim ; 'WASMModule ; 'Stack ; 'EmptyStack ; 'NeStack ;
    'StackElem ; 'Label ; 'StackAndLabel ; 'FuncStore ; 'IndCtx ; 'LocalIndCtx
    ; 'GlobalIndCtx ; 'FuncIndCtx ; 'TypeIndCtx ; 'Starter ; 'ComponentCtr .
  subsort 'Stack < 'WASMLocalSim .
  subsort 'List`{Inst`} < 'WASMLocalSim .
  subsort 'EmptyStack < 'Stack .
  subsort 'NeStack < 'Stack .
  subsort 'StackElem < 'NeStack .
  subsort 'Value < 'StackElem .
  subsort 'Label < 'StackElem .
  subsort 'Und < 'Label .
  subsort 'LocalIndCtx < 'IndCtx .
  subsort 'GlobalIndCtx < 'IndCtx .
  subsort 'FuncIndCtx < 'IndCtx .
  subsort 'TypeIndCtx < 'IndCtx .
  op 'head : 'NeList`{Inst`} -> 'Inst [none] .
  op 'tail : 'NeList`{Inst`} -> 'List`{Inst`} [none] .
  op 'label : 'String 'List`{Inst`} 'Nat -> 'Label [ctor] .
  op '`{localIndCtx_`} : 'Map`{String`,Addr`} -> 'LocalIndCtx [ctor] .
  op '`{funcIndCtx_`} : 'Map`{String`,Addr`} -> 'FuncIndCtx [ctor] .
  op '`{typeIndCtx_`} : 'Map`{String`,Addr`} -> 'TypeIndCtx [ctor] .
  op '<_|_|_> : 'List`{Inst`} 'Stack 'Map`{ValRef`,Value`} -> 'WASMLocalSim [
    ctor format('ni 'd 'd 'd 'd 'd 'd 'd)] .
  op '__ : 'LocalIndCtx 'WASMLocalSim -> 'WASMLocalIndSim [ctor] .
  op '_<->_ : 'Map`{String`,Addr`} 'Map`{Addr`,GlobalInstance`} ->
    'GlobalInventory [ctor] .
  op '_#_ : 'WASMLocalSim 'GlobalInventory -> 'WASMGlobalSim [ctor format('d
    'ni 'ni 'd)] .
  op '_#_ : 'WASMGlobalSim 'Map`{Addr`,ModuleContent`} -> 'WASMFuncGlobalSim [
    ctor format('d 'ni 'ni 'd)] .
  op '__ : 'FuncIndCtx 'WASMFuncGlobalSim -> 'WASMFuncGlobalIndSim [ctor] .
  op '_#_ : 'WASMFuncGlobalIndSim 'Map`{Addr`,ModuleContent`} ->
    'WASMTypeFuncGlobalSim [ctor format('d 'ni 'ni 'd)] .
  op '__ : 'TypeIndCtx 'WASMTypeFuncGlobalSim -> 'WASMTypeFuncGlobalIndSim [
    ctor] .
  op '#_#_# : 'WASMModule 'WASMTypeFuncGlobalIndSim -> 'WASMSim [ctor format(
    'ni 'ni 'ni 'ni 'ni 'ni)] .
  op 'start_ : 'Nat -> 'Starter [ctor] .
  op 'start_ : 'String -> 'Starter [ctor] .
  op '`[_`,_`,_`] : 'Nat 'Nat 'Nat -> 'ComponentCtr [ctor] .
  op '`{_`,indctr_`} : 'Starter 'ComponentCtr -> 'WasmTrigger [ctor] .
  op '__ : 'WasmTrigger 'WASMSim -> 'WASMSimTrigger [ctor format('ni 'ni 'ni)]
    .
  op 'Fail : 'String -> 'WASMSimTrigger [ctor] .
  op 'module_ : 'ModuleContent -> 'WASMModule [ctor prec(20)] .
  op 'EmptyStack : nil -> 'EmptyStack [ctor] .
  op '_$_ : 'StackElem 'Stack -> 'NeStack [ctor format('d 'ni 'd 'd) id(
    'EmptyStack.EmptyStack)] .
  op 'lookup : 'Map`{ValRef`,Value`} 'ValRef -> 'Value [none] .
  op 'jump-to-L : 'StackAndLabel -> 'Inst [ctor] .
  op 'errorMod : nil -> '`[WASMModule`] [none] .
  op 'errorWASMSimTrigger : nil -> '`[WASMSimTrigger`] [none] .
  op 'run-nomodule : 'List`{Inst`} -> 'WASMTypeFuncGlobalSim [none] .
  op 'uninitialized : nil -> 'Inst [ctor] .
  op 'run-module-func : 'WASMModule 'Nat -> 'WASMSimTrigger [none] .
  op 'run-module-func : 'WASMModule 'String -> 'WASMSimTrigger [none] .
  op 'read-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'simulate-wasm : 'WASMTypeFuncGlobalIndSim -> 'WASMTypeFuncGlobalIndSim [
    none] .
  op 'insert : 'String 'Nat 'IndCtx -> 'IndCtx [none] .
  op 'st-push : 'Stack 'StackElem -> 'NeStack [none] .
  op 'st-head : 'NeStack -> 'StackElem [none] .
  op 'st-pop : 'NeStack -> 'Stack [none] .
  op 'st-rev : 'Stack -> 'Stack [none] .
  op 'st-popN : 'Stack 'Nat -> 'Stack [none] .
  op 'st-getTopVals : 'Stack 'List`{TypeToken`} -> 'Stack [none] .
  op 'global-val : 'GlobalInstance -> 'Value [none] .
  op 'global-type : 'GlobalInstance -> 'GlobalType [none] .
  op '_||_ : 'Stack 'Label -> 'StackAndLabel [none] .
  op 'reset-st : 'Stack -> 'StackAndLabel [none] .
  op 'reset-st-res : 'Stack 'Nat -> 'Stack [none] .
  op 'get-inst-list-label : 'StackAndLabel -> 'List`{Inst`} [none] .
  op 'get-st : 'StackAndLabel -> 'Stack [none] .
  op 'get-label : 'StackAndLabel -> 'Label [none] .
  op 'get-lth-label : 'Stack 'Nat -> 'Label [none] .
  op 'get-ith-stackandlabel : 'Stack 'Nat 'Stack -> 'StackAndLabel [none] .
  op 'if-else : 'ValWrapper 'List`{Inst`} 'List`{Inst`} 'BlockType ->
    'List`{Inst`} [none] .
  op 'get-IL-func : 'FuncDef -> 'List`{Inst`} [none] .
  op 'exit-block : 'List`{Inst`} -> 'Inst [ctor] .
  op 'exit-func : 'List`{TypeToken`} -> 'Inst [ctor] .
  op 'get-localsref-func : 'FuncDef -> 'LocalsRef [none] .
  op 'get-localsTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-localsTList : 'LocalsRef -> 'List`{TypeToken`} [none] .
  op 'get-paramlist-func : 'FuncDef -> 'ParamType [none] .
  op 'get-resultlist-func : 'FuncDef -> 'ResultType [none] .
  op 'aux-get-paramlistTList : 'ParamType -> 'List`{TypeToken`} [none] .
  op 'get-paramlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'aux-get-resultlistTList : 'ResultType -> 'List`{TypeToken`} [none] .
  op 'get-resultlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'count-locals-localsref : 'LocalsRef -> 'Nat [none] .
  op 'count-locals-paramlist : 'ParamType -> 'Nat [none] .
  op 'count-paramlist-func : 'FuncDef -> 'Nat [none] .
  op 'expand : 'BlockType 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`} ->
    'ParamResultType [none] .
  op 'init-store : 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`} ->
    'Map`{ValRef`,Value`} [none] .
  op 'inizialize-store : 'Nat 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`}
    -> 'Map`{ValRef`,Value`} [none] .
  op 'selectVal : 'ValWrapper 'Value 'Value -> 'Value [none] .
  op 'valid-stack : 'Stack 'List`{TypeToken`} -> 'Bool [none] .
  op 'validate-funcs-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'get-funcList : 'Map`{Addr`,ModuleContent`} -> 'FuncDefList [none] .
  op 'verify-funcList : 'FuncDefList 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{Addr`,GlobalInstance`}
    'Map`{String`,Addr`} -> 'Bool [none] .
  op 'verify-IL : 'List`{Inst`} 'List`{TypeToken`} 'List`{TypeToken`}
    'List`{TypeToken`} 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{Addr`,GlobalInstance`} 'Map`{String`,Addr`} 'ResultTypeList -> 'Bool
    [none] .
  op 'nthT : 'List`{TypeToken`} 'Nat -> 'TypeToken [none] .
  op 'nthResultT : 'ResultTypeList 'Nat -> 'List`{TypeToken`} [none] .
  none
  eq 'if_['TList:List`{TypeToken`}] = 'if_['result_['TList:List`{TypeToken`}]]
    [none] .
  eq 'block_['TList:List`{TypeToken`}] = 'block_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'loop_['TList:List`{TypeToken`}] = 'loop_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'run-nomodule['IL:List`{Inst`}] = '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['IL:List`{Inst`},
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}] [
    none] .
  eq 'run-module-func['WASMModule:WASMModule, 'N:Nat] = 'read-module['__[
    '`{_`,indctr_`}['start_['N:Nat], '`[_`,_`,_`]['0.Zero, '0.Zero, '0.Zero]],
    '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'Str:String] = 'read-module['__[
    '`{_`,indctr_`}['start_['Str:String], '`[_`,_`,_`]['0.Zero, '0.Zero,
    '0.Zero]], '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['N:Nat], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['Str:String], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Id:Id, 'FuncType:FuncType]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__['Id:Id,
    'FuncType:FuncType], 'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Str:String, 'FuncType:FuncType]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['insert['Str:String, 'TCtr:Nat,
    'IndTypeCtx:TypeIndCtx], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__[
    'Str:String, 'FuncType:FuncType],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['Id:Id, 'func____[
    'Id:Id, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['insert[
    'Str:String, 'FCtr:Nat, 'IndFuncCtx:FuncIndCtx], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['FCtr:Nat, 'func____[
    'Str:String, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'ValW1:ValWrapper]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'ValW1:ValWrapper :=
    'unsigned['val['IntN:Int], 'bit-width['IntT:IntTypeToken]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken, 'IntN:Int]]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['__['ModuleContent:ModuleContent,
    'global__`(_`)['Str:String, 'GlobalType:GlobalType, '_.const_[
    'FloatT:FloatTypeToken, 'float['IntN:Int]]]]], '__['IndTypeCtx:TypeIndCtx,
    '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    '0.0.FiniteFloat]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    'FloatN:Float]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'FloatN:Float]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['v128.VecTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['v128.VecTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'ExportDef:ExportDef]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'simulate-wasm['WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim] =
    'WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}]] = '`{funcIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndFuncCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}]] = '`{typeIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndTypeCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'lookup['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] = '_`[_`][
    'LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] [none] .
  eq 'head['__['I1:Inst, 'IL:List`{Inst`}]] = 'I1:Inst [none] .
  eq 'tail['__['I1:Inst, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'st-push['ST:Stack, 'STElem:StackElem] = '_$_['STElem:StackElem,
    'ST:Stack] [none] .
  eq 'st-push['EmptyStack.EmptyStack, 'STElem:StackElem] = 'STElem:StackElem [
    none] .
  eq 'st-head['_$_['STElem:StackElem, 'ST:Stack]] = 'STElem:StackElem [none] .
  eq 'st-pop['_$_['STElem:StackElem, 'ST:Stack]] = 'ST:Stack [none] .
  eq 'st-rev['_$_['STElem:StackElem, 'ST:Stack]] = '_$_['st-rev['ST:Stack],
    'STElem:StackElem] [none] .
  eq 'st-rev['EmptyStack.EmptyStack] = 'EmptyStack.EmptyStack [none] .
  eq 'st-popN['ST:Stack, '0.Zero] = 'ST:Stack [none] .
  ceq 'st-popN['_$_['STElem:StackElem, 'ST:Stack], 'N:Nat] = 'st-popN[
    'ST:Stack, '_-_['N:Nat, 's_['0.Zero]]] if '_>_['N:Nat, '0.Zero] =
    'true.Bool [none] .
  eq 'st-getTopVals['ST:Stack, 'nil.List`{TypeToken`}] = 'EmptyStack.EmptyStack
    [none] .
  eq 'st-getTopVals['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'st-getTopVals['ST:Stack, 'TList:List`{TypeToken`}]] [
    none] .
  eq 'global-val['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'Val:Value [none] .
  eq 'global-type['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'GlobalType:GlobalType [none] .
  eq 'reset-st['_$_['Val:Value, 'ST:Stack]] = '_||_['_$_['Val:Value, 'get-st[
    'reset-st['ST:Stack]]], 'get-label['reset-st['ST:Stack]]] [none] .
  eq 'reset-st['_$_['Label:Label, 'ST:Stack]] = '_||_['ST:Stack, 'Label:Label]
    [none] .
  eq 'reset-st['EmptyStack.EmptyStack] = '_||_['EmptyStack.EmptyStack,
    'und.Und] [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], '0.Zero] =
    'EmptyStack.EmptyStack [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], 'NzN:NzNat] = '_$_['Val:Value,
    'reset-st-res['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]]] [none] .
  eq 'reset-st-res['EmptyStack.EmptyStack, 'N:Nat] = 'EmptyStack.EmptyStack [
    none] .
  eq 'get-inst-list-label['_||_['ST:Stack, 'label['Str:String,
    'IL:List`{Inst`}, 'N:Nat]]] = 'IL:List`{Inst`} [none] .
  eq 'get-st['_||_['ST:Stack, 'Label:Label]] = 'ST:Stack [none] .
  eq 'get-st['_||_['ST:Stack, 'und.Und]] = 'ST:Stack [none] .
  eq 'get-label['_||_['ST:Stack, 'Label:Label]] = 'Label:Label [none] .
  eq 'get-label['_||_['ST:Stack, 'und.Und]] = 'und.Und [none] .
  eq 'get-lth-label['_$_['Val:Value, 'ST:Stack], 'N:Nat] = 'get-lth-label[
    'ST:Stack, 'N:Nat] [none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], '0.Zero] = 'Label:Label [
    none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat] =
    'get-lth-label['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]] [none] .
  eq 'get-ith-stackandlabel['_$_['Val:Value, 'ST:Stack], 'N:Nat, 'TempST:Stack]
    = 'get-ith-stackandlabel['ST:Stack, 'N:Nat, '_$_['TempST:Stack,
    'Val:Value]] [none] .
  eq 'get-ith-stackandlabel['_$_['label['Str:String, 'IL:List`{Inst`}, 'N:Nat],
    'ST:Stack], '0.Zero, 'TempST:Stack] = '_||_['_$_['reset-st-res[
    'TempST:Stack, 'N:Nat], 'ST:Stack], 'label['Str:String, 'IL:List`{Inst`},
    'N:Nat]] [none] .
  eq 'get-ith-stackandlabel['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat,
    'TempST:Stack] = 'get-ith-stackandlabel['ST:Stack, '_-_['NzN:NzNat, 's_[
    '0.Zero]], 'TempST:Stack] [none] .
  eq 'if-else['val['NzIntN:NzInt], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]] [none] .
  eq 'if-else['val['0.Zero], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL2:List`{Inst`}, 'end.Inst]] [owise] .
  eq 'get-IL-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-IL-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-localsref-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsref-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsTList-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef, 'local_[
    'TList:List`{TypeToken`}], 'IL:List`{Inst`}]] = 'TList:List`{TypeToken`} [
    none] .
  eq 'get-localsTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'local_['TList:List`{TypeToken`}], 'IL:List`{Inst`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsTList['local_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-paramlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'aux-get-paramlistTList['param_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-paramlistTList-func['FuncDef:FuncDef] = 'aux-get-paramlistTList[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'aux-get-resultlistTList['result_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-resultlistTList-func['FuncDef:FuncDef] = 'aux-get-resultlistTList[
    'get-resultlist-func['FuncDef:FuncDef]] [none] .
  eq 'count-locals-localsref['local_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-localsref['local_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-localsref['local_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-locals-paramlist['param_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-paramlist['param_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-paramlist['param_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-paramlist-func['FuncDef:FuncDef] = 'count-locals-paramlist[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'expand['type_['Id:Id], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, 'Id:Id]] [none] .
  eq 'expand['type_['Str:String], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, '_`[_`][
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'init-store['nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'init-store['NeTList:NeList`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'inizialize-store['0.Zero,
    'NeTList:NeList`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}] [
    none] .
  eq 'inizialize-store['N:Nat, 'nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat, 'const['T:TypeToken,
    'ValW1:ValWrapper], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}]] [
    none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'EmptyStack.EmptyStack, 'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat,
    'defaultVal['T:TypeToken], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'EmptyStack.EmptyStack,
    'LocalSTR:Map`{ValRef`,Value`}]] [none] .
  ceq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val1:Value if
    '_=/=_['Int1:Int, '0.Zero] = 'true.Bool [none] .
  eq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val2:Value [
    owise] .
  eq 'valid-stack['ST:Stack, 'nil.List`{TypeToken`}] = 'true.Bool [none] .
  eq 'valid-stack['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = 'valid-stack['ST:Stack,
    'TList:List`{TypeToken`}] [none] .
  eq 'valid-stack['ST:Stack, 'TList:List`{TypeToken`}] = 'false.Bool [owise] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod],
    'simulate-wasm['__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}],
    '_#_['__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['call_['N:Nat], 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_[
    'Str:String], 'ComponentCtr:ComponentCtr], '#_#_#['module_[
    'EmptyMod.EmptyMod], 'simulate-wasm['__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['call_['_`[_`][
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'Str:String]], 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'get-funcList['_`,_['FuncStore:Map`{Addr`,ModuleContent`}, '_|->_[
    'Addr:Addr, 'FuncDef:FuncDef]]] = '_`,_['FuncDef:FuncDef, 'get-funcList[
    'FuncStore:Map`{Addr`,ModuleContent`}]] [none] .
  eq 'get-funcList['empty.Map`{Addr`,ModuleContent`}] =
    'EmptyFuncDefL.EmptyFuncDefL [none] .
  eq 'verify-funcList['EmptyFuncDefL.EmptyFuncDefL,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'true.Bool [none] .
  eq 'verify-funcList['_`,_['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]]] [none]
    .
  eq 'verify-funcList['_`,_['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____[
    'Str:String, 'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef,
    'IL:List`{Inst`}]]]] [none] .
  eq 'verify-funcList['FuncDefL:FuncDefList,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'false.Bool [owise] .
  eq 'verify-IL['nil.List`{Inst`}, 'TListRes:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'T:TypeToken := 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef] [none] .
  ceq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T':TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  eq 'verify-IL['__['global.get_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-GlobalTypeToken['global-type['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  ceq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}], '__[
    'T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '__['MutGlobalTypeIndicator:MutGlobalTypeIndicator, 'T:TypeToken] :=
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], '__['T:TypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '__['IntT:IntTypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], '__['i64.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['nop.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  ceq 'verify-IL['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  ceq 'verify-IL['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], '__[
    'TListLabel:List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TListLabel:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  eq 'verify-IL['__['call_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}], '__[
    'TList':List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TList':List`{TypeToken`}, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]] = 'true.Bool [none] .
  ceq 'verify-IL['nil.List`{Inst`}, '__['TList:List`{TypeToken`},
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool if '__['TList:List`{TypeToken`}, 'TList':List`{TypeToken`}] :=
    'TListRes:List`{TypeToken`} [none] .
  eq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TList':List`{TypeToken`} := 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]] [none] .
  eq 'verify-IL['NeIL:NeList`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'false.Bool [owise] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], '0.Zero] = 'T:TypeToken
    [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], 'N:Nat] = 'nthT[
    'TList:List`{TypeToken`}, '_-_['N:Nat, 's_['0.Zero]]] [none] .
  eq 'nthResultT['result_['TList:List`{TypeToken`}], '0.Zero] =
    'TList:List`{TypeToken`} [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], '0.Zero] = 'TList:List`{TypeToken`}
    [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], 'NzN:NzNat] = 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, '_-_['NzN:NzNat, 's_['0.Zero]]] [
    none] .
  rl '<_|_|_>['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}], 'ST:Stack, '__[
    'LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, '_`[_`]['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef]],
    '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.get)] .
  rl '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'ST:Stack, '__['insert['ValR:ValRef, 'Val:Value,
    'LocalSTR:Map`{ValRef`,Value`}],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.set)] .
  rl '<_|_|_>['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], 'st-push[
    'st-push['ST:Stack, 'Val:Value], 'Val:Value],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('local.tee)] .
  rl '_#_['<_|_|_>['__['global.get_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'global-val['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] [label('global.get)] .
  crl '_#_['<_|_|_>['__['global.set_['Str:String], 'IL:List`{Inst`}], '_$_[
    'const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`}, 'insert['_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken], 'const['T:TypeToken,
    'ValW1:ValWrapper]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]] if '_==_[
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]], '__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken]] = 'true.Bool [label(
    'global.set)] .
  rl '<_|_|_>['__['drop.Inst, 'IL:List`{Inst`}], '_$_['Val:Value, 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('drop)] .
  rl '<_|_|_>['__['select.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW2:ValWrapper], '_$_['Val2:Value, '_$_['Val1:Value,
    'ST:Stack]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['selectVal['ValW2:ValWrapper, 'Val1:Value,
    'Val2:Value], 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('select)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('int-const)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken,
    'ValW1:ValWrapper]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if
    'ValW1:ValWrapper := 'unsigned['val['IntN:Int], 'bit-width[
    'IntT:IntTypeToken]] [label('int-const-signed)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'float['IntN:Int]],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] [
    label('int-as-float-const)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => 'if_then_else_fi['_=/=_['FloatN:Float, '0.0.FiniteFloat], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'correctFloat['const[
    'FloatT:FloatTypeToken, 'val['FloatN:Float]]]],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}], '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label(
    'float-const)] .
  crl '<_|_|_>['__['_.const_['v128.VecTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['v128.VecTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('vec-const)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper], 'und.Und], '<_|_|_>['IL:List`{Inst`}, 'st-push[
    'ST:Stack, 'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'trap['"Binop result undefined".String]] [label('t.binop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'unop['T:TypeToken, 'unopT:UnopToken,
    'ValW1:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('t.unop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'relop['T:TypeToken,
    'relopT:RelopToken, 'ValW1:ValWrapper, 'ValW2:ValWrapper]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.relop)] .
  rl '<_|_|_>['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '_$_['const['IntT:IntTypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'ieq['ValW1:ValWrapper,
    'val['0.Zero]]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.eqz)] .
  rl '<_|_|_>['__['_.__['T2:TypeToken, 'cvtopT:CvtopToken, 'T1:TypeToken],
    'IL:List`{Inst`}], '_$_['const['T1:TypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    'if_then_else_fi['_=/=_['cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper], 'und.Und], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], 'trap[
    '"Cvtop result undefined".String]] [label('t1.cvtop_t2)] .
  rl '<_|_|_>['__['nop.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('nop)] .
  rl '<_|_|_>['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"block".String, 'nil.List`{Inst`}, 'size['aux-get-resultlistTList[
    'ResultType:ResultType]]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]
    [label('block-resultT)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['block_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"block".String, 'nil.List`{Inst`}, 'size[
    'TListRes:List`{TypeToken`}]], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListRes:List`{TypeToken`} := 'aux-get-resultlistTList[
    'getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('block-tref)] .
  rl '<_|_|_>['exit-block['IL:List`{Inst`}], 'NeST:NeStack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'get-st['reset-st['NeST:NeStack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('end)] .
  rl '<_|_|_>['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__['if-else[
    'ValW1:ValWrapper, 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('if-else)] .
  rl '<_|_|_>['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"loop".String, '__['loop_['ResultType:ResultType], '__[
    'IL2:List`{Inst`}, 'end.Inst]], '0.Zero]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('loop-resultT)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['loop_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"loop".String, '__['loop_['TypeRef:TypeRef], '__[
    'IL2:List`{Inst`}, 'end.Inst]], 'size['TListParam:List`{TypeToken`}]],
    'ST:Stack]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListParam:List`{TypeToken`} := 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('loop-tref)] .
  crl '<_|_|_>['__['br_['N:Nat], 'IL2:List`{Inst`}, 'exit-block[
    'IL:List`{Inst`}], 'IL':List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL1:List`{Inst`}, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] if '_||_['ST1:Stack,
    'label['Str:String, 'IL1:List`{Inst`}, 'N1:Nat]] := 'get-ith-stackandlabel[
    'ST:Stack, 'N:Nat, 'EmptyStack.EmptyStack] [label('br)] .
  rl '<_|_|_>['__['br~if_['N:Nat], 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'val['Int1:Int]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'Int1:Int, '0.Zero], '<_|_|_>['__['br_['N:Nat], 'IL:List`{Inst`}],
    'ST:Stack, 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]] [label('br_if)] .
  rl '_#_['_#_['<_|_|_>['__['call_['Addr:Addr], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['__['get-IL-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]], '__['exit-func[
    'get-resultlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]]], 'exit-block['IL:List`{Inst`}]]], '_$_['label['"func".String,
    'nil.List`{Inst`}, 'size['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]], 'st-popN['ST:Stack,
    'size['get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]]], '__['init-store[
    '__['get-paramlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]], 'get-localsTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]], 'st-getTopVals[
    'ST:Stack, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]],
    'empty.Map`{ValRef`,Value`}], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}] [
    label('call)] .
  rl '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    => '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    [label('call-by-name)] .
  crl '_#_['_#_['<_|_|_>['__['exit-func['TypeTokenList:List`{TypeToken`}],
    'IL:List`{Inst`}], 'ST:Stack, '__['LocalSTR:Map`{ValRef`,Value`},
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    if 'valid-stack['ST:Stack, 'reverse['TypeTokenList:List`{TypeToken`}]] =
    'true.Bool [label('exit-func)] .
endm
*********** equation
eq gen-config(WASMModFile) = <> < myObj : myClass | in: nullOid, inFile:
    WASMModFile, outText: "" > openFile(fileManager, myObj, WASMModFile, "r") .
WASMModFile --> "examples/factorial_valid_br_jump.wat"
gen-config("examples/factorial_valid_br_jump.wat")
--->
<> < myObj : myClass | in: nullOid, inFile:
    "examples/factorial_valid_br_jump.wat", outText: "" > openFile(fileManager,
    myObj, "examples/factorial_valid_br_jump.wat", "r")
*********** rule
rl < myObj : myClass | Attrs, in: nullOid, outText: Acc > openedFile(myObj,
    fileManager, FHIn) => getLine(FHIn, myObj) < myObj : myClass | in: FHIn,
    Attrs, outText: Acc > .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
Acc --> ""
FHIn --> file(3)
< myObj : myClass | in: nullOid, inFile:
    "examples/factorial_valid_br_jump.wat", outText: "" > openedFile(myObj,
    fileManager, file(3))
--->
getLine(file(3), myObj) < myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "" >
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> ""
Text --> "(module\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "" > gotLine(myObj, file(
    3), "(module\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("" + "(module\n") > if
    "(module\n" == "" then closeFile(file(3), myObj) else getLine(file(3),
    myObj) fi
*********** equation
(built-in equation for symbol _+_)
"" + "(module\n"
--->
"(module\n"
*********** equation
(built-in equation for symbol _==_)
"(module\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n"
Text --> "      (type $type0 (func (result i64)))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n" > gotLine(
    myObj, file(3), "      (type $type0 (func (result i64)))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n" +
    "      (type $type0 (func (result i64)))\n") > if
    "      (type $type0 (func (result i64)))\n" == "" then closeFile(file(3),
    myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n" + "      (type $type0 (func (result i64)))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n"
*********** equation
(built-in equation for symbol _==_)
"      (type $type0 (func (result i64)))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n"
Text --> "      (type $type1 (func (param i64) (result i64)))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText:
    "(module\n      (type $type0 (func (result i64)))\n" > gotLine(myObj, file(
    3), "      (type $type1 (func (param i64) (result i64)))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: (
    "(module\n      (type $type0 (func (result i64)))\n" +
    "      (type $type1 (func (param i64) (result i64)))\n") > if
    "      (type $type1 (func (param i64) (result i64)))\n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n" +
    "      (type $type1 (func (param i64) (result i64)))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n"
*********** equation
(built-in equation for symbol _==_)
"      (type $type1 (func (param i64) (result i64)))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n"
Text --> "      (type $type2 (func (param i64) (result i64)))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n"
    > gotLine(myObj, file(3),
    "      (type $type2 (func (param i64) (result i64)))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n"
    + "      (type $type2 (func (param i64) (result i64)))\n") > if
    "      (type $type2 (func (param i64) (result i64)))\n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n" +
    "      (type $type2 (func (param i64) (result i64)))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n"
*********** equation
(built-in equation for symbol _==_)
"      (type $type2 (func (param i64) (result i64)))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n"
Text --> "      (export \"$start\" (func 0))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n" > gotLine(myObj, file(3),
    "      (export \"$start\" (func 0))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n" +
    "      (export \"$start\" (func 0))\n") > if
    "      (export \"$start\" (func 0))\n" == "" then closeFile(file(3), myObj)
    else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n"
    + "      (export \"$start\" (func 0))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n"
*********** equation
(built-in equation for symbol _==_)
"      (export \"$start\" (func 0))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n"
Text --> "      (func $start (result i64)\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n" > gotLine(myObj, file(3), "      (func $start (result i64)\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n" + "      (func $start (result i64)\n") > if
    "      (func $start (result i64)\n" == "" then closeFile(file(3), myObj)
    else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n" + "      (func $start (result i64)\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n"
*********** equation
(built-in equation for symbol _==_)
"      (func $start (result i64)\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n"
Text --> "        (local i32)\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n" > gotLine(myObj, file(3),
    "        (local i32)\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n" + "        (local i32)\n") > if
    "        (local i32)\n" == "" then closeFile(file(3), myObj) else getLine(
    file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n" +
    "        (local i32)\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n"
*********** equation
(built-in equation for symbol _==_)
"        (local i32)\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n"
Text --> "        \n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n" > gotLine(myObj,
    file(3), "        \n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n" + "        \n")
    > if "        \n" == "" then closeFile(file(3), myObj) else getLine(file(
    3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n" + "        \n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n"
*********** equation
(built-in equation for symbol _==_)
"        \n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n"
Text --> "            i64.const 5\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n" >
    gotLine(myObj, file(3), "            i64.const 5\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n" +
    "            i64.const 5\n") > if "            i64.const 5\n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n" + "            i64.const 5\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n"
*********** equation
(built-in equation for symbol _==_)
"            i64.const 5\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n"
Text --> "            global.set $gb1\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n" > gotLine(myObj, file(3), "            global.set $gb1\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n" + "            global.set $gb1\n") > if
    "            global.set $gb1\n" == "" then closeFile(file(3), myObj) else
    getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n" + "            global.set $gb1\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n"
*********** equation
(built-in equation for symbol _==_)
"            global.set $gb1\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n"
Text --> "            global.get $gb1\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n" > gotLine(myObj, file(3),
    "            global.get $gb1\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n" +
    "            global.get $gb1\n") > if "            global.get $gb1\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n" +
    "            global.get $gb1\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n"
*********** equation
(built-in equation for symbol _==_)
"            global.get $gb1\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n"
Text --> "            block (type $type2)\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n" >
    gotLine(myObj, file(3), "            block (type $type2)\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n" +
    "            block (type $type2)\n") > if
    "            block (type $type2)\n" == "" then closeFile(file(3), myObj)
    else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n" + "            block (type $type2)\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n"
*********** equation
(built-in equation for symbol _==_)
"            block (type $type2)\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n"
Text --> "            br 0\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n" > gotLine(myObj, file(3), "            br 0\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n" + "            br 0\n") > if "            br 0\n"
    == "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n" + "            br 0\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n"
*********** equation
(built-in equation for symbol _==_)
"            br 0\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n"
Text --> "            call $factorial\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n" > gotLine(myObj, file(3),
    "            call $factorial\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n" +
    "            call $factorial\n") > if "            call $factorial\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n" +
    "            call $factorial\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n"
*********** equation
(built-in equation for symbol _==_)
"            call $factorial\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n"
Text --> "            end\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n" >
    gotLine(myObj, file(3), "            end\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n" +
    "            end\n") > if "            end\n" == "" then closeFile(file(3),
    myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n" + "            end\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n"
*********** equation
(built-in equation for symbol _==_)
"            end\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n"
Text --> "            \n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n" > gotLine(myObj, file(3), "            \n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n" + "            \n") > if "            \n" == "" then closeFile(
    file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n" + "            \n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n"
*********** equation
(built-in equation for symbol _==_)
"            \n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n"
Text --> "        \n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n" > gotLine(myObj, file(3), "        \n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n" + "        \n") > if "        \n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n" + "        \n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n"
*********** equation
(built-in equation for symbol _==_)
"        \n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n"
Text --> "        )\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n" > gotLine(myObj, file(3), "        )\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n" + "        )\n") > if "        )\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n" + "        )\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n"
*********** equation
(built-in equation for symbol _==_)
"        )\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n"
Text --> "      (func $factorial (type $type1)\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n" > gotLine(myObj, file(3),
    "      (func $factorial (type $type1)\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n" +
    "      (func $factorial (type $type1)\n") > if
    "      (func $factorial (type $type1)\n" == "" then closeFile(file(3),
    myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n" +
    "      (func $factorial (type $type1)\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n"
*********** equation
(built-in equation for symbol _==_)
"      (func $factorial (type $type1)\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n"
Text --> "        \n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n" > gotLine(myObj, file(3), "        \n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n" + "        \n") > if "        \n" == "" then closeFile(file(3), myObj)
    else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n" + "        \n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n"
*********** equation
(built-in equation for symbol _==_)
"        \n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n"
Text --> "            i64.const 0\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n" > gotLine(myObj, file(3), "            i64.const 0\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n" + "            i64.const 0\n") > if "            i64.const 0\n"
    == "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n" + "            i64.const 0\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n"
*********** equation
(built-in equation for symbol _==_)
"            i64.const 0\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n"
Text --> "            local.get 0\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n" > gotLine(myObj, file(3),
    "            local.get 0\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n" + "            local.get 0\n") > if
    "            local.get 0\n" == "" then closeFile(file(3), myObj) else
    getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n" +
    "            local.get 0\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n"
*********** equation
(built-in equation for symbol _==_)
"            local.get 0\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n"
Text --> "            i64.eq\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n" > gotLine(
    myObj, file(3), "            i64.eq\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n" +
    "            i64.eq\n") > if "            i64.eq\n" == "" then closeFile(
    file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n" + "            i64.eq\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n"
*********** equation
(built-in equation for symbol _==_)
"            i64.eq\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n"
Text --> "            if (result i64)\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n" > gotLine(myObj, file(3), "            if (result i64)\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n" + "            if (result i64)\n") > if "            if (result i64)\n"
    == "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n" + "            if (result i64)\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n"
*********** equation
(built-in equation for symbol _==_)
"            if (result i64)\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n"
Text --> "                i64.const 1\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n" > gotLine(myObj, file(3),
    "                i64.const 1\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n" + "                i64.const 1\n") > if
    "                i64.const 1\n" == "" then closeFile(file(3), myObj) else
    getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n" +
    "                i64.const 1\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n"
*********** equation
(built-in equation for symbol _==_)
"                i64.const 1\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n"
Text --> "            else\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n" > gotLine(myObj,
    file(3), "            else\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n" +
    "            else\n") > if "            else\n" == "" then closeFile(file(
    3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n" + "            else\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n"
*********** equation
(built-in equation for symbol _==_)
"            else\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n"
Text --> "                local.get 0\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n" > gotLine(myObj, file(3), "                local.get 0\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n" + "                local.get 0\n") > if "                local.get 0\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n" + "                local.get 0\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n"
*********** equation
(built-in equation for symbol _==_)
"                local.get 0\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n"
Text --> "                local.get 0\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n" > gotLine(myObj, file(3),
    "                local.get 0\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n" + "                local.get 0\n") > if
    "                local.get 0\n" == "" then closeFile(file(3), myObj) else
    getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n" +
    "                local.get 0\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n"
*********** equation
(built-in equation for symbol _==_)
"                local.get 0\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n"
Text --> "                i64.const 1\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n" > gotLine(myObj,
    file(3), "                i64.const 1\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n" +
    "                i64.const 1\n") > if "                i64.const 1\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n" + "                i64.const 1\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n"
*********** equation
(built-in equation for symbol _==_)
"                i64.const 1\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n"
Text --> "                i64.sub\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n" > gotLine(myObj, file(3), "                i64.sub\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n" + "                i64.sub\n") > if "                i64.sub\n" == ""
    then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n" + "                i64.sub\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n"
*********** equation
(built-in equation for symbol _==_)
"                i64.sub\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n"
Text --> "                call $factorial\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n" > gotLine(myObj, file(3),
    "                call $factorial\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n" + "                call $factorial\n") > if
    "                call $factorial\n" == "" then closeFile(file(3), myObj)
    else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n" +
    "                call $factorial\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n"
*********** equation
(built-in equation for symbol _==_)
"                call $factorial\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n"
Text --> "                i64.mul\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n" > gotLine(
    myObj, file(3), "                i64.mul\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n" +
    "                i64.mul\n") > if "                i64.mul\n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n" + "                i64.mul\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n"
*********** equation
(built-in equation for symbol _==_)
"                i64.mul\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n"
Text --> "            end\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n" > gotLine(myObj, file(3), "            end\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n" + "            end\n") > if "            end\n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n" + "            end\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n"
*********** equation
(built-in equation for symbol _==_)
"            end\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n"
Text --> "        \n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n" > gotLine(myObj, file(3), "        \n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n" + "        \n") > if "        \n" == "" then
    closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n" + "        \n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n"
*********** equation
(built-in equation for symbol _==_)
"        \n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n"
Text --> "        )\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n" > gotLine(myObj, file(3), "        )\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n" + "        )\n") > if "        )\n" ==
    "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n" +
    "        )\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n"
*********** equation
(built-in equation for symbol _==_)
"        )\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n"
Text --> "      (global $gb1 (mut i64) (i64.const 1))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n" > gotLine(myObj, file(3),
    "      (global $gb1 (mut i64) (i64.const 1))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n" +
    "      (global $gb1 (mut i64) (i64.const 1))\n") > if
    "      (global $gb1 (mut i64) (i64.const 1))\n" == "" then closeFile(file(
    3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n" +
    "      (global $gb1 (mut i64) (i64.const 1))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n"
*********** equation
(built-in equation for symbol _==_)
"      (global $gb1 (mut i64) (i64.const 1))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n"
Text --> "      (global $result (mut i64) (i64.const 1))\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n" > gotLine(myObj, file(3),
    "      (global $result (mut i64) (i64.const 1))\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n" + "      (global $result (mut i64) (i64.const 1))\n") > if
    "      (global $result (mut i64) (i64.const 1))\n" == "" then closeFile(
    file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n" +
    "      (global $result (mut i64) (i64.const 1))\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n"
*********** equation
(built-in equation for symbol _==_)
"      (global $result (mut i64) (i64.const 1))\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n"
Text --> ")\n"
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n" > gotLine(myObj,
    file(3), ")\n")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n" + ")\n") > if
    ")\n" == "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n" + ")\n"
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"
*********** equation
(built-in equation for symbol _==_)
")\n" == ""
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
getLine(file(3), myObj)
*********** rule
rl < myObj : myClass | Attrs, in: FHIn, outText: Acc > gotLine(myObj, FHIn,
    Text) => < myObj : myClass | in: FHIn, Attrs, outText: (Acc + Text) > if
    Text == "" then closeFile(FHIn, myObj) else getLine(FHIn, myObj) fi .
Attrs --> inFile: "examples/factorial_valid_br_jump.wat"
FHIn --> file(3)
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"
Text --> ""
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n" > gotLine(
    myObj, file(3), "")
--->
< myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: ("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n" + "") > if ""
    == "" then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
*********** equation
(built-in equation for symbol _+_)
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n" + ""
--->
"(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"
*********** equation
(built-in equation for symbol _==_)
"" == ""
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then closeFile(file(3), myObj) else getLine(file(3), myObj) fi
--->
closeFile(file(3), myObj)
*********** equation
eq aux-metaSearch(Module, <> closedFile(myObj, FHIn) < myObj : myClass | Attrs,
    outText: Acc >, Func, ResTerm, Condition, SearchType, maxDepth, solNumber)
    = metaSearch(Module, upTerm(run-module-func(downTerm(getTerm(metaParse([
    'WASMMOD], tokenize-wasm(Acc), 'WASMModule)), errorMod), Func)), ResTerm,
    Condition, SearchType, maxDepth, solNumber) .
Module --> mod 'WASMMOD is
  including 'BOOL .
  protecting 'WASM-MODULECONTENT-MOD .
  protecting 'WASM-VERIFYFUNCDEF-MOD .
  protecting 'MAP{'ValRef, 'Value} .
  protecting 'LIST{'Map{'ValRef, 'Value}} .
  protecting 'MAP{'String, 'Addr} .
  protecting 'MAP{'Addr, 'GlobalInstance} .
  sorts 'ComponentCtr ; 'EmptyStack ; 'FuncIndCtx ; 'FuncStore ; 'GlobalIndCtx
    ; 'GlobalInventory ; 'IndCtx ; 'Label ; 'LocalIndCtx ; 'NeStack ; 'Stack ;
    'StackAndLabel ; 'StackElem ; 'Starter ; 'TypeIndCtx ;
    'WASMFuncGlobalIndSim ; 'WASMFuncGlobalSim ; 'WASMGlobalIndSim ;
    'WASMGlobalSim ; 'WASMLocalIndSim ; 'WASMLocalSim ; 'WASMModule ; 'WASMSim
    ; 'WASMSimTrigger ; 'WASMTypeFuncGlobalIndSim ; 'WASMTypeFuncGlobalSim ;
    'WasmTrigger .
  subsort 'EmptyStack < 'Stack .
  subsort 'FuncIndCtx < 'IndCtx .
  subsort 'GlobalIndCtx < 'IndCtx .
  subsort 'Label < 'StackElem .
  subsort 'List`{Inst`} < 'WASMLocalSim .
  subsort 'LocalIndCtx < 'IndCtx .
  subsort 'NeStack < 'Stack .
  subsort 'Stack < 'WASMLocalSim .
  subsort 'StackElem < 'NeStack .
  subsort 'TypeIndCtx < 'IndCtx .
  subsort 'Und < 'Label .
  subsort 'Value < 'StackElem .
  op '#_#_# : 'WASMModule 'WASMTypeFuncGlobalIndSim -> 'WASMSim [ctor format(
    'ni 'ni 'ni 'ni 'ni 'ni)] .
  op '<_|_|_> : 'List`{Inst`} 'Stack 'Map`{ValRef`,Value`} -> 'WASMLocalSim [
    ctor format('ni 'd 'd 'd 'd 'd 'd 'd)] .
  op 'EmptyStack : nil -> 'EmptyStack [ctor] .
  op 'Fail : 'String -> 'WASMSimTrigger [ctor] .
  op '_#_ : 'WASMFuncGlobalIndSim 'Map`{Addr`,ModuleContent`} ->
    'WASMTypeFuncGlobalSim [ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMGlobalSim 'Map`{Addr`,ModuleContent`} -> 'WASMFuncGlobalSim [
    ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMLocalSim 'GlobalInventory -> 'WASMGlobalSim [ctor format('d
    'ni 'ni 'd)] .
  op '_$_ : 'StackElem 'Stack -> 'NeStack [ctor id('EmptyStack.EmptyStack)
    format('d 'ni 'd 'd)] .
  op '_<->_ : 'Map`{String`,Addr`} 'Map`{Addr`,GlobalInstance`} ->
    'GlobalInventory [ctor] .
  op '__ : 'FuncIndCtx 'WASMFuncGlobalSim -> 'WASMFuncGlobalIndSim [ctor] .
  op '__ : 'LocalIndCtx 'WASMLocalSim -> 'WASMLocalIndSim [ctor] .
  op '__ : 'TypeIndCtx 'WASMTypeFuncGlobalSim -> 'WASMTypeFuncGlobalIndSim [
    ctor] .
  op '__ : 'WasmTrigger 'WASMSim -> 'WASMSimTrigger [ctor format('ni 'ni 'ni)]
    .
  op '_||_ : 'Stack 'Label -> 'StackAndLabel [none] .
  op '`[_`,_`,_`] : 'Nat 'Nat 'Nat -> 'ComponentCtr [ctor] .
  op '`{_`,indctr_`} : 'Starter 'ComponentCtr -> 'WasmTrigger [ctor] .
  op '`{funcIndCtx_`} : 'Map`{String`,Addr`} -> 'FuncIndCtx [ctor] .
  op '`{localIndCtx_`} : 'Map`{String`,Addr`} -> 'LocalIndCtx [ctor] .
  op '`{typeIndCtx_`} : 'Map`{String`,Addr`} -> 'TypeIndCtx [ctor] .
  op 'aux-get-paramlistTList : 'ParamType -> 'List`{TypeToken`} [none] .
  op 'aux-get-resultlistTList : 'ResultType -> 'List`{TypeToken`} [none] .
  op 'count-locals-localsref : 'LocalsRef -> 'Nat [none] .
  op 'count-locals-paramlist : 'ParamType -> 'Nat [none] .
  op 'count-paramlist-func : 'FuncDef -> 'Nat [none] .
  op 'errorMod : nil -> '`[WASMModule`] [none] .
  op 'errorWASMSimTrigger : nil -> '`[WASMSimTrigger`] [none] .
  op 'exit-block : 'List`{Inst`} -> 'Inst [ctor] .
  op 'exit-func : 'List`{TypeToken`} -> 'Inst [ctor] .
  op 'expand : 'BlockType 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`} ->
    'ParamResultType [none] .
  op 'get-IL-func : 'FuncDef -> 'List`{Inst`} [none] .
  op 'get-funcList : 'Map`{Addr`,ModuleContent`} -> 'FuncDefList [none] .
  op 'get-inst-list-label : 'StackAndLabel -> 'List`{Inst`} [none] .
  op 'get-ith-stackandlabel : 'Stack 'Nat 'Stack -> 'StackAndLabel [none] .
  op 'get-label : 'StackAndLabel -> 'Label [none] .
  op 'get-localsTList : 'LocalsRef -> 'List`{TypeToken`} [none] .
  op 'get-localsTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-localsref-func : 'FuncDef -> 'LocalsRef [none] .
  op 'get-lth-label : 'Stack 'Nat -> 'Label [none] .
  op 'get-paramlist-func : 'FuncDef -> 'ParamType [none] .
  op 'get-paramlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-resultlist-func : 'FuncDef -> 'ResultType [none] .
  op 'get-resultlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-st : 'StackAndLabel -> 'Stack [none] .
  op 'global-type : 'GlobalInstance -> 'GlobalType [none] .
  op 'global-val : 'GlobalInstance -> 'Value [none] .
  op 'head : 'NeList`{Inst`} -> 'Inst [none] .
  op 'if-else : 'ValWrapper 'List`{Inst`} 'List`{Inst`} 'BlockType ->
    'List`{Inst`} [none] .
  op 'init-store : 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`} ->
    'Map`{ValRef`,Value`} [none] .
  op 'inizialize-store : 'Nat 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`}
    -> 'Map`{ValRef`,Value`} [none] .
  op 'insert : 'String 'Nat 'IndCtx -> 'IndCtx [none] .
  op 'jump-to-L : 'StackAndLabel -> 'Inst [ctor] .
  op 'label : 'String 'List`{Inst`} 'Nat -> 'Label [ctor] .
  op 'lookup : 'Map`{ValRef`,Value`} 'ValRef -> 'Value [none] .
  op 'module_ : 'ModuleContent -> 'WASMModule [ctor prec(20)] .
  op 'nthResultT : 'ResultTypeList 'Nat -> 'List`{TypeToken`} [none] .
  op 'nthT : 'List`{TypeToken`} 'Nat -> 'TypeToken [none] .
  op 'read-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'reset-st : 'Stack -> 'StackAndLabel [none] .
  op 'reset-st-res : 'Stack 'Nat -> 'Stack [none] .
  op 'run-module-func : 'WASMModule 'Nat -> 'WASMSimTrigger [none] .
  op 'run-module-func : 'WASMModule 'String -> 'WASMSimTrigger [none] .
  op 'run-nomodule : 'List`{Inst`} -> 'WASMTypeFuncGlobalSim [none] .
  op 'selectVal : 'ValWrapper 'Value 'Value -> 'Value [none] .
  op 'simulate-wasm : 'WASMTypeFuncGlobalIndSim -> 'WASMTypeFuncGlobalIndSim [
    none] .
  op 'st-getTopVals : 'Stack 'List`{TypeToken`} -> 'Stack [none] .
  op 'st-head : 'NeStack -> 'StackElem [none] .
  op 'st-pop : 'NeStack -> 'Stack [none] .
  op 'st-popN : 'Stack 'Nat -> 'Stack [none] .
  op 'st-push : 'Stack 'StackElem -> 'NeStack [none] .
  op 'st-rev : 'Stack -> 'Stack [none] .
  op 'start_ : 'Nat -> 'Starter [ctor] .
  op 'start_ : 'String -> 'Starter [ctor] .
  op 'tail : 'NeList`{Inst`} -> 'List`{Inst`} [none] .
  op 'uninitialized : nil -> 'Inst [ctor] .
  op 'valid-stack : 'Stack 'List`{TypeToken`} -> 'Bool [none] .
  op 'validate-funcs-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'verify-IL : 'List`{Inst`} 'List`{TypeToken`} 'List`{TypeToken`}
    'List`{TypeToken`} 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{Addr`,GlobalInstance`} 'Map`{String`,Addr`} 'ResultTypeList -> 'Bool
    [none] .
  op 'verify-funcList : 'FuncDefList 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{Addr`,GlobalInstance`}
    'Map`{String`,Addr`} -> 'Bool [none] .
  none
  eq 'aux-get-paramlistTList['param_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'aux-get-resultlistTList['result_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'block_['TList:List`{TypeToken`}] = 'block_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'count-locals-localsref['local_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-localsref['local_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-localsref['local_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-locals-paramlist['param_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-paramlist['param_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-paramlist['param_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-paramlist-func['FuncDef:FuncDef] = 'count-locals-paramlist[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'expand['type_['Id:Id], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, 'Id:Id]] [none] .
  eq 'expand['type_['Str:String], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, '_`[_`][
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'get-IL-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-IL-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-funcList['empty.Map`{Addr`,ModuleContent`}] =
    'EmptyFuncDefL.EmptyFuncDefL [none] .
  eq 'get-funcList['_`,_['FuncStore:Map`{Addr`,ModuleContent`}, '_|->_[
    'Addr:Addr, 'FuncDef:FuncDef]]] = '_`,_['FuncDef:FuncDef, 'get-funcList[
    'FuncStore:Map`{Addr`,ModuleContent`}]] [none] .
  eq 'get-inst-list-label['_||_['ST:Stack, 'label['Str:String,
    'IL:List`{Inst`}, 'N:Nat]]] = 'IL:List`{Inst`} [none] .
  eq 'get-ith-stackandlabel['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat,
    'TempST:Stack] = 'get-ith-stackandlabel['ST:Stack, '_-_['NzN:NzNat, 's_[
    '0.Zero]], 'TempST:Stack] [none] .
  eq 'get-ith-stackandlabel['_$_['Val:Value, 'ST:Stack], 'N:Nat, 'TempST:Stack]
    = 'get-ith-stackandlabel['ST:Stack, 'N:Nat, '_$_['TempST:Stack,
    'Val:Value]] [none] .
  eq 'get-ith-stackandlabel['_$_['label['Str:String, 'IL:List`{Inst`}, 'N:Nat],
    'ST:Stack], '0.Zero, 'TempST:Stack] = '_||_['_$_['reset-st-res[
    'TempST:Stack, 'N:Nat], 'ST:Stack], 'label['Str:String, 'IL:List`{Inst`},
    'N:Nat]] [none] .
  eq 'get-label['_||_['ST:Stack, 'Label:Label]] = 'Label:Label [none] .
  eq 'get-label['_||_['ST:Stack, 'und.Und]] = 'und.Und [none] .
  eq 'get-localsTList['local_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsTList-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef, 'local_[
    'TList:List`{TypeToken`}], 'IL:List`{Inst`}]] = 'TList:List`{TypeToken`} [
    none] .
  eq 'get-localsTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'local_['TList:List`{TypeToken`}], 'IL:List`{Inst`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsref-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsref-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], '0.Zero] = 'Label:Label [
    none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat] =
    'get-lth-label['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]] [none] .
  eq 'get-lth-label['_$_['Val:Value, 'ST:Stack], 'N:Nat] = 'get-lth-label[
    'ST:Stack, 'N:Nat] [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlistTList-func['FuncDef:FuncDef] = 'aux-get-paramlistTList[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlistTList-func['FuncDef:FuncDef] = 'aux-get-resultlistTList[
    'get-resultlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-st['_||_['ST:Stack, 'Label:Label]] = 'ST:Stack [none] .
  eq 'get-st['_||_['ST:Stack, 'und.Und]] = 'ST:Stack [none] .
  eq 'global-type['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'GlobalType:GlobalType [none] .
  eq 'global-val['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'Val:Value [none] .
  eq 'head['__['I1:Inst, 'IL:List`{Inst`}]] = 'I1:Inst [none] .
  eq 'if-else['val['0.Zero], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL2:List`{Inst`}, 'end.Inst]] [owise] .
  eq 'if-else['val['NzIntN:NzInt], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]] [none] .
  eq 'if_['TList:List`{TypeToken`}] = 'if_['result_['TList:List`{TypeToken`}]]
    [none] .
  eq 'init-store['NeTList:NeList`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'inizialize-store['0.Zero,
    'NeTList:NeList`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}] [
    none] .
  eq 'init-store['nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, 'nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'EmptyStack.EmptyStack, 'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat,
    'defaultVal['T:TypeToken], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'EmptyStack.EmptyStack,
    'LocalSTR:Map`{ValRef`,Value`}]] [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat, 'const['T:TypeToken,
    'ValW1:ValWrapper], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}]] [
    none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}]] = '`{funcIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndFuncCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}]] = '`{typeIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndTypeCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'lookup['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] = '_`[_`][
    'LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] [none] .
  eq 'loop_['TList:List`{TypeToken`}] = 'loop_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], '0.Zero] = 'TList:List`{TypeToken`}
    [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], 'NzN:NzNat] = 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, '_-_['NzN:NzNat, 's_['0.Zero]]] [
    none] .
  eq 'nthResultT['result_['TList:List`{TypeToken`}], '0.Zero] =
    'TList:List`{TypeToken`} [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], '0.Zero] = 'T:TypeToken
    [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], 'N:Nat] = 'nthT[
    'TList:List`{TypeToken`}, '_-_['N:Nat, 's_['0.Zero]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'ExportDef:ExportDef]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    '0.0.FiniteFloat]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    'FloatN:Float]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'FloatN:Float]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken, 'IntN:Int]]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['__['ModuleContent:ModuleContent,
    'global__`(_`)['Str:String, 'GlobalType:GlobalType, '_.const_[
    'FloatT:FloatTypeToken, 'float['IntN:Int]]]]], '__['IndTypeCtx:TypeIndCtx,
    '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Id:Id, 'FuncType:FuncType]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__['Id:Id,
    'FuncType:FuncType], 'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Str:String, 'FuncType:FuncType]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['insert['Str:String, 'TCtr:Nat,
    'IndTypeCtx:TypeIndCtx], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__[
    'Str:String, 'FuncType:FuncType],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['N:Nat], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['Str:String], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'reset-st['EmptyStack.EmptyStack] = '_||_['EmptyStack.EmptyStack,
    'und.Und] [none] .
  eq 'reset-st['_$_['Label:Label, 'ST:Stack]] = '_||_['ST:Stack, 'Label:Label]
    [none] .
  eq 'reset-st['_$_['Val:Value, 'ST:Stack]] = '_||_['_$_['Val:Value, 'get-st[
    'reset-st['ST:Stack]]], 'get-label['reset-st['ST:Stack]]] [none] .
  eq 'reset-st-res['EmptyStack.EmptyStack, 'N:Nat] = 'EmptyStack.EmptyStack [
    none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], '0.Zero] =
    'EmptyStack.EmptyStack [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], 'NzN:NzNat] = '_$_['Val:Value,
    'reset-st-res['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]]] [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'N:Nat] = 'read-module['__[
    '`{_`,indctr_`}['start_['N:Nat], '`[_`,_`,_`]['0.Zero, '0.Zero, '0.Zero]],
    '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'Str:String] = 'read-module['__[
    '`{_`,indctr_`}['start_['Str:String], '`[_`,_`,_`]['0.Zero, '0.Zero,
    '0.Zero]], '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-nomodule['IL:List`{Inst`}] = '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['IL:List`{Inst`},
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}] [
    none] .
  eq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val2:Value [
    owise] .
  eq 'simulate-wasm['WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim] =
    'WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim [none] .
  eq 'st-getTopVals['ST:Stack, 'nil.List`{TypeToken`}] = 'EmptyStack.EmptyStack
    [none] .
  eq 'st-getTopVals['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'st-getTopVals['ST:Stack, 'TList:List`{TypeToken`}]] [
    none] .
  eq 'st-head['_$_['STElem:StackElem, 'ST:Stack]] = 'STElem:StackElem [none] .
  eq 'st-pop['_$_['STElem:StackElem, 'ST:Stack]] = 'ST:Stack [none] .
  eq 'st-popN['ST:Stack, '0.Zero] = 'ST:Stack [none] .
  eq 'st-push['EmptyStack.EmptyStack, 'STElem:StackElem] = 'STElem:StackElem [
    none] .
  eq 'st-push['ST:Stack, 'STElem:StackElem] = '_$_['STElem:StackElem,
    'ST:Stack] [none] .
  eq 'st-rev['EmptyStack.EmptyStack] = 'EmptyStack.EmptyStack [none] .
  eq 'st-rev['_$_['STElem:StackElem, 'ST:Stack]] = '_$_['st-rev['ST:Stack],
    'STElem:StackElem] [none] .
  eq 'tail['__['I1:Inst, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'valid-stack['ST:Stack, 'TList:List`{TypeToken`}] = 'false.Bool [owise] .
  eq 'valid-stack['ST:Stack, 'nil.List`{TypeToken`}] = 'true.Bool [none] .
  eq 'valid-stack['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = 'valid-stack['ST:Stack,
    'TList:List`{TypeToken`}] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod],
    'simulate-wasm['__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}],
    '_#_['__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['call_['N:Nat], 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_[
    'Str:String], 'ComponentCtr:ComponentCtr], '#_#_#['module_[
    'EmptyMod.EmptyMod], 'simulate-wasm['__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['call_['_`[_`][
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'Str:String]], 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'verify-IL['NeIL:NeList`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'false.Bool [owise] .
  eq 'verify-IL['nil.List`{Inst`}, 'TListRes:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool [none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], '__['T:TypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['nop.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '__['IntT:IntTypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], '__['i64.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['call_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.get_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-GlobalTypeToken['global-type['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-funcList['EmptyFuncDefL.EmptyFuncDefL,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'true.Bool [none] .
  eq 'verify-funcList['FuncDefL:FuncDefList,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'false.Bool [owise] .
  eq 'verify-funcList['_`,_['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]]] [none]
    .
  eq 'verify-funcList['_`,_['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____[
    'Str:String, 'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef,
    'IL:List`{Inst`}]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['Id:Id, 'func____[
    'Id:Id, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['insert[
    'Str:String, 'FCtr:Nat, 'IndFuncCtx:FuncIndCtx], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['FCtr:Nat, 'func____[
    'Str:String, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'ValW1:ValWrapper]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'ValW1:ValWrapper :=
    'unsigned['val['IntN:Int], 'bit-width['IntT:IntTypeToken]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['v128.VecTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['v128.VecTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val1:Value if
    '_=/=_['Int1:Int, '0.Zero] = 'true.Bool [none] .
  ceq 'st-popN['_$_['STElem:StackElem, 'ST:Stack], 'N:Nat] = 'st-popN[
    'ST:Stack, '_-_['N:Nat, 's_['0.Zero]]] if '_>_['N:Nat, '0.Zero] =
    'true.Bool [none] .
  ceq 'verify-IL['nil.List`{Inst`}, '__['TList:List`{TypeToken`},
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool if '__['TList:List`{TypeToken`}, 'TList':List`{TypeToken`}] :=
    'TListRes:List`{TypeToken`} [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], '__[
    'TListLabel:List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TListLabel:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TList':List`{TypeToken`} := 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}], '__[
    'TList':List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TList':List`{TypeToken`}, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}], '__[
    'T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '__['MutGlobalTypeIndicator:MutGlobalTypeIndicator, 'T:TypeToken] :=
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]] [none] .
  ceq 'verify-IL['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'T:TypeToken := 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef] [none] .
  ceq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T':TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  rl '<_|_|_>['__['drop.Inst, 'IL:List`{Inst`}], '_$_['Val:Value, 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('drop)] .
  rl '<_|_|_>['__['nop.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('nop)] .
  rl '<_|_|_>['__['select.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW2:ValWrapper], '_$_['Val2:Value, '_$_['Val1:Value,
    'ST:Stack]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['selectVal['ValW2:ValWrapper, 'Val1:Value,
    'Val2:Value], 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('select)] .
  rl '<_|_|_>['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '_$_['const['IntT:IntTypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'ieq['ValW1:ValWrapper,
    'val['0.Zero]]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.eqz)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper], 'und.Und], '<_|_|_>['IL:List`{Inst`}, 'st-push[
    'ST:Stack, 'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'trap['"Binop result undefined".String]] [label('t.binop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'relop['T:TypeToken,
    'relopT:RelopToken, 'ValW1:ValWrapper, 'ValW2:ValWrapper]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.relop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'unop['T:TypeToken, 'unopT:UnopToken,
    'ValW1:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('t.unop)] .
  rl '<_|_|_>['__['_.__['T2:TypeToken, 'cvtopT:CvtopToken, 'T1:TypeToken],
    'IL:List`{Inst`}], '_$_['const['T1:TypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    'if_then_else_fi['_=/=_['cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper], 'und.Und], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], 'trap[
    '"Cvtop result undefined".String]] [label('t1.cvtop_t2)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => 'if_then_else_fi['_=/=_['FloatN:Float, '0.0.FiniteFloat], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'correctFloat['const[
    'FloatT:FloatTypeToken, 'val['FloatN:Float]]]],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}], '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label(
    'float-const)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'float['IntN:Int]],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] [
    label('int-as-float-const)] .
  rl '<_|_|_>['__['br~if_['N:Nat], 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'val['Int1:Int]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'Int1:Int, '0.Zero], '<_|_|_>['__['br_['N:Nat], 'IL:List`{Inst`}],
    'ST:Stack, 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]] [label('br_if)] .
  rl '<_|_|_>['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}], 'ST:Stack, '__[
    'LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, '_`[_`]['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef]],
    '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.get)] .
  rl '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'ST:Stack, '__['insert['ValR:ValRef, 'Val:Value,
    'LocalSTR:Map`{ValRef`,Value`}],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.set)] .
  rl '<_|_|_>['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], 'st-push[
    'st-push['ST:Stack, 'Val:Value], 'Val:Value],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('local.tee)] .
  rl '<_|_|_>['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"block".String, 'nil.List`{Inst`}, 'size['aux-get-resultlistTList[
    'ResultType:ResultType]]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]
    [label('block-resultT)] .
  rl '<_|_|_>['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"loop".String, '__['loop_['ResultType:ResultType], '__[
    'IL2:List`{Inst`}, 'end.Inst]], '0.Zero]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('loop-resultT)] .
  rl '<_|_|_>['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__['if-else[
    'ValW1:ValWrapper, 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('if-else)] .
  rl '<_|_|_>['exit-block['IL:List`{Inst`}], 'NeST:NeStack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'get-st['reset-st['NeST:NeStack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('end)] .
  rl '_#_['<_|_|_>['__['global.get_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'global-val['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] [label('global.get)] .
  rl '_#_['_#_['<_|_|_>['__['call_['Addr:Addr], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['__['get-IL-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]], '__['exit-func[
    'get-resultlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]]], 'exit-block['IL:List`{Inst`}]]], '_$_['label['"func".String,
    'nil.List`{Inst`}, 'size['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]], 'st-popN['ST:Stack,
    'size['get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]]], '__['init-store[
    '__['get-paramlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]], 'get-localsTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]], 'st-getTopVals[
    'ST:Stack, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]],
    'empty.Map`{ValRef`,Value`}], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}] [
    label('call)] .
  rl '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    => '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    [label('call-by-name)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken,
    'ValW1:ValWrapper]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if
    'ValW1:ValWrapper := 'unsigned['val['IntN:Int], 'bit-width[
    'IntT:IntTypeToken]] [label('int-const-signed)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('int-const)] .
  crl '<_|_|_>['__['_.const_['v128.VecTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['v128.VecTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('vec-const)] .
  crl '<_|_|_>['__['br_['N:Nat], 'IL2:List`{Inst`}, 'exit-block[
    'IL:List`{Inst`}], 'IL':List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL1:List`{Inst`}, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] if '_||_['ST1:Stack,
    'label['Str:String, 'IL1:List`{Inst`}, 'N1:Nat]] := 'get-ith-stackandlabel[
    'ST:Stack, 'N:Nat, 'EmptyStack.EmptyStack] [label('br)] .
  crl '_#_['<_|_|_>['__['global.set_['Str:String], 'IL:List`{Inst`}], '_$_[
    'const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`}, 'insert['_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken], 'const['T:TypeToken,
    'ValW1:ValWrapper]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]] if '_==_[
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]], '__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken]] = 'true.Bool [label(
    'global.set)] .
  crl '_#_['_#_['<_|_|_>['__['exit-func['TypeTokenList:List`{TypeToken`}],
    'IL:List`{Inst`}], 'ST:Stack, '__['LocalSTR:Map`{ValRef`,Value`},
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    if 'valid-stack['ST:Stack, 'reverse['TypeTokenList:List`{TypeToken`}]] =
    'true.Bool [label('exit-func)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['block_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"block".String, 'nil.List`{Inst`}, 'size[
    'TListRes:List`{TypeToken`}]], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListRes:List`{TypeToken`} := 'aux-get-resultlistTList[
    'getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('block-tref)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['loop_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"loop".String, '__['loop_['TypeRef:TypeRef], '__[
    'IL2:List`{Inst`}, 'end.Inst]], 'size['TListParam:List`{TypeToken`}]],
    'ST:Stack]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListParam:List`{TypeToken`} := 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('loop-tref)] .
endm
FHIn --> file(3)
Attrs --> in: file(3), inFile: "examples/factorial_valid_br_jump.wat"
Acc --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"
Func --> "$start"
ResTerm --> 'w:WASMSimTrigger
Condition --> (nil).EqCondition
SearchType --> '!
maxDepth --> unbounded
solNumber --> (0).Zero
aux-metaSearch(mod 'WASMMOD is
  including 'BOOL .
  protecting 'WASM-MODULECONTENT-MOD .
  protecting 'WASM-VERIFYFUNCDEF-MOD .
  protecting 'MAP{'ValRef, 'Value} .
  protecting 'LIST{'Map{'ValRef, 'Value}} .
  protecting 'MAP{'String, 'Addr} .
  protecting 'MAP{'Addr, 'GlobalInstance} .
  sorts 'ComponentCtr ; 'EmptyStack ; 'FuncIndCtx ; 'FuncStore ; 'GlobalIndCtx
    ; 'GlobalInventory ; 'IndCtx ; 'Label ; 'LocalIndCtx ; 'NeStack ; 'Stack ;
    'StackAndLabel ; 'StackElem ; 'Starter ; 'TypeIndCtx ;
    'WASMFuncGlobalIndSim ; 'WASMFuncGlobalSim ; 'WASMGlobalIndSim ;
    'WASMGlobalSim ; 'WASMLocalIndSim ; 'WASMLocalSim ; 'WASMModule ; 'WASMSim
    ; 'WASMSimTrigger ; 'WASMTypeFuncGlobalIndSim ; 'WASMTypeFuncGlobalSim ;
    'WasmTrigger .
  subsort 'EmptyStack < 'Stack .
  subsort 'FuncIndCtx < 'IndCtx .
  subsort 'GlobalIndCtx < 'IndCtx .
  subsort 'Label < 'StackElem .
  subsort 'List`{Inst`} < 'WASMLocalSim .
  subsort 'LocalIndCtx < 'IndCtx .
  subsort 'NeStack < 'Stack .
  subsort 'Stack < 'WASMLocalSim .
  subsort 'StackElem < 'NeStack .
  subsort 'TypeIndCtx < 'IndCtx .
  subsort 'Und < 'Label .
  subsort 'Value < 'StackElem .
  op '#_#_# : 'WASMModule 'WASMTypeFuncGlobalIndSim -> 'WASMSim [ctor format(
    'ni 'ni 'ni 'ni 'ni 'ni)] .
  op '<_|_|_> : 'List`{Inst`} 'Stack 'Map`{ValRef`,Value`} -> 'WASMLocalSim [
    ctor format('ni 'd 'd 'd 'd 'd 'd 'd)] .
  op 'EmptyStack : nil -> 'EmptyStack [ctor] .
  op 'Fail : 'String -> 'WASMSimTrigger [ctor] .
  op '_#_ : 'WASMFuncGlobalIndSim 'Map`{Addr`,ModuleContent`} ->
    'WASMTypeFuncGlobalSim [ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMGlobalSim 'Map`{Addr`,ModuleContent`} -> 'WASMFuncGlobalSim [
    ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMLocalSim 'GlobalInventory -> 'WASMGlobalSim [ctor format('d
    'ni 'ni 'd)] .
  op '_$_ : 'StackElem 'Stack -> 'NeStack [ctor id('EmptyStack.EmptyStack)
    format('d 'ni 'd 'd)] .
  op '_<->_ : 'Map`{String`,Addr`} 'Map`{Addr`,GlobalInstance`} ->
    'GlobalInventory [ctor] .
  op '__ : 'FuncIndCtx 'WASMFuncGlobalSim -> 'WASMFuncGlobalIndSim [ctor] .
  op '__ : 'LocalIndCtx 'WASMLocalSim -> 'WASMLocalIndSim [ctor] .
  op '__ : 'TypeIndCtx 'WASMTypeFuncGlobalSim -> 'WASMTypeFuncGlobalIndSim [
    ctor] .
  op '__ : 'WasmTrigger 'WASMSim -> 'WASMSimTrigger [ctor format('ni 'ni 'ni)]
    .
  op '_||_ : 'Stack 'Label -> 'StackAndLabel [none] .
  op '`[_`,_`,_`] : 'Nat 'Nat 'Nat -> 'ComponentCtr [ctor] .
  op '`{_`,indctr_`} : 'Starter 'ComponentCtr -> 'WasmTrigger [ctor] .
  op '`{funcIndCtx_`} : 'Map`{String`,Addr`} -> 'FuncIndCtx [ctor] .
  op '`{localIndCtx_`} : 'Map`{String`,Addr`} -> 'LocalIndCtx [ctor] .
  op '`{typeIndCtx_`} : 'Map`{String`,Addr`} -> 'TypeIndCtx [ctor] .
  op 'aux-get-paramlistTList : 'ParamType -> 'List`{TypeToken`} [none] .
  op 'aux-get-resultlistTList : 'ResultType -> 'List`{TypeToken`} [none] .
  op 'count-locals-localsref : 'LocalsRef -> 'Nat [none] .
  op 'count-locals-paramlist : 'ParamType -> 'Nat [none] .
  op 'count-paramlist-func : 'FuncDef -> 'Nat [none] .
  op 'errorMod : nil -> '`[WASMModule`] [none] .
  op 'errorWASMSimTrigger : nil -> '`[WASMSimTrigger`] [none] .
  op 'exit-block : 'List`{Inst`} -> 'Inst [ctor] .
  op 'exit-func : 'List`{TypeToken`} -> 'Inst [ctor] .
  op 'expand : 'BlockType 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`} ->
    'ParamResultType [none] .
  op 'get-IL-func : 'FuncDef -> 'List`{Inst`} [none] .
  op 'get-funcList : 'Map`{Addr`,ModuleContent`} -> 'FuncDefList [none] .
  op 'get-inst-list-label : 'StackAndLabel -> 'List`{Inst`} [none] .
  op 'get-ith-stackandlabel : 'Stack 'Nat 'Stack -> 'StackAndLabel [none] .
  op 'get-label : 'StackAndLabel -> 'Label [none] .
  op 'get-localsTList : 'LocalsRef -> 'List`{TypeToken`} [none] .
  op 'get-localsTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-localsref-func : 'FuncDef -> 'LocalsRef [none] .
  op 'get-lth-label : 'Stack 'Nat -> 'Label [none] .
  op 'get-paramlist-func : 'FuncDef -> 'ParamType [none] .
  op 'get-paramlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-resultlist-func : 'FuncDef -> 'ResultType [none] .
  op 'get-resultlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-st : 'StackAndLabel -> 'Stack [none] .
  op 'global-type : 'GlobalInstance -> 'GlobalType [none] .
  op 'global-val : 'GlobalInstance -> 'Value [none] .
  op 'head : 'NeList`{Inst`} -> 'Inst [none] .
  op 'if-else : 'ValWrapper 'List`{Inst`} 'List`{Inst`} 'BlockType ->
    'List`{Inst`} [none] .
  op 'init-store : 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`} ->
    'Map`{ValRef`,Value`} [none] .
  op 'inizialize-store : 'Nat 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`}
    -> 'Map`{ValRef`,Value`} [none] .
  op 'insert : 'String 'Nat 'IndCtx -> 'IndCtx [none] .
  op 'jump-to-L : 'StackAndLabel -> 'Inst [ctor] .
  op 'label : 'String 'List`{Inst`} 'Nat -> 'Label [ctor] .
  op 'lookup : 'Map`{ValRef`,Value`} 'ValRef -> 'Value [none] .
  op 'module_ : 'ModuleContent -> 'WASMModule [ctor prec(20)] .
  op 'nthResultT : 'ResultTypeList 'Nat -> 'List`{TypeToken`} [none] .
  op 'nthT : 'List`{TypeToken`} 'Nat -> 'TypeToken [none] .
  op 'read-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'reset-st : 'Stack -> 'StackAndLabel [none] .
  op 'reset-st-res : 'Stack 'Nat -> 'Stack [none] .
  op 'run-module-func : 'WASMModule 'Nat -> 'WASMSimTrigger [none] .
  op 'run-module-func : 'WASMModule 'String -> 'WASMSimTrigger [none] .
  op 'run-nomodule : 'List`{Inst`} -> 'WASMTypeFuncGlobalSim [none] .
  op 'selectVal : 'ValWrapper 'Value 'Value -> 'Value [none] .
  op 'simulate-wasm : 'WASMTypeFuncGlobalIndSim -> 'WASMTypeFuncGlobalIndSim [
    none] .
  op 'st-getTopVals : 'Stack 'List`{TypeToken`} -> 'Stack [none] .
  op 'st-head : 'NeStack -> 'StackElem [none] .
  op 'st-pop : 'NeStack -> 'Stack [none] .
  op 'st-popN : 'Stack 'Nat -> 'Stack [none] .
  op 'st-push : 'Stack 'StackElem -> 'NeStack [none] .
  op 'st-rev : 'Stack -> 'Stack [none] .
  op 'start_ : 'Nat -> 'Starter [ctor] .
  op 'start_ : 'String -> 'Starter [ctor] .
  op 'tail : 'NeList`{Inst`} -> 'List`{Inst`} [none] .
  op 'uninitialized : nil -> 'Inst [ctor] .
  op 'valid-stack : 'Stack 'List`{TypeToken`} -> 'Bool [none] .
  op 'validate-funcs-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'verify-IL : 'List`{Inst`} 'List`{TypeToken`} 'List`{TypeToken`}
    'List`{TypeToken`} 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{Addr`,GlobalInstance`} 'Map`{String`,Addr`} 'ResultTypeList -> 'Bool
    [none] .
  op 'verify-funcList : 'FuncDefList 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{Addr`,GlobalInstance`}
    'Map`{String`,Addr`} -> 'Bool [none] .
  none
  eq 'aux-get-paramlistTList['param_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'aux-get-resultlistTList['result_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'block_['TList:List`{TypeToken`}] = 'block_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'count-locals-localsref['local_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-localsref['local_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-localsref['local_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-locals-paramlist['param_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-paramlist['param_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-paramlist['param_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-paramlist-func['FuncDef:FuncDef] = 'count-locals-paramlist[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'expand['type_['Id:Id], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, 'Id:Id]] [none] .
  eq 'expand['type_['Str:String], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, '_`[_`][
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'get-IL-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-IL-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-funcList['empty.Map`{Addr`,ModuleContent`}] =
    'EmptyFuncDefL.EmptyFuncDefL [none] .
  eq 'get-funcList['_`,_['FuncStore:Map`{Addr`,ModuleContent`}, '_|->_[
    'Addr:Addr, 'FuncDef:FuncDef]]] = '_`,_['FuncDef:FuncDef, 'get-funcList[
    'FuncStore:Map`{Addr`,ModuleContent`}]] [none] .
  eq 'get-inst-list-label['_||_['ST:Stack, 'label['Str:String,
    'IL:List`{Inst`}, 'N:Nat]]] = 'IL:List`{Inst`} [none] .
  eq 'get-ith-stackandlabel['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat,
    'TempST:Stack] = 'get-ith-stackandlabel['ST:Stack, '_-_['NzN:NzNat, 's_[
    '0.Zero]], 'TempST:Stack] [none] .
  eq 'get-ith-stackandlabel['_$_['Val:Value, 'ST:Stack], 'N:Nat, 'TempST:Stack]
    = 'get-ith-stackandlabel['ST:Stack, 'N:Nat, '_$_['TempST:Stack,
    'Val:Value]] [none] .
  eq 'get-ith-stackandlabel['_$_['label['Str:String, 'IL:List`{Inst`}, 'N:Nat],
    'ST:Stack], '0.Zero, 'TempST:Stack] = '_||_['_$_['reset-st-res[
    'TempST:Stack, 'N:Nat], 'ST:Stack], 'label['Str:String, 'IL:List`{Inst`},
    'N:Nat]] [none] .
  eq 'get-label['_||_['ST:Stack, 'Label:Label]] = 'Label:Label [none] .
  eq 'get-label['_||_['ST:Stack, 'und.Und]] = 'und.Und [none] .
  eq 'get-localsTList['local_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsTList-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef, 'local_[
    'TList:List`{TypeToken`}], 'IL:List`{Inst`}]] = 'TList:List`{TypeToken`} [
    none] .
  eq 'get-localsTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'local_['TList:List`{TypeToken`}], 'IL:List`{Inst`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsref-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsref-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], '0.Zero] = 'Label:Label [
    none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat] =
    'get-lth-label['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]] [none] .
  eq 'get-lth-label['_$_['Val:Value, 'ST:Stack], 'N:Nat] = 'get-lth-label[
    'ST:Stack, 'N:Nat] [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlistTList-func['FuncDef:FuncDef] = 'aux-get-paramlistTList[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlistTList-func['FuncDef:FuncDef] = 'aux-get-resultlistTList[
    'get-resultlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-st['_||_['ST:Stack, 'Label:Label]] = 'ST:Stack [none] .
  eq 'get-st['_||_['ST:Stack, 'und.Und]] = 'ST:Stack [none] .
  eq 'global-type['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'GlobalType:GlobalType [none] .
  eq 'global-val['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'Val:Value [none] .
  eq 'head['__['I1:Inst, 'IL:List`{Inst`}]] = 'I1:Inst [none] .
  eq 'if-else['val['0.Zero], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL2:List`{Inst`}, 'end.Inst]] [owise] .
  eq 'if-else['val['NzIntN:NzInt], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]] [none] .
  eq 'if_['TList:List`{TypeToken`}] = 'if_['result_['TList:List`{TypeToken`}]]
    [none] .
  eq 'init-store['NeTList:NeList`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'inizialize-store['0.Zero,
    'NeTList:NeList`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}] [
    none] .
  eq 'init-store['nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, 'nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'EmptyStack.EmptyStack, 'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat,
    'defaultVal['T:TypeToken], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'EmptyStack.EmptyStack,
    'LocalSTR:Map`{ValRef`,Value`}]] [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat, 'const['T:TypeToken,
    'ValW1:ValWrapper], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}]] [
    none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}]] = '`{funcIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndFuncCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}]] = '`{typeIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndTypeCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'lookup['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] = '_`[_`][
    'LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] [none] .
  eq 'loop_['TList:List`{TypeToken`}] = 'loop_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], '0.Zero] = 'TList:List`{TypeToken`}
    [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], 'NzN:NzNat] = 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, '_-_['NzN:NzNat, 's_['0.Zero]]] [
    none] .
  eq 'nthResultT['result_['TList:List`{TypeToken`}], '0.Zero] =
    'TList:List`{TypeToken`} [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], '0.Zero] = 'T:TypeToken
    [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], 'N:Nat] = 'nthT[
    'TList:List`{TypeToken`}, '_-_['N:Nat, 's_['0.Zero]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'ExportDef:ExportDef]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    '0.0.FiniteFloat]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    'FloatN:Float]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'FloatN:Float]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken, 'IntN:Int]]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['__['ModuleContent:ModuleContent,
    'global__`(_`)['Str:String, 'GlobalType:GlobalType, '_.const_[
    'FloatT:FloatTypeToken, 'float['IntN:Int]]]]], '__['IndTypeCtx:TypeIndCtx,
    '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Id:Id, 'FuncType:FuncType]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__['Id:Id,
    'FuncType:FuncType], 'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Str:String, 'FuncType:FuncType]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['insert['Str:String, 'TCtr:Nat,
    'IndTypeCtx:TypeIndCtx], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__[
    'Str:String, 'FuncType:FuncType],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['N:Nat], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['Str:String], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'reset-st['EmptyStack.EmptyStack] = '_||_['EmptyStack.EmptyStack,
    'und.Und] [none] .
  eq 'reset-st['_$_['Label:Label, 'ST:Stack]] = '_||_['ST:Stack, 'Label:Label]
    [none] .
  eq 'reset-st['_$_['Val:Value, 'ST:Stack]] = '_||_['_$_['Val:Value, 'get-st[
    'reset-st['ST:Stack]]], 'get-label['reset-st['ST:Stack]]] [none] .
  eq 'reset-st-res['EmptyStack.EmptyStack, 'N:Nat] = 'EmptyStack.EmptyStack [
    none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], '0.Zero] =
    'EmptyStack.EmptyStack [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], 'NzN:NzNat] = '_$_['Val:Value,
    'reset-st-res['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]]] [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'N:Nat] = 'read-module['__[
    '`{_`,indctr_`}['start_['N:Nat], '`[_`,_`,_`]['0.Zero, '0.Zero, '0.Zero]],
    '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'Str:String] = 'read-module['__[
    '`{_`,indctr_`}['start_['Str:String], '`[_`,_`,_`]['0.Zero, '0.Zero,
    '0.Zero]], '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-nomodule['IL:List`{Inst`}] = '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['IL:List`{Inst`},
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}] [
    none] .
  eq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val2:Value [
    owise] .
  eq 'simulate-wasm['WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim] =
    'WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim [none] .
  eq 'st-getTopVals['ST:Stack, 'nil.List`{TypeToken`}] = 'EmptyStack.EmptyStack
    [none] .
  eq 'st-getTopVals['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'st-getTopVals['ST:Stack, 'TList:List`{TypeToken`}]] [
    none] .
  eq 'st-head['_$_['STElem:StackElem, 'ST:Stack]] = 'STElem:StackElem [none] .
  eq 'st-pop['_$_['STElem:StackElem, 'ST:Stack]] = 'ST:Stack [none] .
  eq 'st-popN['ST:Stack, '0.Zero] = 'ST:Stack [none] .
  eq 'st-push['EmptyStack.EmptyStack, 'STElem:StackElem] = 'STElem:StackElem [
    none] .
  eq 'st-push['ST:Stack, 'STElem:StackElem] = '_$_['STElem:StackElem,
    'ST:Stack] [none] .
  eq 'st-rev['EmptyStack.EmptyStack] = 'EmptyStack.EmptyStack [none] .
  eq 'st-rev['_$_['STElem:StackElem, 'ST:Stack]] = '_$_['st-rev['ST:Stack],
    'STElem:StackElem] [none] .
  eq 'tail['__['I1:Inst, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'valid-stack['ST:Stack, 'TList:List`{TypeToken`}] = 'false.Bool [owise] .
  eq 'valid-stack['ST:Stack, 'nil.List`{TypeToken`}] = 'true.Bool [none] .
  eq 'valid-stack['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = 'valid-stack['ST:Stack,
    'TList:List`{TypeToken`}] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod],
    'simulate-wasm['__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}],
    '_#_['__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['call_['N:Nat], 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_[
    'Str:String], 'ComponentCtr:ComponentCtr], '#_#_#['module_[
    'EmptyMod.EmptyMod], 'simulate-wasm['__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['call_['_`[_`][
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'Str:String]], 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'verify-IL['NeIL:NeList`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'false.Bool [owise] .
  eq 'verify-IL['nil.List`{Inst`}, 'TListRes:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool [none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], '__['T:TypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['nop.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '__['IntT:IntTypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], '__['i64.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['call_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.get_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-GlobalTypeToken['global-type['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-funcList['EmptyFuncDefL.EmptyFuncDefL,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'true.Bool [none] .
  eq 'verify-funcList['FuncDefL:FuncDefList,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'false.Bool [owise] .
  eq 'verify-funcList['_`,_['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]]] [none]
    .
  eq 'verify-funcList['_`,_['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____[
    'Str:String, 'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef,
    'IL:List`{Inst`}]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['Id:Id, 'func____[
    'Id:Id, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['insert[
    'Str:String, 'FCtr:Nat, 'IndFuncCtx:FuncIndCtx], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['FCtr:Nat, 'func____[
    'Str:String, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'ValW1:ValWrapper]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'ValW1:ValWrapper :=
    'unsigned['val['IntN:Int], 'bit-width['IntT:IntTypeToken]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['v128.VecTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['v128.VecTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val1:Value if
    '_=/=_['Int1:Int, '0.Zero] = 'true.Bool [none] .
  ceq 'st-popN['_$_['STElem:StackElem, 'ST:Stack], 'N:Nat] = 'st-popN[
    'ST:Stack, '_-_['N:Nat, 's_['0.Zero]]] if '_>_['N:Nat, '0.Zero] =
    'true.Bool [none] .
  ceq 'verify-IL['nil.List`{Inst`}, '__['TList:List`{TypeToken`},
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool if '__['TList:List`{TypeToken`}, 'TList':List`{TypeToken`}] :=
    'TListRes:List`{TypeToken`} [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], '__[
    'TListLabel:List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TListLabel:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TList':List`{TypeToken`} := 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}], '__[
    'TList':List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TList':List`{TypeToken`}, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}], '__[
    'T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '__['MutGlobalTypeIndicator:MutGlobalTypeIndicator, 'T:TypeToken] :=
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]] [none] .
  ceq 'verify-IL['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'T:TypeToken := 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef] [none] .
  ceq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T':TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  rl '<_|_|_>['__['drop.Inst, 'IL:List`{Inst`}], '_$_['Val:Value, 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('drop)] .
  rl '<_|_|_>['__['nop.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('nop)] .
  rl '<_|_|_>['__['select.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW2:ValWrapper], '_$_['Val2:Value, '_$_['Val1:Value,
    'ST:Stack]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['selectVal['ValW2:ValWrapper, 'Val1:Value,
    'Val2:Value], 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('select)] .
  rl '<_|_|_>['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '_$_['const['IntT:IntTypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'ieq['ValW1:ValWrapper,
    'val['0.Zero]]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.eqz)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper], 'und.Und], '<_|_|_>['IL:List`{Inst`}, 'st-push[
    'ST:Stack, 'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'trap['"Binop result undefined".String]] [label('t.binop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'relop['T:TypeToken,
    'relopT:RelopToken, 'ValW1:ValWrapper, 'ValW2:ValWrapper]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.relop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'unop['T:TypeToken, 'unopT:UnopToken,
    'ValW1:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('t.unop)] .
  rl '<_|_|_>['__['_.__['T2:TypeToken, 'cvtopT:CvtopToken, 'T1:TypeToken],
    'IL:List`{Inst`}], '_$_['const['T1:TypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    'if_then_else_fi['_=/=_['cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper], 'und.Und], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], 'trap[
    '"Cvtop result undefined".String]] [label('t1.cvtop_t2)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => 'if_then_else_fi['_=/=_['FloatN:Float, '0.0.FiniteFloat], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'correctFloat['const[
    'FloatT:FloatTypeToken, 'val['FloatN:Float]]]],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}], '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label(
    'float-const)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'float['IntN:Int]],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] [
    label('int-as-float-const)] .
  rl '<_|_|_>['__['br~if_['N:Nat], 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'val['Int1:Int]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'Int1:Int, '0.Zero], '<_|_|_>['__['br_['N:Nat], 'IL:List`{Inst`}],
    'ST:Stack, 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]] [label('br_if)] .
  rl '<_|_|_>['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}], 'ST:Stack, '__[
    'LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, '_`[_`]['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef]],
    '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.get)] .
  rl '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'ST:Stack, '__['insert['ValR:ValRef, 'Val:Value,
    'LocalSTR:Map`{ValRef`,Value`}],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.set)] .
  rl '<_|_|_>['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], 'st-push[
    'st-push['ST:Stack, 'Val:Value], 'Val:Value],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('local.tee)] .
  rl '<_|_|_>['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"block".String, 'nil.List`{Inst`}, 'size['aux-get-resultlistTList[
    'ResultType:ResultType]]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]
    [label('block-resultT)] .
  rl '<_|_|_>['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"loop".String, '__['loop_['ResultType:ResultType], '__[
    'IL2:List`{Inst`}, 'end.Inst]], '0.Zero]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('loop-resultT)] .
  rl '<_|_|_>['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__['if-else[
    'ValW1:ValWrapper, 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('if-else)] .
  rl '<_|_|_>['exit-block['IL:List`{Inst`}], 'NeST:NeStack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'get-st['reset-st['NeST:NeStack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('end)] .
  rl '_#_['<_|_|_>['__['global.get_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'global-val['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] [label('global.get)] .
  rl '_#_['_#_['<_|_|_>['__['call_['Addr:Addr], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['__['get-IL-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]], '__['exit-func[
    'get-resultlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]]], 'exit-block['IL:List`{Inst`}]]], '_$_['label['"func".String,
    'nil.List`{Inst`}, 'size['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]], 'st-popN['ST:Stack,
    'size['get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]]], '__['init-store[
    '__['get-paramlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]], 'get-localsTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]], 'st-getTopVals[
    'ST:Stack, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]],
    'empty.Map`{ValRef`,Value`}], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}] [
    label('call)] .
  rl '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    => '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    [label('call-by-name)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken,
    'ValW1:ValWrapper]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if
    'ValW1:ValWrapper := 'unsigned['val['IntN:Int], 'bit-width[
    'IntT:IntTypeToken]] [label('int-const-signed)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('int-const)] .
  crl '<_|_|_>['__['_.const_['v128.VecTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['v128.VecTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('vec-const)] .
  crl '<_|_|_>['__['br_['N:Nat], 'IL2:List`{Inst`}, 'exit-block[
    'IL:List`{Inst`}], 'IL':List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL1:List`{Inst`}, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] if '_||_['ST1:Stack,
    'label['Str:String, 'IL1:List`{Inst`}, 'N1:Nat]] := 'get-ith-stackandlabel[
    'ST:Stack, 'N:Nat, 'EmptyStack.EmptyStack] [label('br)] .
  crl '_#_['<_|_|_>['__['global.set_['Str:String], 'IL:List`{Inst`}], '_$_[
    'const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`}, 'insert['_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken], 'const['T:TypeToken,
    'ValW1:ValWrapper]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]] if '_==_[
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]], '__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken]] = 'true.Bool [label(
    'global.set)] .
  crl '_#_['_#_['<_|_|_>['__['exit-func['TypeTokenList:List`{TypeToken`}],
    'IL:List`{Inst`}], 'ST:Stack, '__['LocalSTR:Map`{ValRef`,Value`},
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    if 'valid-stack['ST:Stack, 'reverse['TypeTokenList:List`{TypeToken`}]] =
    'true.Bool [label('exit-func)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['block_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"block".String, 'nil.List`{Inst`}, 'size[
    'TListRes:List`{TypeToken`}]], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListRes:List`{TypeToken`} := 'aux-get-resultlistTList[
    'getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('block-tref)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['loop_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"loop".String, '__['loop_['TypeRef:TypeRef], '__[
    'IL2:List`{Inst`}, 'end.Inst]], 'size['TListParam:List`{TypeToken`}]],
    'ST:Stack]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListParam:List`{TypeToken`} := 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('loop-tref)] .
endm, <> closedFile(myObj, file(3)) < myObj : myClass | in: file(3), inFile:
    "examples/factorial_valid_br_jump.wat", outText: "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n" >, "$start",
    'w:WASMSimTrigger, nil, '!, unbounded, 0)
--->
metaSearch(mod 'WASMMOD is
  including 'BOOL .
  protecting 'WASM-MODULECONTENT-MOD .
  protecting 'WASM-VERIFYFUNCDEF-MOD .
  protecting 'MAP{'ValRef, 'Value} .
  protecting 'LIST{'Map{'ValRef, 'Value}} .
  protecting 'MAP{'String, 'Addr} .
  protecting 'MAP{'Addr, 'GlobalInstance} .
  sorts 'ComponentCtr ; 'EmptyStack ; 'FuncIndCtx ; 'FuncStore ; 'GlobalIndCtx
    ; 'GlobalInventory ; 'IndCtx ; 'Label ; 'LocalIndCtx ; 'NeStack ; 'Stack ;
    'StackAndLabel ; 'StackElem ; 'Starter ; 'TypeIndCtx ;
    'WASMFuncGlobalIndSim ; 'WASMFuncGlobalSim ; 'WASMGlobalIndSim ;
    'WASMGlobalSim ; 'WASMLocalIndSim ; 'WASMLocalSim ; 'WASMModule ; 'WASMSim
    ; 'WASMSimTrigger ; 'WASMTypeFuncGlobalIndSim ; 'WASMTypeFuncGlobalSim ;
    'WasmTrigger .
  subsort 'EmptyStack < 'Stack .
  subsort 'FuncIndCtx < 'IndCtx .
  subsort 'GlobalIndCtx < 'IndCtx .
  subsort 'Label < 'StackElem .
  subsort 'List`{Inst`} < 'WASMLocalSim .
  subsort 'LocalIndCtx < 'IndCtx .
  subsort 'NeStack < 'Stack .
  subsort 'Stack < 'WASMLocalSim .
  subsort 'StackElem < 'NeStack .
  subsort 'TypeIndCtx < 'IndCtx .
  subsort 'Und < 'Label .
  subsort 'Value < 'StackElem .
  op '#_#_# : 'WASMModule 'WASMTypeFuncGlobalIndSim -> 'WASMSim [ctor format(
    'ni 'ni 'ni 'ni 'ni 'ni)] .
  op '<_|_|_> : 'List`{Inst`} 'Stack 'Map`{ValRef`,Value`} -> 'WASMLocalSim [
    ctor format('ni 'd 'd 'd 'd 'd 'd 'd)] .
  op 'EmptyStack : nil -> 'EmptyStack [ctor] .
  op 'Fail : 'String -> 'WASMSimTrigger [ctor] .
  op '_#_ : 'WASMFuncGlobalIndSim 'Map`{Addr`,ModuleContent`} ->
    'WASMTypeFuncGlobalSim [ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMGlobalSim 'Map`{Addr`,ModuleContent`} -> 'WASMFuncGlobalSim [
    ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMLocalSim 'GlobalInventory -> 'WASMGlobalSim [ctor format('d
    'ni 'ni 'd)] .
  op '_$_ : 'StackElem 'Stack -> 'NeStack [ctor id('EmptyStack.EmptyStack)
    format('d 'ni 'd 'd)] .
  op '_<->_ : 'Map`{String`,Addr`} 'Map`{Addr`,GlobalInstance`} ->
    'GlobalInventory [ctor] .
  op '__ : 'FuncIndCtx 'WASMFuncGlobalSim -> 'WASMFuncGlobalIndSim [ctor] .
  op '__ : 'LocalIndCtx 'WASMLocalSim -> 'WASMLocalIndSim [ctor] .
  op '__ : 'TypeIndCtx 'WASMTypeFuncGlobalSim -> 'WASMTypeFuncGlobalIndSim [
    ctor] .
  op '__ : 'WasmTrigger 'WASMSim -> 'WASMSimTrigger [ctor format('ni 'ni 'ni)]
    .
  op '_||_ : 'Stack 'Label -> 'StackAndLabel [none] .
  op '`[_`,_`,_`] : 'Nat 'Nat 'Nat -> 'ComponentCtr [ctor] .
  op '`{_`,indctr_`} : 'Starter 'ComponentCtr -> 'WasmTrigger [ctor] .
  op '`{funcIndCtx_`} : 'Map`{String`,Addr`} -> 'FuncIndCtx [ctor] .
  op '`{localIndCtx_`} : 'Map`{String`,Addr`} -> 'LocalIndCtx [ctor] .
  op '`{typeIndCtx_`} : 'Map`{String`,Addr`} -> 'TypeIndCtx [ctor] .
  op 'aux-get-paramlistTList : 'ParamType -> 'List`{TypeToken`} [none] .
  op 'aux-get-resultlistTList : 'ResultType -> 'List`{TypeToken`} [none] .
  op 'count-locals-localsref : 'LocalsRef -> 'Nat [none] .
  op 'count-locals-paramlist : 'ParamType -> 'Nat [none] .
  op 'count-paramlist-func : 'FuncDef -> 'Nat [none] .
  op 'errorMod : nil -> '`[WASMModule`] [none] .
  op 'errorWASMSimTrigger : nil -> '`[WASMSimTrigger`] [none] .
  op 'exit-block : 'List`{Inst`} -> 'Inst [ctor] .
  op 'exit-func : 'List`{TypeToken`} -> 'Inst [ctor] .
  op 'expand : 'BlockType 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`} ->
    'ParamResultType [none] .
  op 'get-IL-func : 'FuncDef -> 'List`{Inst`} [none] .
  op 'get-funcList : 'Map`{Addr`,ModuleContent`} -> 'FuncDefList [none] .
  op 'get-inst-list-label : 'StackAndLabel -> 'List`{Inst`} [none] .
  op 'get-ith-stackandlabel : 'Stack 'Nat 'Stack -> 'StackAndLabel [none] .
  op 'get-label : 'StackAndLabel -> 'Label [none] .
  op 'get-localsTList : 'LocalsRef -> 'List`{TypeToken`} [none] .
  op 'get-localsTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-localsref-func : 'FuncDef -> 'LocalsRef [none] .
  op 'get-lth-label : 'Stack 'Nat -> 'Label [none] .
  op 'get-paramlist-func : 'FuncDef -> 'ParamType [none] .
  op 'get-paramlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-resultlist-func : 'FuncDef -> 'ResultType [none] .
  op 'get-resultlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-st : 'StackAndLabel -> 'Stack [none] .
  op 'global-type : 'GlobalInstance -> 'GlobalType [none] .
  op 'global-val : 'GlobalInstance -> 'Value [none] .
  op 'head : 'NeList`{Inst`} -> 'Inst [none] .
  op 'if-else : 'ValWrapper 'List`{Inst`} 'List`{Inst`} 'BlockType ->
    'List`{Inst`} [none] .
  op 'init-store : 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`} ->
    'Map`{ValRef`,Value`} [none] .
  op 'inizialize-store : 'Nat 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`}
    -> 'Map`{ValRef`,Value`} [none] .
  op 'insert : 'String 'Nat 'IndCtx -> 'IndCtx [none] .
  op 'jump-to-L : 'StackAndLabel -> 'Inst [ctor] .
  op 'label : 'String 'List`{Inst`} 'Nat -> 'Label [ctor] .
  op 'lookup : 'Map`{ValRef`,Value`} 'ValRef -> 'Value [none] .
  op 'module_ : 'ModuleContent -> 'WASMModule [ctor prec(20)] .
  op 'nthResultT : 'ResultTypeList 'Nat -> 'List`{TypeToken`} [none] .
  op 'nthT : 'List`{TypeToken`} 'Nat -> 'TypeToken [none] .
  op 'read-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'reset-st : 'Stack -> 'StackAndLabel [none] .
  op 'reset-st-res : 'Stack 'Nat -> 'Stack [none] .
  op 'run-module-func : 'WASMModule 'Nat -> 'WASMSimTrigger [none] .
  op 'run-module-func : 'WASMModule 'String -> 'WASMSimTrigger [none] .
  op 'run-nomodule : 'List`{Inst`} -> 'WASMTypeFuncGlobalSim [none] .
  op 'selectVal : 'ValWrapper 'Value 'Value -> 'Value [none] .
  op 'simulate-wasm : 'WASMTypeFuncGlobalIndSim -> 'WASMTypeFuncGlobalIndSim [
    none] .
  op 'st-getTopVals : 'Stack 'List`{TypeToken`} -> 'Stack [none] .
  op 'st-head : 'NeStack -> 'StackElem [none] .
  op 'st-pop : 'NeStack -> 'Stack [none] .
  op 'st-popN : 'Stack 'Nat -> 'Stack [none] .
  op 'st-push : 'Stack 'StackElem -> 'NeStack [none] .
  op 'st-rev : 'Stack -> 'Stack [none] .
  op 'start_ : 'Nat -> 'Starter [ctor] .
  op 'start_ : 'String -> 'Starter [ctor] .
  op 'tail : 'NeList`{Inst`} -> 'List`{Inst`} [none] .
  op 'uninitialized : nil -> 'Inst [ctor] .
  op 'valid-stack : 'Stack 'List`{TypeToken`} -> 'Bool [none] .
  op 'validate-funcs-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'verify-IL : 'List`{Inst`} 'List`{TypeToken`} 'List`{TypeToken`}
    'List`{TypeToken`} 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{Addr`,GlobalInstance`} 'Map`{String`,Addr`} 'ResultTypeList -> 'Bool
    [none] .
  op 'verify-funcList : 'FuncDefList 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{Addr`,GlobalInstance`}
    'Map`{String`,Addr`} -> 'Bool [none] .
  none
  eq 'aux-get-paramlistTList['param_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'aux-get-resultlistTList['result_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'block_['TList:List`{TypeToken`}] = 'block_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'count-locals-localsref['local_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-localsref['local_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-localsref['local_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-locals-paramlist['param_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-paramlist['param_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-paramlist['param_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-paramlist-func['FuncDef:FuncDef] = 'count-locals-paramlist[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'expand['type_['Id:Id], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, 'Id:Id]] [none] .
  eq 'expand['type_['Str:String], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, '_`[_`][
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'get-IL-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-IL-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-funcList['empty.Map`{Addr`,ModuleContent`}] =
    'EmptyFuncDefL.EmptyFuncDefL [none] .
  eq 'get-funcList['_`,_['FuncStore:Map`{Addr`,ModuleContent`}, '_|->_[
    'Addr:Addr, 'FuncDef:FuncDef]]] = '_`,_['FuncDef:FuncDef, 'get-funcList[
    'FuncStore:Map`{Addr`,ModuleContent`}]] [none] .
  eq 'get-inst-list-label['_||_['ST:Stack, 'label['Str:String,
    'IL:List`{Inst`}, 'N:Nat]]] = 'IL:List`{Inst`} [none] .
  eq 'get-ith-stackandlabel['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat,
    'TempST:Stack] = 'get-ith-stackandlabel['ST:Stack, '_-_['NzN:NzNat, 's_[
    '0.Zero]], 'TempST:Stack] [none] .
  eq 'get-ith-stackandlabel['_$_['Val:Value, 'ST:Stack], 'N:Nat, 'TempST:Stack]
    = 'get-ith-stackandlabel['ST:Stack, 'N:Nat, '_$_['TempST:Stack,
    'Val:Value]] [none] .
  eq 'get-ith-stackandlabel['_$_['label['Str:String, 'IL:List`{Inst`}, 'N:Nat],
    'ST:Stack], '0.Zero, 'TempST:Stack] = '_||_['_$_['reset-st-res[
    'TempST:Stack, 'N:Nat], 'ST:Stack], 'label['Str:String, 'IL:List`{Inst`},
    'N:Nat]] [none] .
  eq 'get-label['_||_['ST:Stack, 'Label:Label]] = 'Label:Label [none] .
  eq 'get-label['_||_['ST:Stack, 'und.Und]] = 'und.Und [none] .
  eq 'get-localsTList['local_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsTList-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef, 'local_[
    'TList:List`{TypeToken`}], 'IL:List`{Inst`}]] = 'TList:List`{TypeToken`} [
    none] .
  eq 'get-localsTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'local_['TList:List`{TypeToken`}], 'IL:List`{Inst`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsref-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsref-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], '0.Zero] = 'Label:Label [
    none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat] =
    'get-lth-label['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]] [none] .
  eq 'get-lth-label['_$_['Val:Value, 'ST:Stack], 'N:Nat] = 'get-lth-label[
    'ST:Stack, 'N:Nat] [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlistTList-func['FuncDef:FuncDef] = 'aux-get-paramlistTList[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlistTList-func['FuncDef:FuncDef] = 'aux-get-resultlistTList[
    'get-resultlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-st['_||_['ST:Stack, 'Label:Label]] = 'ST:Stack [none] .
  eq 'get-st['_||_['ST:Stack, 'und.Und]] = 'ST:Stack [none] .
  eq 'global-type['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'GlobalType:GlobalType [none] .
  eq 'global-val['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'Val:Value [none] .
  eq 'head['__['I1:Inst, 'IL:List`{Inst`}]] = 'I1:Inst [none] .
  eq 'if-else['val['0.Zero], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL2:List`{Inst`}, 'end.Inst]] [owise] .
  eq 'if-else['val['NzIntN:NzInt], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]] [none] .
  eq 'if_['TList:List`{TypeToken`}] = 'if_['result_['TList:List`{TypeToken`}]]
    [none] .
  eq 'init-store['NeTList:NeList`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'inizialize-store['0.Zero,
    'NeTList:NeList`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}] [
    none] .
  eq 'init-store['nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, 'nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'EmptyStack.EmptyStack, 'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat,
    'defaultVal['T:TypeToken], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'EmptyStack.EmptyStack,
    'LocalSTR:Map`{ValRef`,Value`}]] [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat, 'const['T:TypeToken,
    'ValW1:ValWrapper], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}]] [
    none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}]] = '`{funcIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndFuncCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}]] = '`{typeIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndTypeCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'lookup['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] = '_`[_`][
    'LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] [none] .
  eq 'loop_['TList:List`{TypeToken`}] = 'loop_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], '0.Zero] = 'TList:List`{TypeToken`}
    [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], 'NzN:NzNat] = 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, '_-_['NzN:NzNat, 's_['0.Zero]]] [
    none] .
  eq 'nthResultT['result_['TList:List`{TypeToken`}], '0.Zero] =
    'TList:List`{TypeToken`} [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], '0.Zero] = 'T:TypeToken
    [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], 'N:Nat] = 'nthT[
    'TList:List`{TypeToken`}, '_-_['N:Nat, 's_['0.Zero]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'ExportDef:ExportDef]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    '0.0.FiniteFloat]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    'FloatN:Float]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'FloatN:Float]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken, 'IntN:Int]]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['__['ModuleContent:ModuleContent,
    'global__`(_`)['Str:String, 'GlobalType:GlobalType, '_.const_[
    'FloatT:FloatTypeToken, 'float['IntN:Int]]]]], '__['IndTypeCtx:TypeIndCtx,
    '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Id:Id, 'FuncType:FuncType]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__['Id:Id,
    'FuncType:FuncType], 'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Str:String, 'FuncType:FuncType]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['insert['Str:String, 'TCtr:Nat,
    'IndTypeCtx:TypeIndCtx], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__[
    'Str:String, 'FuncType:FuncType],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['N:Nat], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['Str:String], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'reset-st['EmptyStack.EmptyStack] = '_||_['EmptyStack.EmptyStack,
    'und.Und] [none] .
  eq 'reset-st['_$_['Label:Label, 'ST:Stack]] = '_||_['ST:Stack, 'Label:Label]
    [none] .
  eq 'reset-st['_$_['Val:Value, 'ST:Stack]] = '_||_['_$_['Val:Value, 'get-st[
    'reset-st['ST:Stack]]], 'get-label['reset-st['ST:Stack]]] [none] .
  eq 'reset-st-res['EmptyStack.EmptyStack, 'N:Nat] = 'EmptyStack.EmptyStack [
    none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], '0.Zero] =
    'EmptyStack.EmptyStack [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], 'NzN:NzNat] = '_$_['Val:Value,
    'reset-st-res['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]]] [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'N:Nat] = 'read-module['__[
    '`{_`,indctr_`}['start_['N:Nat], '`[_`,_`,_`]['0.Zero, '0.Zero, '0.Zero]],
    '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'Str:String] = 'read-module['__[
    '`{_`,indctr_`}['start_['Str:String], '`[_`,_`,_`]['0.Zero, '0.Zero,
    '0.Zero]], '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-nomodule['IL:List`{Inst`}] = '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['IL:List`{Inst`},
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}] [
    none] .
  eq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val2:Value [
    owise] .
  eq 'simulate-wasm['WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim] =
    'WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim [none] .
  eq 'st-getTopVals['ST:Stack, 'nil.List`{TypeToken`}] = 'EmptyStack.EmptyStack
    [none] .
  eq 'st-getTopVals['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'st-getTopVals['ST:Stack, 'TList:List`{TypeToken`}]] [
    none] .
  eq 'st-head['_$_['STElem:StackElem, 'ST:Stack]] = 'STElem:StackElem [none] .
  eq 'st-pop['_$_['STElem:StackElem, 'ST:Stack]] = 'ST:Stack [none] .
  eq 'st-popN['ST:Stack, '0.Zero] = 'ST:Stack [none] .
  eq 'st-push['EmptyStack.EmptyStack, 'STElem:StackElem] = 'STElem:StackElem [
    none] .
  eq 'st-push['ST:Stack, 'STElem:StackElem] = '_$_['STElem:StackElem,
    'ST:Stack] [none] .
  eq 'st-rev['EmptyStack.EmptyStack] = 'EmptyStack.EmptyStack [none] .
  eq 'st-rev['_$_['STElem:StackElem, 'ST:Stack]] = '_$_['st-rev['ST:Stack],
    'STElem:StackElem] [none] .
  eq 'tail['__['I1:Inst, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'valid-stack['ST:Stack, 'TList:List`{TypeToken`}] = 'false.Bool [owise] .
  eq 'valid-stack['ST:Stack, 'nil.List`{TypeToken`}] = 'true.Bool [none] .
  eq 'valid-stack['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = 'valid-stack['ST:Stack,
    'TList:List`{TypeToken`}] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod],
    'simulate-wasm['__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}],
    '_#_['__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['call_['N:Nat], 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_[
    'Str:String], 'ComponentCtr:ComponentCtr], '#_#_#['module_[
    'EmptyMod.EmptyMod], 'simulate-wasm['__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['call_['_`[_`][
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'Str:String]], 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'verify-IL['NeIL:NeList`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'false.Bool [owise] .
  eq 'verify-IL['nil.List`{Inst`}, 'TListRes:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool [none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], '__['T:TypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['nop.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '__['IntT:IntTypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], '__['i64.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['call_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.get_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-GlobalTypeToken['global-type['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-funcList['EmptyFuncDefL.EmptyFuncDefL,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'true.Bool [none] .
  eq 'verify-funcList['FuncDefL:FuncDefList,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'false.Bool [owise] .
  eq 'verify-funcList['_`,_['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]]] [none]
    .
  eq 'verify-funcList['_`,_['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____[
    'Str:String, 'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef,
    'IL:List`{Inst`}]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['Id:Id, 'func____[
    'Id:Id, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['insert[
    'Str:String, 'FCtr:Nat, 'IndFuncCtx:FuncIndCtx], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['FCtr:Nat, 'func____[
    'Str:String, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'ValW1:ValWrapper]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'ValW1:ValWrapper :=
    'unsigned['val['IntN:Int], 'bit-width['IntT:IntTypeToken]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['v128.VecTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['v128.VecTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val1:Value if
    '_=/=_['Int1:Int, '0.Zero] = 'true.Bool [none] .
  ceq 'st-popN['_$_['STElem:StackElem, 'ST:Stack], 'N:Nat] = 'st-popN[
    'ST:Stack, '_-_['N:Nat, 's_['0.Zero]]] if '_>_['N:Nat, '0.Zero] =
    'true.Bool [none] .
  ceq 'verify-IL['nil.List`{Inst`}, '__['TList:List`{TypeToken`},
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool if '__['TList:List`{TypeToken`}, 'TList':List`{TypeToken`}] :=
    'TListRes:List`{TypeToken`} [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], '__[
    'TListLabel:List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TListLabel:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TList':List`{TypeToken`} := 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}], '__[
    'TList':List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TList':List`{TypeToken`}, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}], '__[
    'T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '__['MutGlobalTypeIndicator:MutGlobalTypeIndicator, 'T:TypeToken] :=
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]] [none] .
  ceq 'verify-IL['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'T:TypeToken := 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef] [none] .
  ceq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T':TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  rl '<_|_|_>['__['drop.Inst, 'IL:List`{Inst`}], '_$_['Val:Value, 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('drop)] .
  rl '<_|_|_>['__['nop.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('nop)] .
  rl '<_|_|_>['__['select.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW2:ValWrapper], '_$_['Val2:Value, '_$_['Val1:Value,
    'ST:Stack]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['selectVal['ValW2:ValWrapper, 'Val1:Value,
    'Val2:Value], 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('select)] .
  rl '<_|_|_>['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '_$_['const['IntT:IntTypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'ieq['ValW1:ValWrapper,
    'val['0.Zero]]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.eqz)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper], 'und.Und], '<_|_|_>['IL:List`{Inst`}, 'st-push[
    'ST:Stack, 'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'trap['"Binop result undefined".String]] [label('t.binop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'relop['T:TypeToken,
    'relopT:RelopToken, 'ValW1:ValWrapper, 'ValW2:ValWrapper]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.relop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'unop['T:TypeToken, 'unopT:UnopToken,
    'ValW1:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('t.unop)] .
  rl '<_|_|_>['__['_.__['T2:TypeToken, 'cvtopT:CvtopToken, 'T1:TypeToken],
    'IL:List`{Inst`}], '_$_['const['T1:TypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    'if_then_else_fi['_=/=_['cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper], 'und.Und], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], 'trap[
    '"Cvtop result undefined".String]] [label('t1.cvtop_t2)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => 'if_then_else_fi['_=/=_['FloatN:Float, '0.0.FiniteFloat], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'correctFloat['const[
    'FloatT:FloatTypeToken, 'val['FloatN:Float]]]],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}], '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label(
    'float-const)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'float['IntN:Int]],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] [
    label('int-as-float-const)] .
  rl '<_|_|_>['__['br~if_['N:Nat], 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'val['Int1:Int]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'Int1:Int, '0.Zero], '<_|_|_>['__['br_['N:Nat], 'IL:List`{Inst`}],
    'ST:Stack, 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]] [label('br_if)] .
  rl '<_|_|_>['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}], 'ST:Stack, '__[
    'LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, '_`[_`]['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef]],
    '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.get)] .
  rl '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'ST:Stack, '__['insert['ValR:ValRef, 'Val:Value,
    'LocalSTR:Map`{ValRef`,Value`}],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.set)] .
  rl '<_|_|_>['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], 'st-push[
    'st-push['ST:Stack, 'Val:Value], 'Val:Value],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('local.tee)] .
  rl '<_|_|_>['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"block".String, 'nil.List`{Inst`}, 'size['aux-get-resultlistTList[
    'ResultType:ResultType]]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]
    [label('block-resultT)] .
  rl '<_|_|_>['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"loop".String, '__['loop_['ResultType:ResultType], '__[
    'IL2:List`{Inst`}, 'end.Inst]], '0.Zero]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('loop-resultT)] .
  rl '<_|_|_>['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__['if-else[
    'ValW1:ValWrapper, 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('if-else)] .
  rl '<_|_|_>['exit-block['IL:List`{Inst`}], 'NeST:NeStack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'get-st['reset-st['NeST:NeStack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('end)] .
  rl '_#_['<_|_|_>['__['global.get_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'global-val['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] [label('global.get)] .
  rl '_#_['_#_['<_|_|_>['__['call_['Addr:Addr], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['__['get-IL-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]], '__['exit-func[
    'get-resultlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]]], 'exit-block['IL:List`{Inst`}]]], '_$_['label['"func".String,
    'nil.List`{Inst`}, 'size['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]], 'st-popN['ST:Stack,
    'size['get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]]], '__['init-store[
    '__['get-paramlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]], 'get-localsTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]], 'st-getTopVals[
    'ST:Stack, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]],
    'empty.Map`{ValRef`,Value`}], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}] [
    label('call)] .
  rl '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    => '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    [label('call-by-name)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken,
    'ValW1:ValWrapper]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if
    'ValW1:ValWrapper := 'unsigned['val['IntN:Int], 'bit-width[
    'IntT:IntTypeToken]] [label('int-const-signed)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('int-const)] .
  crl '<_|_|_>['__['_.const_['v128.VecTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['v128.VecTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('vec-const)] .
  crl '<_|_|_>['__['br_['N:Nat], 'IL2:List`{Inst`}, 'exit-block[
    'IL:List`{Inst`}], 'IL':List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL1:List`{Inst`}, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] if '_||_['ST1:Stack,
    'label['Str:String, 'IL1:List`{Inst`}, 'N1:Nat]] := 'get-ith-stackandlabel[
    'ST:Stack, 'N:Nat, 'EmptyStack.EmptyStack] [label('br)] .
  crl '_#_['<_|_|_>['__['global.set_['Str:String], 'IL:List`{Inst`}], '_$_[
    'const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`}, 'insert['_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken], 'const['T:TypeToken,
    'ValW1:ValWrapper]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]] if '_==_[
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]], '__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken]] = 'true.Bool [label(
    'global.set)] .
  crl '_#_['_#_['<_|_|_>['__['exit-func['TypeTokenList:List`{TypeToken`}],
    'IL:List`{Inst`}], 'ST:Stack, '__['LocalSTR:Map`{ValRef`,Value`},
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    if 'valid-stack['ST:Stack, 'reverse['TypeTokenList:List`{TypeToken`}]] =
    'true.Bool [label('exit-func)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['block_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"block".String, 'nil.List`{Inst`}, 'size[
    'TListRes:List`{TypeToken`}]], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListRes:List`{TypeToken`} := 'aux-get-resultlistTList[
    'getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('block-tref)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['loop_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"loop".String, '__['loop_['TypeRef:TypeRef], '__[
    'IL2:List`{Inst`}, 'end.Inst]], 'size['TListParam:List`{TypeToken`}]],
    'ST:Stack]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListParam:List`{TypeToken`} := 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('loop-tref)] .
endm, upTerm(run-module-func(downTerm(getTerm(metaParse(['WASMMOD],
    tokenize-wasm("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"), 'WASMModule)), errorMod), "$start")),
    'w:WASMSimTrigger, nil, '!, unbounded, 0)
*********** equation
eq [Q:Qid] = sth Q:Qid is
  including Q:Qid .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth .
Q:Qid --> 'WASMMOD
['WASMMOD]
--->
sth 'WASMMOD is
  including 'WASMMOD .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth
*********** equation
eq tokenize-wasm(S:String) = tokenize-wasm(tokenize(S:String)) .
S:String --> "(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"
tokenize-wasm("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n")
--->
tokenize-wasm(tokenize("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n"))
*********** equation
(built-in equation for symbol tokenize)
tokenize("(module\n      (type $type0 (func (result i64)))\n      (type $type1 (func (param i64) (result i64)))\n      (type $type2 (func (param i64) (result i64)))\n      (export \"$start\" (func 0))\n      (func $start (result i64)\n        (local i32)\n        \n            i64.const 5\n            global.set $gb1\n            global.get $gb1\n            block (type $type2)\n            br 0\n            call $factorial\n            end\n            \n        \n        )\n      (func $factorial (type $type1)\n        \n            i64.const 0\n            local.get 0\n            i64.eq\n            if (result i64)\n                i64.const 1\n            else\n                local.get 0\n                local.get 0\n                i64.const 1\n                i64.sub\n                call $factorial\n                i64.mul\n            end\n        \n        )\n      (global $gb1 (mut i64) (i64.const 1))\n      (global $result (mut i64) (i64.const 1))\n)\n")
--->
'`( 'module '`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'module '`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'module '`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`)
    '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('module '`( 'type
    '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #1
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #1
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #2
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #2
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #3
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #3
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'module
QL:QidList --> '`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('module '`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('module), "\"") then 'module else if startsWith(string(
    'module), "$") then qid("\"" + string('module) + "\"") else splitDot(
    removeChar(removeChar(string('module), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('module)
--->
"module"
*********** equation
(built-in equation for symbol startsWith)
startsWith("module", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'module else if startsWith("module", "$") then qid("\"" +
    "module" + "\"") else splitDot(removeChar(removeChar("module", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("module", "$") then qid("\"" + "module" + "\"") else splitDot(
    removeChar(removeChar("module", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("module", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "module" + "\"") else splitDot(removeChar(removeChar(
    "module", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("module", "_", "~"), "\n", " "))
*********** trial #4
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "module"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("module", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "module"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #4
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "module"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("module", "_", "~")
--->
if notFound :: Nat then removeChar(substr("module", 0, notFound) + "~" +
    substr("module", s notFound, sd(notFound, length("module"))), "_", "~")
    else "module" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("module", 0, notFound) + "~" + substr("module",
    s notFound, sd(notFound, length("module"))), "_", "~") else "module" fi
--->
"module"
*********** trial #5
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "module"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("module", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "module"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #5
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "module"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("module", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("module", 0, notFound) + " " +
    substr("module", s notFound, sd(notFound, length("module"))), "\n", " ")
    else "module" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("module", 0, notFound) + " " + substr("module",
    s notFound, sd(notFound, length("module"))), "\n", " ") else "module" fi
--->
"module"
*********** trial #6
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "module"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("module", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "module"
N?:FindResult --> notFound
*********** success #6
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "module"
N?:FindResult --> notFound
splitDot("module")
--->
if notFound :: Nat and (startsWith("module", "f") or startsWith("module", "i"))
    then qid(substr("module", 0, notFound)) if substr("module", notFound, sd(
    notFound, length("module"))) =/= ".const" then qid(substr("module",
    notFound, 1)) if (startsWith(substr("module", notFound, sd(notFound,
    length("module"))), ".demote") or startsWith(substr("module", notFound, sd(
    notFound, length("module"))), ".promote")) or startsWith(substr("module",
    notFound, sd(notFound, length("module"))), ".wrap") then splitConversion(
    substr("module", s notFound, sd(notFound, length("module")))) else qid(
    substr("module", s notFound, sd(notFound, length("module")))) fi else qid(
    substr("module", notFound, sd(notFound, length("module")))) fi else qid(
    "module") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("module", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("module", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("module", 0, notFound)) if substr("module", notFound,
    sd(notFound, length("module"))) =/= ".const" then qid(substr("module",
    notFound, 1)) if (startsWith(substr("module", notFound, sd(notFound,
    length("module"))), ".demote") or startsWith(substr("module", notFound, sd(
    notFound, length("module"))), ".promote")) or startsWith(substr("module",
    notFound, sd(notFound, length("module"))), ".wrap") then splitConversion(
    substr("module", s notFound, sd(notFound, length("module")))) else qid(
    substr("module", s notFound, sd(notFound, length("module")))) fi else qid(
    substr("module", notFound, sd(notFound, length("module")))) fi else qid(
    "module") fi
--->
qid("module")
*********** equation
(built-in equation for symbol qid)
qid("module")
--->
'module
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('type '$type0 '`(
    'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #7
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #7
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #8
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #8
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #9
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #9
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'type
QL:QidList --> '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('type '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('type), "\"") then 'type else if startsWith(string('type),
    "$") then qid("\"" + string('type) + "\"") else splitDot(removeChar(
    removeChar(string('type), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('type)
--->
"type"
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'type else if startsWith("type", "$") then qid("\"" + "type" +
    "\"") else splitDot(removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("type", "$") then qid("\"" + "type" + "\"") else splitDot(
    removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "type" + "\"") else splitDot(removeChar(removeChar(
    "type", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("type", "_", "~"), "\n", " "))
*********** trial #10
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #10
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("type", "_", "~")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + "~" + substr(
    "type", s notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + "~" + substr("type", s
    notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
--->
"type"
*********** trial #11
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #11
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("type", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + " " + substr(
    "type", s notFound, sd(notFound, length("type"))), "\n", " ") else "type"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + " " + substr("type", s
    notFound, sd(notFound, length("type"))), "\n", " ") else "type" fi
--->
"type"
*********** trial #12
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("type", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "type"
N?:FindResult --> notFound
*********** success #12
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> notFound
splitDot("type")
--->
if notFound :: Nat and (startsWith("type", "f") or startsWith("type", "i"))
    then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
--->
qid("type")
*********** equation
(built-in equation for symbol qid)
qid("type")
--->
'type
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$type0
QL:QidList --> '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$type0 '`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$type0), "\"") then '$type0 else if startsWith(string(
    '$type0), "$") then qid("\"" + string('$type0) + "\"") else splitDot(
    removeChar(removeChar(string('$type0), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$type0)
--->
"$type0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$type0 else if startsWith("$type0", "$") then qid("\"" +
    "$type0" + "\"") else splitDot(removeChar(removeChar("$type0", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$type0", "$") then qid("\"" + "$type0" + "\"") else splitDot(
    removeChar(removeChar("$type0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type0", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$type0" + "\"") else splitDot(removeChar(removeChar(
    "$type0", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$type0" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$type0"
--->
"\"$type0"
*********** equation
(built-in equation for symbol _+_)
"\"$type0" + "\""
--->
"\"$type0\""
*********** equation
(built-in equation for symbol qid)
qid("\"$type0\"")
--->
'"$type0"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '`( 'result
    'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #13
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #13
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #14
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #14
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #15
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #15
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('func '`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`(
    'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64
    '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #16
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #16
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #17
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #17
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #18
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #18
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`( 'result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('result 'i64 '`)
    '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #19
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #19
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #20
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #20
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #21
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #21
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'result
QL:QidList --> 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64
    '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('result 'i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('result), "\"") then 'result else if startsWith(string(
    'result), "$") then qid("\"" + string('result) + "\"") else splitDot(
    removeChar(removeChar(string('result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64
    '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('result)
--->
"result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'result else if startsWith("result", "$") then qid("\"" +
    "result" + "\"") else splitDot(removeChar(removeChar("result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("result", "$") then qid("\"" + "result" + "\"") else splitDot(
    removeChar(removeChar("result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "result" + "\"") else splitDot(removeChar(removeChar(
    "result", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("result", "_", "~"), "\n", " "))
*********** trial #22
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #22
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("result", "_", "~")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + "~" +
    substr("result", s notFound, sd(notFound, length("result"))), "_", "~")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + "~" + substr("result",
    s notFound, sd(notFound, length("result"))), "_", "~") else "result" fi
--->
"result"
*********** trial #23
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #23
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("result", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + " " +
    substr("result", s notFound, sd(notFound, length("result"))), "\n", " ")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + " " + substr("result",
    s notFound, sd(notFound, length("result"))), "\n", " ") else "result" fi
--->
"result"
*********** trial #24
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("result", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "result"
N?:FindResult --> notFound
*********** success #24
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> notFound
splitDot("result")
--->
if notFound :: Nat and (startsWith("result", "f") or startsWith("result", "i"))
    then qid(substr("result", 0, notFound)) if substr("result", notFound, sd(
    notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("result", 0, notFound)) if substr("result", notFound,
    sd(notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
--->
qid("result")
*********** equation
(built-in equation for symbol qid)
qid("result")
--->
'result
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64
    '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`)
    '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #25
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #25
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #26
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #26
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #27
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #27
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`( 'type
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #28
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #28
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #29
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #29
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #30
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #30
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`( 'type
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #31
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #31
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #32
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #32
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #33
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #33
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'type '$type1
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #34
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #34
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #35
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #35
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #36
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #36
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('type '$type1 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #37
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #37
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #38
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #38
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #39
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #39
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'type
QL:QidList --> '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('type '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('type), "\"") then 'type else if startsWith(string('type),
    "$") then qid("\"" + string('type) + "\"") else splitDot(removeChar(
    removeChar(string('type), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('type)
--->
"type"
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'type else if startsWith("type", "$") then qid("\"" + "type" +
    "\"") else splitDot(removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("type", "$") then qid("\"" + "type" + "\"") else splitDot(
    removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "type" + "\"") else splitDot(removeChar(removeChar(
    "type", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("type", "_", "~"), "\n", " "))
*********** trial #40
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #40
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("type", "_", "~")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + "~" + substr(
    "type", s notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + "~" + substr("type", s
    notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
--->
"type"
*********** trial #41
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #41
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("type", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + " " + substr(
    "type", s notFound, sd(notFound, length("type"))), "\n", " ") else "type"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + " " + substr("type", s
    notFound, sd(notFound, length("type"))), "\n", " ") else "type" fi
--->
"type"
*********** trial #42
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("type", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "type"
N?:FindResult --> notFound
*********** success #42
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> notFound
splitDot("type")
--->
if notFound :: Nat and (startsWith("type", "f") or startsWith("type", "i"))
    then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
--->
qid("type")
*********** equation
(built-in equation for symbol qid)
qid("type")
--->
'type
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$type1
QL:QidList --> '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$type1 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$type1), "\"") then '$type1 else if startsWith(string(
    '$type1), "$") then qid("\"" + string('$type1) + "\"") else splitDot(
    removeChar(removeChar(string('$type1), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$type1)
--->
"$type1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$type1 else if startsWith("$type1", "$") then qid("\"" +
    "$type1" + "\"") else splitDot(removeChar(removeChar("$type1", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$type1", "$") then qid("\"" + "$type1" + "\"") else splitDot(
    removeChar(removeChar("$type1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type1", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$type1" + "\"") else splitDot(removeChar(removeChar(
    "$type1", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$type1" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$type1"
--->
"\"$type1"
*********** equation
(built-in equation for symbol _+_)
"\"$type1" + "\""
--->
"\"$type1\""
*********** equation
(built-in equation for symbol qid)
qid("\"$type1\"")
--->
'"$type1"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #43
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #43
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #44
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #44
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #45
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #45
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #46
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #46
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #47
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #47
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #48
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #48
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #49
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #49
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #50
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #50
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #51
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #51
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'param
QL:QidList --> 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('param), "\"") then 'param else if startsWith(string(
    'param), "$") then qid("\"" + string('param) + "\"") else splitDot(
    removeChar(removeChar(string('param), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('param)
--->
"param"
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'param else if startsWith("param", "$") then qid("\"" + "param" +
    "\"") else splitDot(removeChar(removeChar("param", "_", "~"), "\n", " "))
    fi fi
--->
if startsWith("param", "$") then qid("\"" + "param" + "\"") else splitDot(
    removeChar(removeChar("param", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "param" + "\"") else splitDot(removeChar(removeChar(
    "param", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("param", "_", "~"), "\n", " "))
*********** trial #52
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("param", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #52
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("param", "_", "~")
--->
if notFound :: Nat then removeChar(substr("param", 0, notFound) + "~" + substr(
    "param", s notFound, sd(notFound, length("param"))), "_", "~") else "param"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("param", 0, notFound) + "~" + substr("param", s
    notFound, sd(notFound, length("param"))), "_", "~") else "param" fi
--->
"param"
*********** trial #53
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("param", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #53
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("param", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("param", 0, notFound) + " " + substr(
    "param", s notFound, sd(notFound, length("param"))), "\n", " ") else
    "param" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("param", 0, notFound) + " " + substr("param", s
    notFound, sd(notFound, length("param"))), "\n", " ") else "param" fi
--->
"param"
*********** trial #54
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "param"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("param", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "param"
N?:FindResult --> notFound
*********** success #54
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "param"
N?:FindResult --> notFound
splitDot("param")
--->
if notFound :: Nat and (startsWith("param", "f") or startsWith("param", "i"))
    then qid(substr("param", 0, notFound)) if substr("param", notFound, sd(
    notFound, length("param"))) =/= ".const" then qid(substr("param", notFound,
    1)) if (startsWith(substr("param", notFound, sd(notFound, length(
    "param"))), ".demote") or startsWith(substr("param", notFound, sd(notFound,
    length("param"))), ".promote")) or startsWith(substr("param", notFound, sd(
    notFound, length("param"))), ".wrap") then splitConversion(substr("param",
    s notFound, sd(notFound, length("param")))) else qid(substr("param", s
    notFound, sd(notFound, length("param")))) fi else qid(substr("param",
    notFound, sd(notFound, length("param")))) fi else qid("param") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("param", 0, notFound)) if substr("param", notFound,
    sd(notFound, length("param"))) =/= ".const" then qid(substr("param",
    notFound, 1)) if (startsWith(substr("param", notFound, sd(notFound, length(
    "param"))), ".demote") or startsWith(substr("param", notFound, sd(notFound,
    length("param"))), ".promote")) or startsWith(substr("param", notFound, sd(
    notFound, length("param"))), ".wrap") then splitConversion(substr("param",
    s notFound, sd(notFound, length("param")))) else qid(substr("param", s
    notFound, sd(notFound, length("param")))) fi else qid(substr("param",
    notFound, sd(notFound, length("param")))) fi else qid("param") fi
--->
qid("param")
*********** equation
(built-in equation for symbol qid)
qid("param")
--->
'param
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func
    '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #55
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #55
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #56
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #56
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #57
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #57
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) '`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'result 'i64
    '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #58
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #58
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #59
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #59
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #60
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #60
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`( 'result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('result 'i64 '`)
    '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #61
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #61
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #62
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #62
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #63
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #63
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'result
QL:QidList --> 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('result 'i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('result), "\"") then 'result else if startsWith(string(
    'result), "$") then qid("\"" + string('result) + "\"") else splitDot(
    removeChar(removeChar(string('result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64
    '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('result)
--->
"result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'result else if startsWith("result", "$") then qid("\"" +
    "result" + "\"") else splitDot(removeChar(removeChar("result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("result", "$") then qid("\"" + "result" + "\"") else splitDot(
    removeChar(removeChar("result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "result" + "\"") else splitDot(removeChar(removeChar(
    "result", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("result", "_", "~"), "\n", " "))
*********** trial #64
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #64
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("result", "_", "~")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + "~" +
    substr("result", s notFound, sd(notFound, length("result"))), "_", "~")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + "~" + substr("result",
    s notFound, sd(notFound, length("result"))), "_", "~") else "result" fi
--->
"result"
*********** trial #65
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #65
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("result", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + " " +
    substr("result", s notFound, sd(notFound, length("result"))), "\n", " ")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + " " + substr("result",
    s notFound, sd(notFound, length("result"))), "\n", " ") else "result" fi
--->
"result"
*********** trial #66
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("result", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "result"
N?:FindResult --> notFound
*********** success #66
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> notFound
splitDot("result")
--->
if notFound :: Nat and (startsWith("result", "f") or startsWith("result", "i"))
    then qid(substr("result", 0, notFound)) if substr("result", notFound, sd(
    notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("result", 0, notFound)) if substr("result", notFound,
    sd(notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
--->
qid("result")
*********** equation
(built-in equation for symbol qid)
qid("result")
--->
'result
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`)
    '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`)
    '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #67
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #67
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #68
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #68
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #69
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #69
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #70
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #70
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #71
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #71
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #72
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #72
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`( 'type
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #73
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #73
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #74
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #74
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #75
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #75
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'type '$type2
    '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #76
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #76
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #77
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #77
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #78
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #78
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('type '$type2 '`(
    'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #79
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #79
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #80
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #80
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #81
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #81
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'type
QL:QidList --> '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('type '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('type), "\"") then 'type else if startsWith(string('type),
    "$") then qid("\"" + string('type) + "\"") else splitDot(removeChar(
    removeChar(string('type), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('type)
--->
"type"
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'type else if startsWith("type", "$") then qid("\"" + "type" +
    "\"") else splitDot(removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("type", "$") then qid("\"" + "type" + "\"") else splitDot(
    removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "type" + "\"") else splitDot(removeChar(removeChar(
    "type", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("type", "_", "~"), "\n", " "))
*********** trial #82
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #82
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("type", "_", "~")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + "~" + substr(
    "type", s notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + "~" + substr("type", s
    notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
--->
"type"
*********** trial #83
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #83
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("type", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + " " + substr(
    "type", s notFound, sd(notFound, length("type"))), "\n", " ") else "type"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + " " + substr("type", s
    notFound, sd(notFound, length("type"))), "\n", " ") else "type" fi
--->
"type"
*********** trial #84
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("type", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "type"
N?:FindResult --> notFound
*********** success #84
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> notFound
splitDot("type")
--->
if notFound :: Nat and (startsWith("type", "f") or startsWith("type", "i"))
    then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
--->
qid("type")
*********** equation
(built-in equation for symbol qid)
qid("type")
--->
'type
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$type2
QL:QidList --> '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$type2 '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$type2), "\"") then '$type2 else if startsWith(string(
    '$type2), "$") then qid("\"" + string('$type2) + "\"") else splitDot(
    removeChar(removeChar(string('$type2), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`)
    '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$type2)
--->
"$type2"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type2", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$type2 else if startsWith("$type2", "$") then qid("\"" +
    "$type2" + "\"") else splitDot(removeChar(removeChar("$type2", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$type2", "$") then qid("\"" + "$type2" + "\"") else splitDot(
    removeChar(removeChar("$type2", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type2", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$type2" + "\"") else splitDot(removeChar(removeChar(
    "$type2", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$type2" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$type2"
--->
"\"$type2"
*********** equation
(built-in equation for symbol _+_)
"\"$type2" + "\""
--->
"\"$type2\""
*********** equation
(built-in equation for symbol qid)
qid("\"$type2\"")
--->
'"$type2"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '`( 'param
    'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #85
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #85
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #86
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #86
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #87
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #87
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`(
    'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`(
    'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #88
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #88
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #89
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #89
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #90
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #90
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('param 'i64 '`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #91
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #91
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #92
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #92
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #93
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #93
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'param
QL:QidList --> 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('param 'i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('param), "\"") then 'param else if startsWith(string(
    'param), "$") then qid("\"" + string('param) + "\"") else splitDot(
    removeChar(removeChar(string('param), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start"
    '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32
    '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('param)
--->
"param"
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'param else if startsWith("param", "$") then qid("\"" + "param" +
    "\"") else splitDot(removeChar(removeChar("param", "_", "~"), "\n", " "))
    fi fi
--->
if startsWith("param", "$") then qid("\"" + "param" + "\"") else splitDot(
    removeChar(removeChar("param", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "param" + "\"") else splitDot(removeChar(removeChar(
    "param", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("param", "_", "~"), "\n", " "))
*********** trial #94
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("param", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #94
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("param", "_", "~")
--->
if notFound :: Nat then removeChar(substr("param", 0, notFound) + "~" + substr(
    "param", s notFound, sd(notFound, length("param"))), "_", "~") else "param"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("param", 0, notFound) + "~" + substr("param", s
    notFound, sd(notFound, length("param"))), "_", "~") else "param" fi
--->
"param"
*********** trial #95
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("param", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #95
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "param"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("param", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("param", 0, notFound) + " " + substr(
    "param", s notFound, sd(notFound, length("param"))), "\n", " ") else
    "param" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("param", 0, notFound) + " " + substr("param", s
    notFound, sd(notFound, length("param"))), "\n", " ") else "param" fi
--->
"param"
*********** trial #96
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "param"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("param", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "param"
N?:FindResult --> notFound
*********** success #96
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "param"
N?:FindResult --> notFound
splitDot("param")
--->
if notFound :: Nat and (startsWith("param", "f") or startsWith("param", "i"))
    then qid(substr("param", 0, notFound)) if substr("param", notFound, sd(
    notFound, length("param"))) =/= ".const" then qid(substr("param", notFound,
    1)) if (startsWith(substr("param", notFound, sd(notFound, length(
    "param"))), ".demote") or startsWith(substr("param", notFound, sd(notFound,
    length("param"))), ".promote")) or startsWith(substr("param", notFound, sd(
    notFound, length("param"))), ".wrap") then splitConversion(substr("param",
    s notFound, sd(notFound, length("param")))) else qid(substr("param", s
    notFound, sd(notFound, length("param")))) fi else qid(substr("param",
    notFound, sd(notFound, length("param")))) fi else qid("param") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("param", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("param", 0, notFound)) if substr("param", notFound,
    sd(notFound, length("param"))) =/= ".const" then qid(substr("param",
    notFound, 1)) if (startsWith(substr("param", notFound, sd(notFound, length(
    "param"))), ".demote") or startsWith(substr("param", notFound, sd(notFound,
    length("param"))), ".promote")) or startsWith(substr("param", notFound, sd(
    notFound, length("param"))), ".wrap") then splitConversion(substr("param",
    s notFound, sd(notFound, length("param")))) else qid(substr("param", s
    notFound, sd(notFound, length("param")))) fi else qid(substr("param",
    notFound, sd(notFound, length("param")))) fi else qid("param") fi
--->
qid("param")
*********** equation
(built-in equation for symbol qid)
qid("param")
--->
'param
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func
    '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`(
    'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #97
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #97
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #98
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #98
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #99
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #99
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) '`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func
    '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'result 'i64
    '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #100
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #100
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #101
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #101
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #102
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #102
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`)
    '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const
    '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0
    '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #103
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #103
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #104
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #104
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #105
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #105
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'result
QL:QidList --> 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('result 'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`)
    '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const
    '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('result), "\"") then 'result else if startsWith(string(
    'result), "$") then qid("\"" + string('result) + "\"") else splitDot(
    removeChar(removeChar(string('result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('result)
--->
"result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'result else if startsWith("result", "$") then qid("\"" +
    "result" + "\"") else splitDot(removeChar(removeChar("result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("result", "$") then qid("\"" + "result" + "\"") else splitDot(
    removeChar(removeChar("result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "result" + "\"") else splitDot(removeChar(removeChar(
    "result", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("result", "_", "~"), "\n", " "))
*********** trial #106
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #106
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("result", "_", "~")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + "~" +
    substr("result", s notFound, sd(notFound, length("result"))), "_", "~")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + "~" + substr("result",
    s notFound, sd(notFound, length("result"))), "_", "~") else "result" fi
--->
"result"
*********** trial #107
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #107
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("result", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + " " +
    substr("result", s notFound, sd(notFound, length("result"))), "\n", " ")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + " " + substr("result",
    s notFound, sd(notFound, length("result"))), "\n", " ") else "result" fi
--->
"result"
*********** trial #108
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("result", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "result"
N?:FindResult --> notFound
*********** success #108
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> notFound
splitDot("result")
--->
if notFound :: Nat and (startsWith("result", "f") or startsWith("result", "i"))
    then qid(substr("result", 0, notFound)) if substr("result", notFound, sd(
    notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("result", 0, notFound)) if substr("result", notFound,
    sd(notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
--->
qid("result")
*********** equation
(built-in equation for symbol qid)
qid("result")
--->
'result
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`(
    'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`)
    '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #109
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #109
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #110
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #110
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #111
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #111
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #112
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #112
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #113
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #113
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #114
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #114
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #115
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #115
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #116
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #116
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #117
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #117
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'export
    '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #118
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #118
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #119
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #119
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #120
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #120
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('export '"$start"
    '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32
    '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #121
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #121
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #122
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #122
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #123
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #123
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'export
QL:QidList --> '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('export '"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('export), "\"") then 'export else if startsWith(string(
    'export), "$") then qid("\"" + string('export) + "\"") else splitDot(
    removeChar(removeChar(string('export), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result
    'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('export)
--->
"export"
*********** equation
(built-in equation for symbol startsWith)
startsWith("export", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'export else if startsWith("export", "$") then qid("\"" +
    "export" + "\"") else splitDot(removeChar(removeChar("export", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("export", "$") then qid("\"" + "export" + "\"") else splitDot(
    removeChar(removeChar("export", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("export", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "export" + "\"") else splitDot(removeChar(removeChar(
    "export", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("export", "_", "~"), "\n", " "))
*********** trial #124
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "export"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("export", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "export"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #124
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "export"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("export", "_", "~")
--->
if notFound :: Nat then removeChar(substr("export", 0, notFound) + "~" +
    substr("export", s notFound, sd(notFound, length("export"))), "_", "~")
    else "export" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("export", 0, notFound) + "~" + substr("export",
    s notFound, sd(notFound, length("export"))), "_", "~") else "export" fi
--->
"export"
*********** trial #125
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "export"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("export", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "export"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #125
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "export"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("export", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("export", 0, notFound) + " " +
    substr("export", s notFound, sd(notFound, length("export"))), "\n", " ")
    else "export" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("export", 0, notFound) + " " + substr("export",
    s notFound, sd(notFound, length("export"))), "\n", " ") else "export" fi
--->
"export"
*********** trial #126
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "export"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("export", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "export"
N?:FindResult --> notFound
*********** success #126
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "export"
N?:FindResult --> notFound
splitDot("export")
--->
if notFound :: Nat and (startsWith("export", "f") or startsWith("export", "i"))
    then qid(substr("export", 0, notFound)) if substr("export", notFound, sd(
    notFound, length("export"))) =/= ".const" then qid(substr("export",
    notFound, 1)) if (startsWith(substr("export", notFound, sd(notFound,
    length("export"))), ".demote") or startsWith(substr("export", notFound, sd(
    notFound, length("export"))), ".promote")) or startsWith(substr("export",
    notFound, sd(notFound, length("export"))), ".wrap") then splitConversion(
    substr("export", s notFound, sd(notFound, length("export")))) else qid(
    substr("export", s notFound, sd(notFound, length("export")))) fi else qid(
    substr("export", notFound, sd(notFound, length("export")))) fi else qid(
    "export") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("export", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("export", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("export", 0, notFound)) if substr("export", notFound,
    sd(notFound, length("export"))) =/= ".const" then qid(substr("export",
    notFound, 1)) if (startsWith(substr("export", notFound, sd(notFound,
    length("export"))), ".demote") or startsWith(substr("export", notFound, sd(
    notFound, length("export"))), ".promote")) or startsWith(substr("export",
    notFound, sd(notFound, length("export"))), ".wrap") then splitConversion(
    substr("export", s notFound, sd(notFound, length("export")))) else qid(
    substr("export", s notFound, sd(notFound, length("export")))) fi else qid(
    substr("export", notFound, sd(notFound, length("export")))) fi else qid(
    "export") fi
--->
qid("export")
*********** equation
(built-in equation for symbol qid)
qid("export")
--->
'export
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '"$start"
QL:QidList --> '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('"$start" '`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('"$start"), "\"") then '"$start" else if startsWith(
    string('"$start"), "$") then qid("\"" + string('"$start") + "\"") else
    splitDot(removeChar(removeChar(string('"$start"), "_", "~"), "\n", " ")) fi
    fi tokenize-wasm('`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64
    '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('"$start")
--->
"\"$start\""
*********** equation
(built-in equation for symbol startsWith)
startsWith("\"$start\"", "\"")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then '"$start" else if startsWith("\"$start\"", "$") then qid("\"" +
    "\"$start\"" + "\"") else splitDot(removeChar(removeChar("\"$start\"", "_",
    "~"), "\n", " ")) fi fi
--->
'"$start"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '0 '`) '`)
    '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #127
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #127
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #128
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #128
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #129
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #129
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local
    'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('func '0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm('0 '`)
    '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const
    '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #130
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #130
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #131
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #131
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #132
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #132
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32
    '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('0 '`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32
    '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #133
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #133
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #134
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #134
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #135
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #135
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) '`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32
    '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`( 'func
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #136
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #136
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #137
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #137
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #138
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #138
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) '`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'func '$start
    '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #139
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #139
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #140
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #140
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #141
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #141
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`( 'func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '$start '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #142
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #142
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #143
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #143
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #144
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #144
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('func '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const
    '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #145
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #145
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #146
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #146
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #147
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #147
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$start
QL:QidList --> '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$start '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$start), "\"") then '$start else if startsWith(string(
    '$start), "$") then qid("\"" + string('$start) + "\"") else splitDot(
    removeChar(removeChar(string('$start), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$start)
--->
"$start"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$start", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$start else if startsWith("$start", "$") then qid("\"" +
    "$start" + "\"") else splitDot(removeChar(removeChar("$start", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$start", "$") then qid("\"" + "$start" + "\"") else splitDot(
    removeChar(removeChar("$start", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$start", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$start" + "\"") else splitDot(removeChar(removeChar(
    "$start", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$start" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$start"
--->
"\"$start"
*********** equation
(built-in equation for symbol _+_)
"\"$start" + "\""
--->
"\"$start\""
*********** equation
(built-in equation for symbol qid)
qid("\"$start\"")
--->
'"$start"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('result 'i64 '`)
    '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #148
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #148
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #149
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #149
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #150
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #150
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'result
QL:QidList --> 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('result 'i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set
    '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('result), "\"") then 'result else if startsWith(string(
    'result), "$") then qid("\"" + string('result) + "\"") else splitDot(
    removeChar(removeChar(string('result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('result)
--->
"result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'result else if startsWith("result", "$") then qid("\"" +
    "result" + "\"") else splitDot(removeChar(removeChar("result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("result", "$") then qid("\"" + "result" + "\"") else splitDot(
    removeChar(removeChar("result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "result" + "\"") else splitDot(removeChar(removeChar(
    "result", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("result", "_", "~"), "\n", " "))
*********** trial #151
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #151
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("result", "_", "~")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + "~" +
    substr("result", s notFound, sd(notFound, length("result"))), "_", "~")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + "~" + substr("result",
    s notFound, sd(notFound, length("result"))), "_", "~") else "result" fi
--->
"result"
*********** trial #152
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #152
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("result", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + " " +
    substr("result", s notFound, sd(notFound, length("result"))), "\n", " ")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + " " + substr("result",
    s notFound, sd(notFound, length("result"))), "\n", " ") else "result" fi
--->
"result"
*********** trial #153
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("result", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "result"
N?:FindResult --> notFound
*********** success #153
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> notFound
splitDot("result")
--->
if notFound :: Nat and (startsWith("result", "f") or startsWith("result", "i"))
    then qid(substr("result", 0, notFound)) if substr("result", notFound, sd(
    notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("result", 0, notFound)) if substr("result", notFound,
    sd(notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
--->
qid("result")
*********** equation
(built-in equation for symbol qid)
qid("result")
--->
'result
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #154
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #154
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #155
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #155
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #156
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #156
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #157
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #157
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #158
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #158
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #159
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #159
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get
    '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('local 'i32 '`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #160
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #160
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #161
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #161
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #162
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #162
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'local
QL:QidList --> 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('local 'i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('local), "\"") then 'local else if startsWith(string(
    'local), "$") then qid("\"" + string('local) + "\"") else splitDot(
    removeChar(removeChar(string('local), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1
    'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('local)
--->
"local"
*********** equation
(built-in equation for symbol startsWith)
startsWith("local", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'local else if startsWith("local", "$") then qid("\"" + "local" +
    "\"") else splitDot(removeChar(removeChar("local", "_", "~"), "\n", " "))
    fi fi
--->
if startsWith("local", "$") then qid("\"" + "local" + "\"") else splitDot(
    removeChar(removeChar("local", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("local", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "local" + "\"") else splitDot(removeChar(removeChar(
    "local", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("local", "_", "~"), "\n", " "))
*********** trial #163
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #163
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("local", "_", "~")
--->
if notFound :: Nat then removeChar(substr("local", 0, notFound) + "~" + substr(
    "local", s notFound, sd(notFound, length("local"))), "_", "~") else "local"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local", 0, notFound) + "~" + substr("local", s
    notFound, sd(notFound, length("local"))), "_", "~") else "local" fi
--->
"local"
*********** trial #164
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #164
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("local", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("local", 0, notFound) + " " + substr(
    "local", s notFound, sd(notFound, length("local"))), "\n", " ") else
    "local" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local", 0, notFound) + " " + substr("local", s
    notFound, sd(notFound, length("local"))), "\n", " ") else "local" fi
--->
"local"
*********** trial #165
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("local", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "local"
N?:FindResult --> notFound
*********** success #165
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local"
N?:FindResult --> notFound
splitDot("local")
--->
if notFound :: Nat and (startsWith("local", "f") or startsWith("local", "i"))
    then qid(substr("local", 0, notFound)) if substr("local", notFound, sd(
    notFound, length("local"))) =/= ".const" then qid(substr("local", notFound,
    1)) if (startsWith(substr("local", notFound, sd(notFound, length(
    "local"))), ".demote") or startsWith(substr("local", notFound, sd(notFound,
    length("local"))), ".promote")) or startsWith(substr("local", notFound, sd(
    notFound, length("local"))), ".wrap") then splitConversion(substr("local",
    s notFound, sd(notFound, length("local")))) else qid(substr("local", s
    notFound, sd(notFound, length("local")))) fi else qid(substr("local",
    notFound, sd(notFound, length("local")))) fi else qid("local") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("local", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("local", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("local", 0, notFound)) if substr("local", notFound,
    sd(notFound, length("local"))) =/= ".const" then qid(substr("local",
    notFound, 1)) if (startsWith(substr("local", notFound, sd(notFound, length(
    "local"))), ".demote") or startsWith(substr("local", notFound, sd(notFound,
    length("local"))), ".promote")) or startsWith(substr("local", notFound, sd(
    notFound, length("local"))), ".wrap") then splitConversion(substr("local",
    s notFound, sd(notFound, length("local")))) else qid(substr("local", s
    notFound, sd(notFound, length("local")))) fi else qid(substr("local",
    notFound, sd(notFound, length("local")))) fi else qid("local") fi
--->
qid("local")
*********** equation
(built-in equation for symbol qid)
qid("local")
--->
'local
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i32
QL:QidList --> '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`(
    'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i32 '`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i32), "\"") then 'i32 else if startsWith(string('i32),
    "$") then qid("\"" + string('i32) + "\"") else splitDot(removeChar(
    removeChar(string('i32), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`)
    'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i32)
--->
"i32"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i32", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i32 else if startsWith("i32", "$") then qid("\"" + "i32" + "\"")
    else splitDot(removeChar(removeChar("i32", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i32", "$") then qid("\"" + "i32" + "\"") else splitDot(
    removeChar(removeChar("i32", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i32", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i32" + "\"") else splitDot(removeChar(removeChar(
    "i32", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i32", "_", "~"), "\n", " "))
*********** trial #166
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i32"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i32", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i32"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #166
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i32"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i32", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i32", 0, notFound) + "~" + substr(
    "i32", s notFound, sd(notFound, length("i32"))), "_", "~") else "i32" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i32", 0, notFound) + "~" + substr("i32", s
    notFound, sd(notFound, length("i32"))), "_", "~") else "i32" fi
--->
"i32"
*********** trial #167
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i32"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i32", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i32"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #167
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i32"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i32", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i32", 0, notFound) + " " + substr(
    "i32", s notFound, sd(notFound, length("i32"))), "\n", " ") else "i32" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i32", 0, notFound) + " " + substr("i32", s
    notFound, sd(notFound, length("i32"))), "\n", " ") else "i32" fi
--->
"i32"
*********** trial #168
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i32"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i32", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i32"
N?:FindResult --> notFound
*********** success #168
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i32"
N?:FindResult --> notFound
splitDot("i32")
--->
if notFound :: Nat and (startsWith("i32", "f") or startsWith("i32", "i")) then
    qid(substr("i32", 0, notFound)) if substr("i32", notFound, sd(notFound,
    length("i32"))) =/= ".const" then qid(substr("i32", notFound, 1)) if (
    startsWith(substr("i32", notFound, sd(notFound, length("i32"))), ".demote")
    or startsWith(substr("i32", notFound, sd(notFound, length("i32"))),
    ".promote")) or startsWith(substr("i32", notFound, sd(notFound, length(
    "i32"))), ".wrap") then splitConversion(substr("i32", s notFound, sd(
    notFound, length("i32")))) else qid(substr("i32", s notFound, sd(notFound,
    length("i32")))) fi else qid(substr("i32", notFound, sd(notFound, length(
    "i32")))) fi else qid("i32") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i32", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i32", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i32", 0, notFound)) if substr("i32", notFound, sd(
    notFound, length("i32"))) =/= ".const" then qid(substr("i32", notFound, 1))
    if (startsWith(substr("i32", notFound, sd(notFound, length("i32"))),
    ".demote") or startsWith(substr("i32", notFound, sd(notFound, length(
    "i32"))), ".promote")) or startsWith(substr("i32", notFound, sd(notFound,
    length("i32"))), ".wrap") then splitConversion(substr("i32", s notFound,
    sd(notFound, length("i32")))) else qid(substr("i32", s notFound, sd(
    notFound, length("i32")))) fi else qid(substr("i32", notFound, sd(notFound,
    length("i32")))) fi else qid("i32") fi
--->
qid("i32")
*********** equation
(built-in equation for symbol qid)
qid("i32")
--->
'i32
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`(
    'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) 'i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`(
    'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '5
    'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #169
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #169
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #170
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #170
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #171
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #171
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('i64.const '5 'global.set '$gb1 'global.get '$gb1 'block '`(
    'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #172
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #172
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #173
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #173
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #174
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #174
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '5
QL:QidList --> 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`)
    'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1
    '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const
    '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('5 'global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2
    '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('5), "\"") then '5 else if startsWith(string('5), "$")
    then qid("\"" + string('5) + "\"") else splitDot(removeChar(removeChar(
    string('5), "_", "~"), "\n", " ")) fi fi tokenize-wasm('global.set '$gb1
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('5)
--->
"5"
*********** equation
(built-in equation for symbol startsWith)
startsWith("5", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '5 else if startsWith("5", "$") then qid("\"" + "5" + "\"") else
    splitDot(removeChar(removeChar("5", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("5", "$") then qid("\"" + "5" + "\"") else splitDot(removeChar(
    removeChar("5", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("5", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "5" + "\"") else splitDot(removeChar(removeChar("5",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("5", "_", "~"), "\n", " "))
*********** trial #175
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "5"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("5", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "5"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #175
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "5"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("5", "_", "~")
--->
if notFound :: Nat then removeChar(substr("5", 0, notFound) + "~" + substr("5",
    s notFound, sd(notFound, length("5"))), "_", "~") else "5" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("5", 0, notFound) + "~" + substr("5", s
    notFound, sd(notFound, length("5"))), "_", "~") else "5" fi
--->
"5"
*********** trial #176
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "5"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("5", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "5"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #176
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "5"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("5", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("5", 0, notFound) + " " + substr("5",
    s notFound, sd(notFound, length("5"))), "\n", " ") else "5" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("5", 0, notFound) + " " + substr("5", s
    notFound, sd(notFound, length("5"))), "\n", " ") else "5" fi
--->
"5"
*********** trial #177
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "5"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("5", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "5"
N?:FindResult --> notFound
*********** success #177
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "5"
N?:FindResult --> notFound
splitDot("5")
--->
if notFound :: Nat and (startsWith("5", "f") or startsWith("5", "i")) then qid(
    substr("5", 0, notFound)) if substr("5", notFound, sd(notFound, length(
    "5"))) =/= ".const" then qid(substr("5", notFound, 1)) if (startsWith(
    substr("5", notFound, sd(notFound, length("5"))), ".demote") or startsWith(
    substr("5", notFound, sd(notFound, length("5"))), ".promote")) or
    startsWith(substr("5", notFound, sd(notFound, length("5"))), ".wrap") then
    splitConversion(substr("5", s notFound, sd(notFound, length("5")))) else
    qid(substr("5", s notFound, sd(notFound, length("5")))) fi else qid(substr(
    "5", notFound, sd(notFound, length("5")))) fi else qid("5") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("5", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("5", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("5", 0, notFound)) if substr("5", notFound, sd(
    notFound, length("5"))) =/= ".const" then qid(substr("5", notFound, 1)) if
    (startsWith(substr("5", notFound, sd(notFound, length("5"))), ".demote") or
    startsWith(substr("5", notFound, sd(notFound, length("5"))), ".promote"))
    or startsWith(substr("5", notFound, sd(notFound, length("5"))), ".wrap")
    then splitConversion(substr("5", s notFound, sd(notFound, length("5"))))
    else qid(substr("5", s notFound, sd(notFound, length("5")))) fi else qid(
    substr("5", notFound, sd(notFound, length("5")))) fi else qid("5") fi
--->
qid("5")
*********** equation
(built-in equation for symbol qid)
qid("5")
--->
'5
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'global.set
QL:QidList --> '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0
    'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('global.set '$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`)
    'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1
    '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const
    '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('global.set), "\"") then 'global.set else if startsWith(
    string('global.set), "$") then qid("\"" + string('global.set) + "\"") else
    splitDot(removeChar(removeChar(string('global.set), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`)
    'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1
    '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const
    '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('global.set)
--->
"global.set"
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.set", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'global.set else if startsWith("global.set", "$") then qid("\"" +
    "global.set" + "\"") else splitDot(removeChar(removeChar("global.set", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("global.set", "$") then qid("\"" + "global.set" + "\"") else
    splitDot(removeChar(removeChar("global.set", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.set", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "global.set" + "\"") else splitDot(removeChar(
    removeChar("global.set", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("global.set", "_", "~"), "\n", " "))
*********** trial #178
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.set"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global.set", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global.set"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #178
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.set"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("global.set", "_", "~")
--->
if notFound :: Nat then removeChar(substr("global.set", 0, notFound) + "~" +
    substr("global.set", s notFound, sd(notFound, length("global.set"))), "_",
    "~") else "global.set" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global.set", 0, notFound) + "~" + substr(
    "global.set", s notFound, sd(notFound, length("global.set"))), "_", "~")
    else "global.set" fi
--->
"global.set"
*********** trial #179
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.set"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global.set", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global.set"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #179
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.set"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("global.set", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("global.set", 0, notFound) + " " +
    substr("global.set", s notFound, sd(notFound, length("global.set"))), "\n",
    " ") else "global.set" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global.set", 0, notFound) + " " + substr(
    "global.set", s notFound, sd(notFound, length("global.set"))), "\n", " ")
    else "global.set" fi
--->
"global.set"
*********** trial #180
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global.set"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("global.set", ".", 0)
--->
6
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "global.set"
N?:FindResult --> 6
*********** success #180
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global.set"
N?:FindResult --> 6
splitDot("global.set")
--->
if 6 :: Nat and (startsWith("global.set", "f") or startsWith("global.set",
    "i")) then qid(substr("global.set", 0, 6)) if substr("global.set", 6, sd(6,
    length("global.set"))) =/= ".const" then qid(substr("global.set", 6, 1)) if
    (startsWith(substr("global.set", 6, sd(6, length("global.set"))),
    ".demote") or startsWith(substr("global.set", 6, sd(6, length(
    "global.set"))), ".promote")) or startsWith(substr("global.set", 6, sd(6,
    length("global.set"))), ".wrap") then splitConversion(substr("global.set",
    s 6, sd(6, length("global.set")))) else qid(substr("global.set", s 6, sd(6,
    length("global.set")))) fi else qid(substr("global.set", 6, sd(6, length(
    "global.set")))) fi else qid("global.set") fi
*********** equation
(built-in equation for symbol _::`Nat)
6 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.set", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.set", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("global.set", 0, 6)) if substr("global.set", 6, sd(6,
    length("global.set"))) =/= ".const" then qid(substr("global.set", 6, 1)) if
    (startsWith(substr("global.set", 6, sd(6, length("global.set"))),
    ".demote") or startsWith(substr("global.set", 6, sd(6, length(
    "global.set"))), ".promote")) or startsWith(substr("global.set", 6, sd(6,
    length("global.set"))), ".wrap") then splitConversion(substr("global.set",
    s 6, sd(6, length("global.set")))) else qid(substr("global.set", s 6, sd(6,
    length("global.set")))) fi else qid(substr("global.set", 6, sd(6, length(
    "global.set")))) fi else qid("global.set") fi
--->
qid("global.set")
*********** equation
(built-in equation for symbol qid)
qid("global.set")
--->
'global.set
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$gb1
QL:QidList --> 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$gb1 'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$gb1), "\"") then '$gb1 else if startsWith(string('$gb1),
    "$") then qid("\"" + string('$gb1) + "\"") else splitDot(removeChar(
    removeChar(string('$gb1), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    'global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$gb1)
--->
"$gb1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$gb1 else if startsWith("$gb1", "$") then qid("\"" + "$gb1" +
    "\"") else splitDot(removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("$gb1", "$") then qid("\"" + "$gb1" + "\"") else splitDot(
    removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$gb1" + "\"") else splitDot(removeChar(removeChar(
    "$gb1", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$gb1" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$gb1"
--->
"\"$gb1"
*********** equation
(built-in equation for symbol _+_)
"\"$gb1" + "\""
--->
"\"$gb1\""
*********** equation
(built-in equation for symbol qid)
qid("\"$gb1\"")
--->
'"$gb1"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'global.get
QL:QidList --> '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end
    '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('global.get '$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('global.get), "\"") then 'global.get else if startsWith(
    string('global.get), "$") then qid("\"" + string('global.get) + "\"") else
    splitDot(removeChar(removeChar(string('global.get), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('$gb1 'block '`( 'type '$type2 '`) 'br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('global.get)
--->
"global.get"
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.get", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'global.get else if startsWith("global.get", "$") then qid("\"" +
    "global.get" + "\"") else splitDot(removeChar(removeChar("global.get", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("global.get", "$") then qid("\"" + "global.get" + "\"") else
    splitDot(removeChar(removeChar("global.get", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.get", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "global.get" + "\"") else splitDot(removeChar(
    removeChar("global.get", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("global.get", "_", "~"), "\n", " "))
*********** trial #181
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global.get", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #181
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("global.get", "_", "~")
--->
if notFound :: Nat then removeChar(substr("global.get", 0, notFound) + "~" +
    substr("global.get", s notFound, sd(notFound, length("global.get"))), "_",
    "~") else "global.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global.get", 0, notFound) + "~" + substr(
    "global.get", s notFound, sd(notFound, length("global.get"))), "_", "~")
    else "global.get" fi
--->
"global.get"
*********** trial #182
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global.get", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #182
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("global.get", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("global.get", 0, notFound) + " " +
    substr("global.get", s notFound, sd(notFound, length("global.get"))), "\n",
    " ") else "global.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global.get", 0, notFound) + " " + substr(
    "global.get", s notFound, sd(notFound, length("global.get"))), "\n", " ")
    else "global.get" fi
--->
"global.get"
*********** trial #183
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global.get"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("global.get", ".", 0)
--->
6
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "global.get"
N?:FindResult --> 6
*********** success #183
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global.get"
N?:FindResult --> 6
splitDot("global.get")
--->
if 6 :: Nat and (startsWith("global.get", "f") or startsWith("global.get",
    "i")) then qid(substr("global.get", 0, 6)) if substr("global.get", 6, sd(6,
    length("global.get"))) =/= ".const" then qid(substr("global.get", 6, 1)) if
    (startsWith(substr("global.get", 6, sd(6, length("global.get"))),
    ".demote") or startsWith(substr("global.get", 6, sd(6, length(
    "global.get"))), ".promote")) or startsWith(substr("global.get", 6, sd(6,
    length("global.get"))), ".wrap") then splitConversion(substr("global.get",
    s 6, sd(6, length("global.get")))) else qid(substr("global.get", s 6, sd(6,
    length("global.get")))) fi else qid(substr("global.get", 6, sd(6, length(
    "global.get")))) fi else qid("global.get") fi
*********** equation
(built-in equation for symbol _::`Nat)
6 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.get", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global.get", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("global.get", 0, 6)) if substr("global.get", 6, sd(6,
    length("global.get"))) =/= ".const" then qid(substr("global.get", 6, 1)) if
    (startsWith(substr("global.get", 6, sd(6, length("global.get"))),
    ".demote") or startsWith(substr("global.get", 6, sd(6, length(
    "global.get"))), ".promote")) or startsWith(substr("global.get", 6, sd(6,
    length("global.get"))), ".wrap") then splitConversion(substr("global.get",
    s 6, sd(6, length("global.get")))) else qid(substr("global.get", s 6, sd(6,
    length("global.get")))) fi else qid(substr("global.get", 6, sd(6, length(
    "global.get")))) fi else qid("global.get") fi
--->
qid("global.get")
*********** equation
(built-in equation for symbol qid)
qid("global.get")
--->
'global.get
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$gb1
QL:QidList --> 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`)
    '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$gb1 'block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end
    '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$gb1), "\"") then '$gb1 else if startsWith(string('$gb1),
    "$") then qid("\"" + string('$gb1) + "\"") else splitDot(removeChar(
    removeChar(string('$gb1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('block
    '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$gb1)
--->
"$gb1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$gb1 else if startsWith("$gb1", "$") then qid("\"" + "$gb1" +
    "\"") else splitDot(removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("$gb1", "$") then qid("\"" + "$gb1" + "\"") else splitDot(
    removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$gb1" + "\"") else splitDot(removeChar(removeChar(
    "$gb1", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$gb1" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$gb1"
--->
"\"$gb1"
*********** equation
(built-in equation for symbol _+_)
"\"$gb1" + "\""
--->
"\"$gb1\""
*********** equation
(built-in equation for symbol qid)
qid("\"$gb1\"")
--->
'"$gb1"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'block
QL:QidList --> '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('block '`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`)
    '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('block), "\"") then 'block else if startsWith(string(
    'block), "$") then qid("\"" + string('block) + "\"") else splitDot(
    removeChar(removeChar(string('block), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('block)
--->
"block"
*********** equation
(built-in equation for symbol startsWith)
startsWith("block", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'block else if startsWith("block", "$") then qid("\"" + "block" +
    "\"") else splitDot(removeChar(removeChar("block", "_", "~"), "\n", " "))
    fi fi
--->
if startsWith("block", "$") then qid("\"" + "block" + "\"") else splitDot(
    removeChar(removeChar("block", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("block", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "block" + "\"") else splitDot(removeChar(removeChar(
    "block", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("block", "_", "~"), "\n", " "))
*********** trial #184
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "block"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("block", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "block"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #184
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "block"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("block", "_", "~")
--->
if notFound :: Nat then removeChar(substr("block", 0, notFound) + "~" + substr(
    "block", s notFound, sd(notFound, length("block"))), "_", "~") else "block"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("block", 0, notFound) + "~" + substr("block", s
    notFound, sd(notFound, length("block"))), "_", "~") else "block" fi
--->
"block"
*********** trial #185
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "block"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("block", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "block"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #185
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "block"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("block", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("block", 0, notFound) + " " + substr(
    "block", s notFound, sd(notFound, length("block"))), "\n", " ") else
    "block" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("block", 0, notFound) + " " + substr("block", s
    notFound, sd(notFound, length("block"))), "\n", " ") else "block" fi
--->
"block"
*********** trial #186
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "block"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("block", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "block"
N?:FindResult --> notFound
*********** success #186
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "block"
N?:FindResult --> notFound
splitDot("block")
--->
if notFound :: Nat and (startsWith("block", "f") or startsWith("block", "i"))
    then qid(substr("block", 0, notFound)) if substr("block", notFound, sd(
    notFound, length("block"))) =/= ".const" then qid(substr("block", notFound,
    1)) if (startsWith(substr("block", notFound, sd(notFound, length(
    "block"))), ".demote") or startsWith(substr("block", notFound, sd(notFound,
    length("block"))), ".promote")) or startsWith(substr("block", notFound, sd(
    notFound, length("block"))), ".wrap") then splitConversion(substr("block",
    s notFound, sd(notFound, length("block")))) else qid(substr("block", s
    notFound, sd(notFound, length("block")))) fi else qid(substr("block",
    notFound, sd(notFound, length("block")))) fi else qid("block") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("block", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("block", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("block", 0, notFound)) if substr("block", notFound,
    sd(notFound, length("block"))) =/= ".const" then qid(substr("block",
    notFound, 1)) if (startsWith(substr("block", notFound, sd(notFound, length(
    "block"))), ".demote") or startsWith(substr("block", notFound, sd(notFound,
    length("block"))), ".promote")) or startsWith(substr("block", notFound, sd(
    notFound, length("block"))), ".wrap") then splitConversion(substr("block",
    s notFound, sd(notFound, length("block")))) else qid(substr("block", s
    notFound, sd(notFound, length("block")))) fi else qid(substr("block",
    notFound, sd(notFound, length("block")))) fi else qid("block") fi
--->
qid("block")
*********** equation
(built-in equation for symbol qid)
qid("block")
--->
'block
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('type '$type2 '`)
    'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1
    '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const
    '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #187
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #187
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #188
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #188
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #189
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #189
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'type
QL:QidList --> '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('type '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('type), "\"") then 'type else if startsWith(string('type),
    "$") then qid("\"" + string('type) + "\"") else splitDot(removeChar(
    removeChar(string('type), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('type)
--->
"type"
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'type else if startsWith("type", "$") then qid("\"" + "type" +
    "\"") else splitDot(removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("type", "$") then qid("\"" + "type" + "\"") else splitDot(
    removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "type" + "\"") else splitDot(removeChar(removeChar(
    "type", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("type", "_", "~"), "\n", " "))
*********** trial #190
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #190
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("type", "_", "~")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + "~" + substr(
    "type", s notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + "~" + substr("type", s
    notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
--->
"type"
*********** trial #191
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #191
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("type", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + " " + substr(
    "type", s notFound, sd(notFound, length("type"))), "\n", " ") else "type"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + " " + substr("type", s
    notFound, sd(notFound, length("type"))), "\n", " ") else "type" fi
--->
"type"
*********** trial #192
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("type", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "type"
N?:FindResult --> notFound
*********** success #192
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> notFound
splitDot("type")
--->
if notFound :: Nat and (startsWith("type", "f") or startsWith("type", "i"))
    then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
--->
qid("type")
*********** equation
(built-in equation for symbol qid)
qid("type")
--->
'type
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$type2
QL:QidList --> '`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('$type2 '`) 'br '0 'call '$factorial 'end '`) '`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$type2), "\"") then '$type2 else if startsWith(string(
    '$type2), "$") then qid("\"" + string('$type2) + "\"") else splitDot(
    removeChar(removeChar(string('$type2), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$type2)
--->
"$type2"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type2", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$type2 else if startsWith("$type2", "$") then qid("\"" +
    "$type2" + "\"") else splitDot(removeChar(removeChar("$type2", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$type2", "$") then qid("\"" + "$type2" + "\"") else splitDot(
    removeChar(removeChar("$type2", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type2", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$type2" + "\"") else splitDot(removeChar(removeChar(
    "$type2", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$type2" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$type2"
--->
"\"$type2"
*********** equation
(built-in equation for symbol _+_)
"\"$type2" + "\""
--->
"\"$type2\""
*********** equation
(built-in equation for symbol qid)
qid("\"$type2\"")
--->
'"$type2"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) 'br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`(
    'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('br '0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #193
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #193
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #194
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #194
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #195
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #195
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'br
QL:QidList --> '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('br '0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('br), "\"") then 'br else if startsWith(string('br), "$")
    then qid("\"" + string('br) + "\"") else splitDot(removeChar(removeChar(
    string('br), "_", "~"), "\n", " ")) fi fi tokenize-wasm('0 'call
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('br)
--->
"br"
*********** equation
(built-in equation for symbol startsWith)
startsWith("br", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'br else if startsWith("br", "$") then qid("\"" + "br" + "\"")
    else splitDot(removeChar(removeChar("br", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("br", "$") then qid("\"" + "br" + "\"") else splitDot(removeChar(
    removeChar("br", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("br", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "br" + "\"") else splitDot(removeChar(removeChar("br",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("br", "_", "~"), "\n", " "))
*********** trial #196
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "br"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("br", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "br"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #196
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "br"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("br", "_", "~")
--->
if notFound :: Nat then removeChar(substr("br", 0, notFound) + "~" + substr(
    "br", s notFound, sd(notFound, length("br"))), "_", "~") else "br" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("br", 0, notFound) + "~" + substr("br", s
    notFound, sd(notFound, length("br"))), "_", "~") else "br" fi
--->
"br"
*********** trial #197
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "br"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("br", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "br"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #197
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "br"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("br", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("br", 0, notFound) + " " + substr(
    "br", s notFound, sd(notFound, length("br"))), "\n", " ") else "br" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("br", 0, notFound) + " " + substr("br", s
    notFound, sd(notFound, length("br"))), "\n", " ") else "br" fi
--->
"br"
*********** trial #198
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "br"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("br", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "br"
N?:FindResult --> notFound
*********** success #198
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "br"
N?:FindResult --> notFound
splitDot("br")
--->
if notFound :: Nat and (startsWith("br", "f") or startsWith("br", "i")) then
    qid(substr("br", 0, notFound)) if substr("br", notFound, sd(notFound,
    length("br"))) =/= ".const" then qid(substr("br", notFound, 1)) if (
    startsWith(substr("br", notFound, sd(notFound, length("br"))), ".demote")
    or startsWith(substr("br", notFound, sd(notFound, length("br"))),
    ".promote")) or startsWith(substr("br", notFound, sd(notFound, length(
    "br"))), ".wrap") then splitConversion(substr("br", s notFound, sd(
    notFound, length("br")))) else qid(substr("br", s notFound, sd(notFound,
    length("br")))) fi else qid(substr("br", notFound, sd(notFound, length(
    "br")))) fi else qid("br") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("br", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("br", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("br", 0, notFound)) if substr("br", notFound, sd(
    notFound, length("br"))) =/= ".const" then qid(substr("br", notFound, 1))
    if (startsWith(substr("br", notFound, sd(notFound, length("br"))),
    ".demote") or startsWith(substr("br", notFound, sd(notFound, length(
    "br"))), ".promote")) or startsWith(substr("br", notFound, sd(notFound,
    length("br"))), ".wrap") then splitConversion(substr("br", s notFound, sd(
    notFound, length("br")))) else qid(substr("br", s notFound, sd(notFound,
    length("br")))) fi else qid(substr("br", notFound, sd(notFound, length(
    "br")))) fi else qid("br") fi
--->
qid("br")
*********** equation
(built-in equation for symbol qid)
qid("br")
--->
'br
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('0 'call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('call '$factorial
    'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #199
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #199
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #200
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #200
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #201
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #201
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'call
QL:QidList --> '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('call '$factorial 'end '`) '`( 'func '$factorial '`( 'type
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('call), "\"") then 'call else if startsWith(string('call),
    "$") then qid("\"" + string('call) + "\"") else splitDot(removeChar(
    removeChar(string('call), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('call)
--->
"call"
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'call else if startsWith("call", "$") then qid("\"" + "call" +
    "\"") else splitDot(removeChar(removeChar("call", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("call", "$") then qid("\"" + "call" + "\"") else splitDot(
    removeChar(removeChar("call", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "call" + "\"") else splitDot(removeChar(removeChar(
    "call", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("call", "_", "~"), "\n", " "))
*********** trial #202
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("call", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #202
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("call", "_", "~")
--->
if notFound :: Nat then removeChar(substr("call", 0, notFound) + "~" + substr(
    "call", s notFound, sd(notFound, length("call"))), "_", "~") else "call" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("call", 0, notFound) + "~" + substr("call", s
    notFound, sd(notFound, length("call"))), "_", "~") else "call" fi
--->
"call"
*********** trial #203
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("call", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #203
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("call", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("call", 0, notFound) + " " + substr(
    "call", s notFound, sd(notFound, length("call"))), "\n", " ") else "call"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("call", 0, notFound) + " " + substr("call", s
    notFound, sd(notFound, length("call"))), "\n", " ") else "call" fi
--->
"call"
*********** trial #204
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "call"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("call", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "call"
N?:FindResult --> notFound
*********** success #204
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "call"
N?:FindResult --> notFound
splitDot("call")
--->
if notFound :: Nat and (startsWith("call", "f") or startsWith("call", "i"))
    then qid(substr("call", 0, notFound)) if substr("call", notFound, sd(
    notFound, length("call"))) =/= ".const" then qid(substr("call", notFound,
    1)) if (startsWith(substr("call", notFound, sd(notFound, length("call"))),
    ".demote") or startsWith(substr("call", notFound, sd(notFound, length(
    "call"))), ".promote")) or startsWith(substr("call", notFound, sd(notFound,
    length("call"))), ".wrap") then splitConversion(substr("call", s notFound,
    sd(notFound, length("call")))) else qid(substr("call", s notFound, sd(
    notFound, length("call")))) fi else qid(substr("call", notFound, sd(
    notFound, length("call")))) fi else qid("call") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("call", 0, notFound)) if substr("call", notFound, sd(
    notFound, length("call"))) =/= ".const" then qid(substr("call", notFound,
    1)) if (startsWith(substr("call", notFound, sd(notFound, length("call"))),
    ".demote") or startsWith(substr("call", notFound, sd(notFound, length(
    "call"))), ".promote")) or startsWith(substr("call", notFound, sd(notFound,
    length("call"))), ".wrap") then splitConversion(substr("call", s notFound,
    sd(notFound, length("call")))) else qid(substr("call", s notFound, sd(
    notFound, length("call")))) fi else qid(substr("call", notFound, sd(
    notFound, length("call")))) fi else qid("call") fi
--->
qid("call")
*********** equation
(built-in equation for symbol qid)
qid("call")
--->
'call
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$factorial
QL:QidList --> 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$factorial 'end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$factorial), "\"") then '$factorial else if startsWith(
    string('$factorial), "$") then qid("\"" + string('$factorial) + "\"") else
    splitDot(removeChar(removeChar(string('$factorial), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('end '`) '`( 'func '$factorial '`( 'type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$factorial)
--->
"$factorial"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$factorial else if startsWith("$factorial", "$") then qid("\"" +
    "$factorial" + "\"") else splitDot(removeChar(removeChar("$factorial", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("$factorial", "$") then qid("\"" + "$factorial" + "\"") else
    splitDot(removeChar(removeChar("$factorial", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$factorial" + "\"") else splitDot(removeChar(
    removeChar("$factorial", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$factorial" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$factorial"
--->
"\"$factorial"
*********** equation
(built-in equation for symbol _+_)
"\"$factorial" + "\""
--->
"\"$factorial\""
*********** equation
(built-in equation for symbol qid)
qid("\"$factorial\"")
--->
'"$factorial"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'end
QL:QidList --> '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('end '`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const
    '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('end), "\"") then 'end else if startsWith(string('end),
    "$") then qid("\"" + string('end) + "\"") else splitDot(removeChar(
    removeChar(string('end), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq
    'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('end)
--->
"end"
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'end else if startsWith("end", "$") then qid("\"" + "end" + "\"")
    else splitDot(removeChar(removeChar("end", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("end", "$") then qid("\"" + "end" + "\"") else splitDot(
    removeChar(removeChar("end", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "end" + "\"") else splitDot(removeChar(removeChar(
    "end", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("end", "_", "~"), "\n", " "))
*********** trial #205
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("end", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #205
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("end", "_", "~")
--->
if notFound :: Nat then removeChar(substr("end", 0, notFound) + "~" + substr(
    "end", s notFound, sd(notFound, length("end"))), "_", "~") else "end" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("end", 0, notFound) + "~" + substr("end", s
    notFound, sd(notFound, length("end"))), "_", "~") else "end" fi
--->
"end"
*********** trial #206
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("end", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #206
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("end", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("end", 0, notFound) + " " + substr(
    "end", s notFound, sd(notFound, length("end"))), "\n", " ") else "end" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("end", 0, notFound) + " " + substr("end", s
    notFound, sd(notFound, length("end"))), "\n", " ") else "end" fi
--->
"end"
*********** trial #207
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "end"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("end", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "end"
N?:FindResult --> notFound
*********** success #207
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "end"
N?:FindResult --> notFound
splitDot("end")
--->
if notFound :: Nat and (startsWith("end", "f") or startsWith("end", "i")) then
    qid(substr("end", 0, notFound)) if substr("end", notFound, sd(notFound,
    length("end"))) =/= ".const" then qid(substr("end", notFound, 1)) if (
    startsWith(substr("end", notFound, sd(notFound, length("end"))), ".demote")
    or startsWith(substr("end", notFound, sd(notFound, length("end"))),
    ".promote")) or startsWith(substr("end", notFound, sd(notFound, length(
    "end"))), ".wrap") then splitConversion(substr("end", s notFound, sd(
    notFound, length("end")))) else qid(substr("end", s notFound, sd(notFound,
    length("end")))) fi else qid(substr("end", notFound, sd(notFound, length(
    "end")))) fi else qid("end") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("end", 0, notFound)) if substr("end", notFound, sd(
    notFound, length("end"))) =/= ".const" then qid(substr("end", notFound, 1))
    if (startsWith(substr("end", notFound, sd(notFound, length("end"))),
    ".demote") or startsWith(substr("end", notFound, sd(notFound, length(
    "end"))), ".promote")) or startsWith(substr("end", notFound, sd(notFound,
    length("end"))), ".wrap") then splitConversion(substr("end", s notFound,
    sd(notFound, length("end")))) else qid(substr("end", s notFound, sd(
    notFound, length("end")))) fi else qid(substr("end", notFound, sd(notFound,
    length("end")))) fi else qid("end") fi
--->
qid("end")
*********** equation
(built-in equation for symbol qid)
qid("end")
--->
'end
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'func
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #208
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #208
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #209
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #209
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #210
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #210
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get
    '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'func '$factorial '`( 'type '$type1 '`) 'i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('func '$factorial
    '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #211
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #211
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #212
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #212
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #213
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #213
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'func
QL:QidList --> '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('func '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get
    '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('func), "\"") then 'func else if startsWith(string('func),
    "$") then qid("\"" + string('func) + "\"") else splitDot(removeChar(
    removeChar(string('func), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('func)
--->
"func"
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'func else if startsWith("func", "$") then qid("\"" + "func" +
    "\"") else splitDot(removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("func", "$") then qid("\"" + "func" + "\"") else splitDot(
    removeChar(removeChar("func", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "func" + "\"") else splitDot(removeChar(removeChar(
    "func", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("func", "_", "~"), "\n", " "))
*********** trial #214
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #214
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("func", "_", "~")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + "~" + substr(
    "func", s notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + "~" + substr("func", s
    notFound, sd(notFound, length("func"))), "_", "~") else "func" fi
--->
"func"
*********** trial #215
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("func", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #215
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "func"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("func", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("func", 0, notFound) + " " + substr(
    "func", s notFound, sd(notFound, length("func"))), "\n", " ") else "func"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("func", 0, notFound) + " " + substr("func", s
    notFound, sd(notFound, length("func"))), "\n", " ") else "func" fi
--->
"func"
*********** trial #216
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("func", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "func"
N?:FindResult --> notFound
*********** success #216
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "func"
N?:FindResult --> notFound
splitDot("func")
--->
if notFound :: Nat and (startsWith("func", "f") or startsWith("func", "i"))
    then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "f")
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("func", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("func", 0, notFound)) if substr("func", notFound, sd(
    notFound, length("func"))) =/= ".const" then qid(substr("func", notFound,
    1)) if (startsWith(substr("func", notFound, sd(notFound, length("func"))),
    ".demote") or startsWith(substr("func", notFound, sd(notFound, length(
    "func"))), ".promote")) or startsWith(substr("func", notFound, sd(notFound,
    length("func"))), ".wrap") then splitConversion(substr("func", s notFound,
    sd(notFound, length("func")))) else qid(substr("func", s notFound, sd(
    notFound, length("func")))) fi else qid(substr("func", notFound, sd(
    notFound, length("func")))) fi else qid("func") fi
--->
qid("func")
*********** equation
(built-in equation for symbol qid)
qid("func")
--->
'func
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$factorial
QL:QidList --> '`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if
    '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$factorial '`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$factorial), "\"") then '$factorial else if startsWith(
    string('$factorial), "$") then qid("\"" + string('$factorial) + "\"") else
    splitDot(removeChar(removeChar(string('$factorial), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('`( 'type '$type1 '`) 'i64.const '0 'local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$factorial)
--->
"$factorial"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$factorial else if startsWith("$factorial", "$") then qid("\"" +
    "$factorial" + "\"") else splitDot(removeChar(removeChar("$factorial", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("$factorial", "$") then qid("\"" + "$factorial" + "\"") else
    splitDot(removeChar(removeChar("$factorial", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$factorial" + "\"") else splitDot(removeChar(
    removeChar("$factorial", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$factorial" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$factorial"
--->
"\"$factorial"
*********** equation
(built-in equation for symbol _+_)
"\"$factorial" + "\""
--->
"\"$factorial\""
*********** equation
(built-in equation for symbol qid)
qid("\"$factorial\"")
--->
'"$factorial"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`(
    'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const
    '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`(
    'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const
    '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('type '$type1 '`)
    'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #217
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #217
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #218
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #218
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #219
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #219
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'type
QL:QidList --> '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('type '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`(
    'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const
    '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('type), "\"") then 'type else if startsWith(string('type),
    "$") then qid("\"" + string('type) + "\"") else splitDot(removeChar(
    removeChar(string('type), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('type)
--->
"type"
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'type else if startsWith("type", "$") then qid("\"" + "type" +
    "\"") else splitDot(removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("type", "$") then qid("\"" + "type" + "\"") else splitDot(
    removeChar(removeChar("type", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "type" + "\"") else splitDot(removeChar(removeChar(
    "type", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("type", "_", "~"), "\n", " "))
*********** trial #220
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #220
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("type", "_", "~")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + "~" + substr(
    "type", s notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + "~" + substr("type", s
    notFound, sd(notFound, length("type"))), "_", "~") else "type" fi
--->
"type"
*********** trial #221
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("type", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #221
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "type"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("type", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("type", 0, notFound) + " " + substr(
    "type", s notFound, sd(notFound, length("type"))), "\n", " ") else "type"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("type", 0, notFound) + " " + substr("type", s
    notFound, sd(notFound, length("type"))), "\n", " ") else "type" fi
--->
"type"
*********** trial #222
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("type", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "type"
N?:FindResult --> notFound
*********** success #222
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "type"
N?:FindResult --> notFound
splitDot("type")
--->
if notFound :: Nat and (startsWith("type", "f") or startsWith("type", "i"))
    then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("type", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("type", 0, notFound)) if substr("type", notFound, sd(
    notFound, length("type"))) =/= ".const" then qid(substr("type", notFound,
    1)) if (startsWith(substr("type", notFound, sd(notFound, length("type"))),
    ".demote") or startsWith(substr("type", notFound, sd(notFound, length(
    "type"))), ".promote")) or startsWith(substr("type", notFound, sd(notFound,
    length("type"))), ".wrap") then splitConversion(substr("type", s notFound,
    sd(notFound, length("type")))) else qid(substr("type", s notFound, sd(
    notFound, length("type")))) fi else qid(substr("type", notFound, sd(
    notFound, length("type")))) fi else qid("type") fi
--->
qid("type")
*********** equation
(built-in equation for symbol qid)
qid("type")
--->
'type
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$type1
QL:QidList --> '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('$type1 '`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result
    'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$type1), "\"") then '$type1 else if startsWith(string(
    '$type1), "$") then qid("\"" + string('$type1) + "\"") else splitDot(
    removeChar(removeChar(string('$type1), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$type1)
--->
"$type1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$type1 else if startsWith("$type1", "$") then qid("\"" +
    "$type1" + "\"") else splitDot(removeChar(removeChar("$type1", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$type1", "$") then qid("\"" + "$type1" + "\"") else splitDot(
    removeChar(removeChar("$type1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$type1", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$type1" + "\"") else splitDot(removeChar(removeChar(
    "$type1", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$type1" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$type1"
--->
"\"$type1"
*********** equation
(built-in equation for symbol _+_)
"\"$type1" + "\""
--->
"\"$type1\""
*********** equation
(built-in equation for symbol qid)
qid("\"$type1\"")
--->
'"$type1"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('`) 'i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '0
    'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #223
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #223
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #224
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #224
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #225
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #225
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64.const '0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #226
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #226
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #227
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #227
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #228
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #228
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('0 'local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('local.get '0
    'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #229
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #229
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #230
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #230
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #231
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #231
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'local.get
QL:QidList --> '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('local.get '0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1
    'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('local.get), "\"") then 'local.get else if startsWith(
    string('local.get), "$") then qid("\"" + string('local.get) + "\"") else
    splitDot(removeChar(removeChar(string('local.get), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('local.get)
--->
"local.get"
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'local.get else if startsWith("local.get", "$") then qid("\"" +
    "local.get" + "\"") else splitDot(removeChar(removeChar("local.get", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("local.get", "$") then qid("\"" + "local.get" + "\"") else
    splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "local.get" + "\"") else splitDot(removeChar(
    removeChar("local.get", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " "))
*********** trial #232
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #232
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("local.get", "_", "~")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + "~" +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "_",
    "~") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + "~" + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "_", "~") else
    "local.get" fi
--->
"local.get"
*********** trial #233
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #233
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("local.get", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + " " +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "\n",
    " ") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + " " + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "\n", " ")
    else "local.get" fi
--->
"local.get"
*********** trial #234
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("local.get", ".", 0)
--->
5
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "local.get"
N?:FindResult --> 5
*********** success #234
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> 5
splitDot("local.get")
--->
if 5 :: Nat and (startsWith("local.get", "f") or startsWith("local.get", "i"))
    then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5, length(
    "local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
*********** equation
(built-in equation for symbol _::`Nat)
5 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5,
    length("local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
--->
qid("local.get")
*********** equation
(built-in equation for symbol qid)
qid("local.get")
--->
'local.get
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get
    '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('0 'i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.eq 'if '`(
    'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const
    '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #235
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #235
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #236
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #236
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #237
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #237
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.eq
QL:QidList --> 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64.eq 'if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get
    '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.eq), "\"") then 'i64.eq else if startsWith(string(
    'i64.eq), "$") then qid("\"" + string('i64.eq) + "\"") else splitDot(
    removeChar(removeChar(string('i64.eq), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.eq)
--->
"i64.eq"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.eq", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.eq else if startsWith("i64.eq", "$") then qid("\"" +
    "i64.eq" + "\"") else splitDot(removeChar(removeChar("i64.eq", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("i64.eq", "$") then qid("\"" + "i64.eq" + "\"") else splitDot(
    removeChar(removeChar("i64.eq", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.eq", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.eq" + "\"") else splitDot(removeChar(removeChar(
    "i64.eq", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.eq", "_", "~"), "\n", " "))
*********** trial #238
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.eq"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.eq", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.eq"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #238
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.eq"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.eq", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.eq", 0, notFound) + "~" +
    substr("i64.eq", s notFound, sd(notFound, length("i64.eq"))), "_", "~")
    else "i64.eq" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.eq", 0, notFound) + "~" + substr("i64.eq",
    s notFound, sd(notFound, length("i64.eq"))), "_", "~") else "i64.eq" fi
--->
"i64.eq"
*********** trial #239
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.eq"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.eq", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.eq"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #239
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.eq"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.eq", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.eq", 0, notFound) + " " +
    substr("i64.eq", s notFound, sd(notFound, length("i64.eq"))), "\n", " ")
    else "i64.eq" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.eq", 0, notFound) + " " + substr("i64.eq",
    s notFound, sd(notFound, length("i64.eq"))), "\n", " ") else "i64.eq" fi
--->
"i64.eq"
*********** trial #240
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.eq"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.eq", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.eq"
N?:FindResult --> 3
*********** success #240
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.eq"
N?:FindResult --> 3
splitDot("i64.eq")
--->
if 3 :: Nat and (startsWith("i64.eq", "f") or startsWith("i64.eq", "i")) then
    qid(substr("i64.eq", 0, 3)) if substr("i64.eq", 3, sd(3, length("i64.eq")))
    =/= ".const" then qid(substr("i64.eq", 3, 1)) if (startsWith(substr(
    "i64.eq", 3, sd(3, length("i64.eq"))), ".demote") or startsWith(substr(
    "i64.eq", 3, sd(3, length("i64.eq"))), ".promote")) or startsWith(substr(
    "i64.eq", 3, sd(3, length("i64.eq"))), ".wrap") then splitConversion(
    substr("i64.eq", s 3, sd(3, length("i64.eq")))) else qid(substr("i64.eq", s
    3, sd(3, length("i64.eq")))) fi else qid(substr("i64.eq", 3, sd(3, length(
    "i64.eq")))) fi else qid("i64.eq") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.eq", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.eq", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.eq", 0, 3)) if substr("i64.eq", 3, sd(3, length(
    "i64.eq"))) =/= ".const" then qid(substr("i64.eq", 3, 1)) if (startsWith(
    substr("i64.eq", 3, sd(3, length("i64.eq"))), ".demote") or startsWith(
    substr("i64.eq", 3, sd(3, length("i64.eq"))), ".promote")) or startsWith(
    substr("i64.eq", 3, sd(3, length("i64.eq"))), ".wrap") then
    splitConversion(substr("i64.eq", s 3, sd(3, length("i64.eq")))) else qid(
    substr("i64.eq", s 3, sd(3, length("i64.eq")))) fi else qid(substr(
    "i64.eq", 3, sd(3, length("i64.eq")))) fi else qid("i64.eq") fi
--->
qid(substr("i64.eq", 0, 3)) if substr("i64.eq", 3, sd(3, length("i64.eq"))) =/=
    ".const" then qid(substr("i64.eq", 3, 1)) if (startsWith(substr("i64.eq",
    3, sd(3, length("i64.eq"))), ".demote") or startsWith(substr("i64.eq", 3,
    sd(3, length("i64.eq"))), ".promote")) or startsWith(substr("i64.eq", 3,
    sd(3, length("i64.eq"))), ".wrap") then splitConversion(substr("i64.eq", s
    3, sd(3, length("i64.eq")))) else qid(substr("i64.eq", s 3, sd(3, length(
    "i64.eq")))) fi else qid(substr("i64.eq", 3, sd(3, length("i64.eq")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.eq", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.eq")
--->
6
*********** equation
(built-in equation for symbol sd)
sd(3, 6)
--->
3
*********** equation
(built-in equation for symbol substr)
substr("i64.eq", 3, 3)
--->
".eq"
*********** equation
(built-in equation for symbol _=/=_)
".eq" =/= ".const"
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.eq", 3, 1)) if (startsWith(".eq", ".demote") or
    startsWith(".eq", ".promote")) or startsWith(".eq", ".wrap") then
    splitConversion(substr("i64.eq", s 3, 3)) else qid(substr("i64.eq", s 3,
    3)) fi else qid(".eq") fi
--->
qid(substr("i64.eq", 3, 1)) if (startsWith(".eq", ".demote") or startsWith(
    ".eq", ".promote")) or startsWith(".eq", ".wrap") then splitConversion(
    substr("i64.eq", s 3, 3)) else qid(substr("i64.eq", s 3, 3)) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.eq", 3, 1)
--->
"."
*********** equation
(built-in equation for symbol qid)
qid(".")
--->
'.
*********** equation
(built-in equation for symbol startsWith)
startsWith(".eq", ".demote")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".eq", ".promote")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".eq", ".wrap")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then splitConversion(substr("i64.eq", s 3, 3)) else qid(substr(
    "i64.eq", s 3, 3)) fi
--->
qid(substr("i64.eq", s 3, 3))
*********** equation
(built-in equation for symbol substr)
substr("i64.eq", 4, 3)
--->
"eq"
*********** equation
(built-in equation for symbol qid)
qid("eq")
--->
'eq
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'if
QL:QidList --> '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('if '`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('if), "\"") then 'if else if startsWith(string('if), "$")
    then qid("\"" + string('if) + "\"") else splitDot(removeChar(removeChar(
    string('if), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'result 'i64
    '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('if)
--->
"if"
*********** equation
(built-in equation for symbol startsWith)
startsWith("if", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'if else if startsWith("if", "$") then qid("\"" + "if" + "\"")
    else splitDot(removeChar(removeChar("if", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("if", "$") then qid("\"" + "if" + "\"") else splitDot(removeChar(
    removeChar("if", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("if", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "if" + "\"") else splitDot(removeChar(removeChar("if",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("if", "_", "~"), "\n", " "))
*********** trial #241
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "if"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("if", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "if"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #241
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "if"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("if", "_", "~")
--->
if notFound :: Nat then removeChar(substr("if", 0, notFound) + "~" + substr(
    "if", s notFound, sd(notFound, length("if"))), "_", "~") else "if" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("if", 0, notFound) + "~" + substr("if", s
    notFound, sd(notFound, length("if"))), "_", "~") else "if" fi
--->
"if"
*********** trial #242
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "if"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("if", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "if"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #242
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "if"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("if", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("if", 0, notFound) + " " + substr(
    "if", s notFound, sd(notFound, length("if"))), "\n", " ") else "if" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("if", 0, notFound) + " " + substr("if", s
    notFound, sd(notFound, length("if"))), "\n", " ") else "if" fi
--->
"if"
*********** trial #243
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "if"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("if", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "if"
N?:FindResult --> notFound
*********** success #243
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "if"
N?:FindResult --> notFound
splitDot("if")
--->
if notFound :: Nat and (startsWith("if", "f") or startsWith("if", "i")) then
    qid(substr("if", 0, notFound)) if substr("if", notFound, sd(notFound,
    length("if"))) =/= ".const" then qid(substr("if", notFound, 1)) if (
    startsWith(substr("if", notFound, sd(notFound, length("if"))), ".demote")
    or startsWith(substr("if", notFound, sd(notFound, length("if"))),
    ".promote")) or startsWith(substr("if", notFound, sd(notFound, length(
    "if"))), ".wrap") then splitConversion(substr("if", s notFound, sd(
    notFound, length("if")))) else qid(substr("if", s notFound, sd(notFound,
    length("if")))) fi else qid(substr("if", notFound, sd(notFound, length(
    "if")))) fi else qid("if") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("if", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("if", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("if", 0, notFound)) if substr("if", notFound, sd(
    notFound, length("if"))) =/= ".const" then qid(substr("if", notFound, 1))
    if (startsWith(substr("if", notFound, sd(notFound, length("if"))),
    ".demote") or startsWith(substr("if", notFound, sd(notFound, length(
    "if"))), ".promote")) or startsWith(substr("if", notFound, sd(notFound,
    length("if"))), ".wrap") then splitConversion(substr("if", s notFound, sd(
    notFound, length("if")))) else qid(substr("if", s notFound, sd(notFound,
    length("if")))) fi else qid(substr("if", notFound, sd(notFound, length(
    "if")))) fi else qid("if") fi
--->
qid("if")
*********** equation
(built-in equation for symbol qid)
qid("if")
--->
'if
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get
    '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('result 'i64 '`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #244
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #244
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #245
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #245
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #246
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #246
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'result
QL:QidList --> 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('result 'i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('result), "\"") then 'result else if startsWith(string(
    'result), "$") then qid("\"" + string('result) + "\"") else splitDot(
    removeChar(removeChar(string('result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('result)
--->
"result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'result else if startsWith("result", "$") then qid("\"" +
    "result" + "\"") else splitDot(removeChar(removeChar("result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("result", "$") then qid("\"" + "result" + "\"") else splitDot(
    removeChar(removeChar("result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "result" + "\"") else splitDot(removeChar(removeChar(
    "result", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("result", "_", "~"), "\n", " "))
*********** trial #247
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #247
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("result", "_", "~")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + "~" +
    substr("result", s notFound, sd(notFound, length("result"))), "_", "~")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + "~" + substr("result",
    s notFound, sd(notFound, length("result"))), "_", "~") else "result" fi
--->
"result"
*********** trial #248
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("result", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #248
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "result"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("result", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("result", 0, notFound) + " " +
    substr("result", s notFound, sd(notFound, length("result"))), "\n", " ")
    else "result" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("result", 0, notFound) + " " + substr("result",
    s notFound, sd(notFound, length("result"))), "\n", " ") else "result" fi
--->
"result"
*********** trial #249
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("result", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "result"
N?:FindResult --> notFound
*********** success #249
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "result"
N?:FindResult --> notFound
splitDot("result")
--->
if notFound :: Nat and (startsWith("result", "f") or startsWith("result", "i"))
    then qid(substr("result", 0, notFound)) if substr("result", notFound, sd(
    notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("result", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("result", 0, notFound)) if substr("result", notFound,
    sd(notFound, length("result"))) =/= ".const" then qid(substr("result",
    notFound, 1)) if (startsWith(substr("result", notFound, sd(notFound,
    length("result"))), ".demote") or startsWith(substr("result", notFound, sd(
    notFound, length("result"))), ".promote")) or startsWith(substr("result",
    notFound, sd(notFound, length("result"))), ".wrap") then splitConversion(
    substr("result", s notFound, sd(notFound, length("result")))) else qid(
    substr("result", s notFound, sd(notFound, length("result")))) fi else qid(
    substr("result", notFound, sd(notFound, length("result")))) fi else qid(
    "result") fi
--->
qid("result")
*********** equation
(built-in equation for symbol qid)
qid("result")
--->
'result
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const
    '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) 'i64.const '1 'else 'local.get '0 'local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`)
    'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #250
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #250
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #251
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #251
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #252
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #252
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) 'i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '1 'else
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #253
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #253
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #254
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #254
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #255
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #255
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub
    'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('i64.const '1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('1 'else 'local.get '0 'local.get '0 'i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #256
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #256
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #257
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #257
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #258
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #258
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '1
QL:QidList --> 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('1 'else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('1), "\"") then '1 else if startsWith(string('1), "$")
    then qid("\"" + string('1) + "\"") else splitDot(removeChar(removeChar(
    string('1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('else 'local.get '0
    'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('1)
--->
"1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '1 else if startsWith("1", "$") then qid("\"" + "1" + "\"") else
    splitDot(removeChar(removeChar("1", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("1", "$") then qid("\"" + "1" + "\"") else splitDot(removeChar(
    removeChar("1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "1" + "\"") else splitDot(removeChar(removeChar("1",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("1", "_", "~"), "\n", " "))
*********** trial #259
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #259
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("1", "_", "~")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + "~" + substr("1",
    s notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + "~" + substr("1", s
    notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
--->
"1"
*********** trial #260
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #260
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("1", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + " " + substr("1",
    s notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + " " + substr("1", s
    notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
--->
"1"
*********** trial #261
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("1", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "1"
N?:FindResult --> notFound
*********** success #261
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> notFound
splitDot("1")
--->
if notFound :: Nat and (startsWith("1", "f") or startsWith("1", "i")) then qid(
    substr("1", 0, notFound)) if substr("1", notFound, sd(notFound, length(
    "1"))) =/= ".const" then qid(substr("1", notFound, 1)) if (startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".demote") or startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".promote")) or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap") then
    splitConversion(substr("1", s notFound, sd(notFound, length("1")))) else
    qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(substr(
    "1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("1", 0, notFound)) if substr("1", notFound, sd(
    notFound, length("1"))) =/= ".const" then qid(substr("1", notFound, 1)) if
    (startsWith(substr("1", notFound, sd(notFound, length("1"))), ".demote") or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".promote"))
    or startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap")
    then splitConversion(substr("1", s notFound, sd(notFound, length("1"))))
    else qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(
    substr("1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
--->
qid("1")
*********** equation
(built-in equation for symbol qid)
qid("1")
--->
'1
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'else
QL:QidList --> 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('else 'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('else), "\"") then 'else else if startsWith(string('else),
    "$") then qid("\"" + string('else) + "\"") else splitDot(removeChar(
    removeChar(string('else), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    'local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('else)
--->
"else"
*********** equation
(built-in equation for symbol startsWith)
startsWith("else", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'else else if startsWith("else", "$") then qid("\"" + "else" +
    "\"") else splitDot(removeChar(removeChar("else", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("else", "$") then qid("\"" + "else" + "\"") else splitDot(
    removeChar(removeChar("else", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("else", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "else" + "\"") else splitDot(removeChar(removeChar(
    "else", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("else", "_", "~"), "\n", " "))
*********** trial #262
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "else"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("else", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "else"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #262
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "else"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("else", "_", "~")
--->
if notFound :: Nat then removeChar(substr("else", 0, notFound) + "~" + substr(
    "else", s notFound, sd(notFound, length("else"))), "_", "~") else "else" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("else", 0, notFound) + "~" + substr("else", s
    notFound, sd(notFound, length("else"))), "_", "~") else "else" fi
--->
"else"
*********** trial #263
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "else"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("else", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "else"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #263
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "else"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("else", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("else", 0, notFound) + " " + substr(
    "else", s notFound, sd(notFound, length("else"))), "\n", " ") else "else"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("else", 0, notFound) + " " + substr("else", s
    notFound, sd(notFound, length("else"))), "\n", " ") else "else" fi
--->
"else"
*********** trial #264
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "else"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("else", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "else"
N?:FindResult --> notFound
*********** success #264
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "else"
N?:FindResult --> notFound
splitDot("else")
--->
if notFound :: Nat and (startsWith("else", "f") or startsWith("else", "i"))
    then qid(substr("else", 0, notFound)) if substr("else", notFound, sd(
    notFound, length("else"))) =/= ".const" then qid(substr("else", notFound,
    1)) if (startsWith(substr("else", notFound, sd(notFound, length("else"))),
    ".demote") or startsWith(substr("else", notFound, sd(notFound, length(
    "else"))), ".promote")) or startsWith(substr("else", notFound, sd(notFound,
    length("else"))), ".wrap") then splitConversion(substr("else", s notFound,
    sd(notFound, length("else")))) else qid(substr("else", s notFound, sd(
    notFound, length("else")))) fi else qid(substr("else", notFound, sd(
    notFound, length("else")))) fi else qid("else") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("else", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("else", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("else", 0, notFound)) if substr("else", notFound, sd(
    notFound, length("else"))) =/= ".const" then qid(substr("else", notFound,
    1)) if (startsWith(substr("else", notFound, sd(notFound, length("else"))),
    ".demote") or startsWith(substr("else", notFound, sd(notFound, length(
    "else"))), ".promote")) or startsWith(substr("else", notFound, sd(notFound,
    length("else"))), ".wrap") then splitConversion(substr("else", s notFound,
    sd(notFound, length("else")))) else qid(substr("else", s notFound, sd(
    notFound, length("else")))) fi else qid(substr("else", notFound, sd(
    notFound, length("else")))) fi else qid("else") fi
--->
qid("else")
*********** equation
(built-in equation for symbol qid)
qid("else")
--->
'else
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'local.get
QL:QidList --> '0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('local.get '0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('local.get), "\"") then 'local.get else if startsWith(
    string('local.get), "$") then qid("\"" + string('local.get) + "\"") else
    splitDot(removeChar(removeChar(string('local.get), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('0 'local.get '0 'i64.const '1 'i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('local.get)
--->
"local.get"
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'local.get else if startsWith("local.get", "$") then qid("\"" +
    "local.get" + "\"") else splitDot(removeChar(removeChar("local.get", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("local.get", "$") then qid("\"" + "local.get" + "\"") else
    splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "local.get" + "\"") else splitDot(removeChar(
    removeChar("local.get", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " "))
*********** trial #265
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #265
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("local.get", "_", "~")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + "~" +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "_",
    "~") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + "~" + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "_", "~") else
    "local.get" fi
--->
"local.get"
*********** trial #266
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #266
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("local.get", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + " " +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "\n",
    " ") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + " " + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "\n", " ")
    else "local.get" fi
--->
"local.get"
*********** trial #267
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("local.get", ".", 0)
--->
5
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "local.get"
N?:FindResult --> 5
*********** success #267
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> 5
splitDot("local.get")
--->
if 5 :: Nat and (startsWith("local.get", "f") or startsWith("local.get", "i"))
    then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5, length(
    "local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
*********** equation
(built-in equation for symbol _::`Nat)
5 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5,
    length("local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
--->
qid("local.get")
*********** equation
(built-in equation for symbol qid)
qid("local.get")
--->
'local.get
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul
    'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('0 'local.get '0 'i64.const '1 'i64.sub 'call '$factorial
    'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('local.get '0
    'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #268
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #268
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #269
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #269
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #270
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #270
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'local.get
QL:QidList --> '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`)
    '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('local.get '0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul
    'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('local.get), "\"") then 'local.get else if startsWith(
    string('local.get), "$") then qid("\"" + string('local.get) + "\"") else
    splitDot(removeChar(removeChar(string('local.get), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul
    'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('local.get)
--->
"local.get"
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'local.get else if startsWith("local.get", "$") then qid("\"" +
    "local.get" + "\"") else splitDot(removeChar(removeChar("local.get", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("local.get", "$") then qid("\"" + "local.get" + "\"") else
    splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "local.get" + "\"") else splitDot(removeChar(
    removeChar("local.get", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("local.get", "_", "~"), "\n", " "))
*********** trial #271
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #271
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("local.get", "_", "~")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + "~" +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "_",
    "~") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + "~" + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "_", "~") else
    "local.get" fi
--->
"local.get"
*********** trial #272
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("local.get", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #272
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "local.get"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("local.get", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("local.get", 0, notFound) + " " +
    substr("local.get", s notFound, sd(notFound, length("local.get"))), "\n",
    " ") else "local.get" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("local.get", 0, notFound) + " " + substr(
    "local.get", s notFound, sd(notFound, length("local.get"))), "\n", " ")
    else "local.get" fi
--->
"local.get"
*********** trial #273
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("local.get", ".", 0)
--->
5
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "local.get"
N?:FindResult --> 5
*********** success #273
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "local.get"
N?:FindResult --> 5
splitDot("local.get")
--->
if 5 :: Nat and (startsWith("local.get", "f") or startsWith("local.get", "i"))
    then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5, length(
    "local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
*********** equation
(built-in equation for symbol _::`Nat)
5 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("local.get", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("local.get", 0, 5)) if substr("local.get", 5, sd(5,
    length("local.get"))) =/= ".const" then qid(substr("local.get", 5, 1)) if (
    startsWith(substr("local.get", 5, sd(5, length("local.get"))), ".demote")
    or startsWith(substr("local.get", 5, sd(5, length("local.get"))),
    ".promote")) or startsWith(substr("local.get", 5, sd(5, length(
    "local.get"))), ".wrap") then splitConversion(substr("local.get", s 5, sd(
    5, length("local.get")))) else qid(substr("local.get", s 5, sd(5, length(
    "local.get")))) fi else qid(substr("local.get", 5, sd(5, length(
    "local.get")))) fi else qid("local.get") fi
--->
qid("local.get")
*********** equation
(built-in equation for symbol qid)
qid("local.get")
--->
'local.get
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '0
QL:QidList --> 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`(
    'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('0 'i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`(
    'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('0), "\"") then '0 else if startsWith(string('0), "$")
    then qid("\"" + string('0) + "\"") else splitDot(removeChar(removeChar(
    string('0), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '1
    'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('0)
--->
"0"
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '0 else if startsWith("0", "$") then qid("\"" + "0" + "\"") else
    splitDot(removeChar(removeChar("0", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("0", "$") then qid("\"" + "0" + "\"") else splitDot(removeChar(
    removeChar("0", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "0" + "\"") else splitDot(removeChar(removeChar("0",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("0", "_", "~"), "\n", " "))
*********** trial #274
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #274
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("0", "_", "~")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + "~" + substr("0",
    s notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + "~" + substr("0", s
    notFound, sd(notFound, length("0"))), "_", "~") else "0" fi
--->
"0"
*********** trial #275
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("0", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #275
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "0"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("0", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("0", 0, notFound) + " " + substr("0",
    s notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("0", 0, notFound) + " " + substr("0", s
    notFound, sd(notFound, length("0"))), "\n", " ") else "0" fi
--->
"0"
*********** trial #276
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("0", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "0"
N?:FindResult --> notFound
*********** success #276
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "0"
N?:FindResult --> notFound
splitDot("0")
--->
if notFound :: Nat and (startsWith("0", "f") or startsWith("0", "i")) then qid(
    substr("0", 0, notFound)) if substr("0", notFound, sd(notFound, length(
    "0"))) =/= ".const" then qid(substr("0", notFound, 1)) if (startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".demote") or startsWith(
    substr("0", notFound, sd(notFound, length("0"))), ".promote")) or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap") then
    splitConversion(substr("0", s notFound, sd(notFound, length("0")))) else
    qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(substr(
    "0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("0", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("0", 0, notFound)) if substr("0", notFound, sd(
    notFound, length("0"))) =/= ".const" then qid(substr("0", notFound, 1)) if
    (startsWith(substr("0", notFound, sd(notFound, length("0"))), ".demote") or
    startsWith(substr("0", notFound, sd(notFound, length("0"))), ".promote"))
    or startsWith(substr("0", notFound, sd(notFound, length("0"))), ".wrap")
    then splitConversion(substr("0", s notFound, sd(notFound, length("0"))))
    else qid(substr("0", s notFound, sd(notFound, length("0")))) fi else qid(
    substr("0", notFound, sd(notFound, length("0")))) fi else qid("0") fi
--->
qid("0")
*********** equation
(built-in equation for symbol qid)
qid("0")
--->
'0
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global
    '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64.const '1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`(
    'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`(
    'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #277
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #277
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #278
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #278
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #279
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #279
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '1
QL:QidList --> 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('1 'i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('1), "\"") then '1 else if startsWith(string('1), "$")
    then qid("\"" + string('1) + "\"") else splitDot(removeChar(removeChar(
    string('1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.sub 'call
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('1)
--->
"1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '1 else if startsWith("1", "$") then qid("\"" + "1" + "\"") else
    splitDot(removeChar(removeChar("1", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("1", "$") then qid("\"" + "1" + "\"") else splitDot(removeChar(
    removeChar("1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "1" + "\"") else splitDot(removeChar(removeChar("1",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("1", "_", "~"), "\n", " "))
*********** trial #280
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #280
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("1", "_", "~")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + "~" + substr("1",
    s notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + "~" + substr("1", s
    notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
--->
"1"
*********** trial #281
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #281
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("1", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + " " + substr("1",
    s notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + " " + substr("1", s
    notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
--->
"1"
*********** trial #282
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("1", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "1"
N?:FindResult --> notFound
*********** success #282
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> notFound
splitDot("1")
--->
if notFound :: Nat and (startsWith("1", "f") or startsWith("1", "i")) then qid(
    substr("1", 0, notFound)) if substr("1", notFound, sd(notFound, length(
    "1"))) =/= ".const" then qid(substr("1", notFound, 1)) if (startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".demote") or startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".promote")) or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap") then
    splitConversion(substr("1", s notFound, sd(notFound, length("1")))) else
    qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(substr(
    "1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("1", 0, notFound)) if substr("1", notFound, sd(
    notFound, length("1"))) =/= ".const" then qid(substr("1", notFound, 1)) if
    (startsWith(substr("1", notFound, sd(notFound, length("1"))), ".demote") or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".promote"))
    or startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap")
    then splitConversion(substr("1", s notFound, sd(notFound, length("1"))))
    else qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(
    substr("1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
--->
qid("1")
*********** equation
(built-in equation for symbol qid)
qid("1")
--->
'1
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.sub
QL:QidList --> 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64.sub 'call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.sub), "\"") then 'i64.sub else if startsWith(string(
    'i64.sub), "$") then qid("\"" + string('i64.sub) + "\"") else splitDot(
    removeChar(removeChar(string('i64.sub), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.sub)
--->
"i64.sub"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.sub", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.sub else if startsWith("i64.sub", "$") then qid("\"" +
    "i64.sub" + "\"") else splitDot(removeChar(removeChar("i64.sub", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("i64.sub", "$") then qid("\"" + "i64.sub" + "\"") else splitDot(
    removeChar(removeChar("i64.sub", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.sub", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.sub" + "\"") else splitDot(removeChar(removeChar(
    "i64.sub", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.sub", "_", "~"), "\n", " "))
*********** trial #283
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.sub"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.sub", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.sub"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #283
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.sub"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.sub", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.sub", 0, notFound) + "~" +
    substr("i64.sub", s notFound, sd(notFound, length("i64.sub"))), "_", "~")
    else "i64.sub" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.sub", 0, notFound) + "~" + substr(
    "i64.sub", s notFound, sd(notFound, length("i64.sub"))), "_", "~") else
    "i64.sub" fi
--->
"i64.sub"
*********** trial #284
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.sub"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.sub", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.sub"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #284
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.sub"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.sub", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.sub", 0, notFound) + " " +
    substr("i64.sub", s notFound, sd(notFound, length("i64.sub"))), "\n", " ")
    else "i64.sub" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.sub", 0, notFound) + " " + substr(
    "i64.sub", s notFound, sd(notFound, length("i64.sub"))), "\n", " ") else
    "i64.sub" fi
--->
"i64.sub"
*********** trial #285
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.sub"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.sub", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.sub"
N?:FindResult --> 3
*********** success #285
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.sub"
N?:FindResult --> 3
splitDot("i64.sub")
--->
if 3 :: Nat and (startsWith("i64.sub", "f") or startsWith("i64.sub", "i")) then
    qid(substr("i64.sub", 0, 3)) if substr("i64.sub", 3, sd(3, length(
    "i64.sub"))) =/= ".const" then qid(substr("i64.sub", 3, 1)) if (startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".demote") or startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".promote")) or startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".wrap") then
    splitConversion(substr("i64.sub", s 3, sd(3, length("i64.sub")))) else qid(
    substr("i64.sub", s 3, sd(3, length("i64.sub")))) fi else qid(substr(
    "i64.sub", 3, sd(3, length("i64.sub")))) fi else qid("i64.sub") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.sub", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.sub", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.sub", 0, 3)) if substr("i64.sub", 3, sd(3, length(
    "i64.sub"))) =/= ".const" then qid(substr("i64.sub", 3, 1)) if (startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".demote") or startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".promote")) or startsWith(
    substr("i64.sub", 3, sd(3, length("i64.sub"))), ".wrap") then
    splitConversion(substr("i64.sub", s 3, sd(3, length("i64.sub")))) else qid(
    substr("i64.sub", s 3, sd(3, length("i64.sub")))) fi else qid(substr(
    "i64.sub", 3, sd(3, length("i64.sub")))) fi else qid("i64.sub") fi
--->
qid(substr("i64.sub", 0, 3)) if substr("i64.sub", 3, sd(3, length("i64.sub")))
    =/= ".const" then qid(substr("i64.sub", 3, 1)) if (startsWith(substr(
    "i64.sub", 3, sd(3, length("i64.sub"))), ".demote") or startsWith(substr(
    "i64.sub", 3, sd(3, length("i64.sub"))), ".promote")) or startsWith(substr(
    "i64.sub", 3, sd(3, length("i64.sub"))), ".wrap") then splitConversion(
    substr("i64.sub", s 3, sd(3, length("i64.sub")))) else qid(substr(
    "i64.sub", s 3, sd(3, length("i64.sub")))) fi else qid(substr("i64.sub", 3,
    sd(3, length("i64.sub")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.sub", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.sub")
--->
7
*********** equation
(built-in equation for symbol sd)
sd(3, 7)
--->
4
*********** equation
(built-in equation for symbol substr)
substr("i64.sub", 3, 4)
--->
".sub"
*********** equation
(built-in equation for symbol _=/=_)
".sub" =/= ".const"
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.sub", 3, 1)) if (startsWith(".sub", ".demote") or
    startsWith(".sub", ".promote")) or startsWith(".sub", ".wrap") then
    splitConversion(substr("i64.sub", s 3, 4)) else qid(substr("i64.sub", s 3,
    4)) fi else qid(".sub") fi
--->
qid(substr("i64.sub", 3, 1)) if (startsWith(".sub", ".demote") or startsWith(
    ".sub", ".promote")) or startsWith(".sub", ".wrap") then splitConversion(
    substr("i64.sub", s 3, 4)) else qid(substr("i64.sub", s 3, 4)) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.sub", 3, 1)
--->
"."
*********** equation
(built-in equation for symbol qid)
qid(".")
--->
'.
*********** equation
(built-in equation for symbol startsWith)
startsWith(".sub", ".demote")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".sub", ".promote")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".sub", ".wrap")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then splitConversion(substr("i64.sub", s 3, 4)) else qid(substr(
    "i64.sub", s 3, 4)) fi
--->
qid(substr("i64.sub", s 3, 4))
*********** equation
(built-in equation for symbol substr)
substr("i64.sub", 4, 4)
--->
"sub"
*********** equation
(built-in equation for symbol qid)
qid("sub")
--->
'sub
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'call
QL:QidList --> '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`)
tokenize-wasm('call '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('call), "\"") then 'call else if startsWith(string('call),
    "$") then qid("\"" + string('call) + "\"") else splitDot(removeChar(
    removeChar(string('call), "_", "~"), "\n", " ")) fi fi tokenize-wasm(
    '$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('call)
--->
"call"
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'call else if startsWith("call", "$") then qid("\"" + "call" +
    "\"") else splitDot(removeChar(removeChar("call", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("call", "$") then qid("\"" + "call" + "\"") else splitDot(
    removeChar(removeChar("call", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "call" + "\"") else splitDot(removeChar(removeChar(
    "call", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("call", "_", "~"), "\n", " "))
*********** trial #286
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("call", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #286
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("call", "_", "~")
--->
if notFound :: Nat then removeChar(substr("call", 0, notFound) + "~" + substr(
    "call", s notFound, sd(notFound, length("call"))), "_", "~") else "call" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("call", 0, notFound) + "~" + substr("call", s
    notFound, sd(notFound, length("call"))), "_", "~") else "call" fi
--->
"call"
*********** trial #287
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("call", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #287
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "call"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("call", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("call", 0, notFound) + " " + substr(
    "call", s notFound, sd(notFound, length("call"))), "\n", " ") else "call"
    fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("call", 0, notFound) + " " + substr("call", s
    notFound, sd(notFound, length("call"))), "\n", " ") else "call" fi
--->
"call"
*********** trial #288
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "call"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("call", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "call"
N?:FindResult --> notFound
*********** success #288
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "call"
N?:FindResult --> notFound
splitDot("call")
--->
if notFound :: Nat and (startsWith("call", "f") or startsWith("call", "i"))
    then qid(substr("call", 0, notFound)) if substr("call", notFound, sd(
    notFound, length("call"))) =/= ".const" then qid(substr("call", notFound,
    1)) if (startsWith(substr("call", notFound, sd(notFound, length("call"))),
    ".demote") or startsWith(substr("call", notFound, sd(notFound, length(
    "call"))), ".promote")) or startsWith(substr("call", notFound, sd(notFound,
    length("call"))), ".wrap") then splitConversion(substr("call", s notFound,
    sd(notFound, length("call")))) else qid(substr("call", s notFound, sd(
    notFound, length("call")))) fi else qid(substr("call", notFound, sd(
    notFound, length("call")))) fi else qid("call") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("call", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("call", 0, notFound)) if substr("call", notFound, sd(
    notFound, length("call"))) =/= ".const" then qid(substr("call", notFound,
    1)) if (startsWith(substr("call", notFound, sd(notFound, length("call"))),
    ".demote") or startsWith(substr("call", notFound, sd(notFound, length(
    "call"))), ".promote")) or startsWith(substr("call", notFound, sd(notFound,
    length("call"))), ".wrap") then splitConversion(substr("call", s notFound,
    sd(notFound, length("call")))) else qid(substr("call", s notFound, sd(
    notFound, length("call")))) fi else qid(substr("call", notFound, sd(
    notFound, length("call")))) fi else qid("call") fi
--->
qid("call")
*********** equation
(built-in equation for symbol qid)
qid("call")
--->
'call
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$factorial
QL:QidList --> 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('$factorial 'i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$factorial), "\"") then '$factorial else if startsWith(
    string('$factorial), "$") then qid("\"" + string('$factorial) + "\"") else
    splitDot(removeChar(removeChar(string('$factorial), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$factorial)
--->
"$factorial"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$factorial else if startsWith("$factorial", "$") then qid("\"" +
    "$factorial" + "\"") else splitDot(removeChar(removeChar("$factorial", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("$factorial", "$") then qid("\"" + "$factorial" + "\"") else
    splitDot(removeChar(removeChar("$factorial", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$factorial", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$factorial" + "\"") else splitDot(removeChar(
    removeChar("$factorial", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$factorial" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$factorial"
--->
"\"$factorial"
*********** equation
(built-in equation for symbol _+_)
"\"$factorial" + "\""
--->
"\"$factorial\""
*********** equation
(built-in equation for symbol qid)
qid("\"$factorial\"")
--->
'"$factorial"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.mul
QL:QidList --> 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1
    '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`)
tokenize-wasm('i64.mul 'end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('i64.mul), "\"") then 'i64.mul else if startsWith(string(
    'i64.mul), "$") then qid("\"" + string('i64.mul) + "\"") else splitDot(
    removeChar(removeChar(string('i64.mul), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`))
*********** equation
(built-in equation for symbol string)
string('i64.mul)
--->
"i64.mul"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.mul", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.mul else if startsWith("i64.mul", "$") then qid("\"" +
    "i64.mul" + "\"") else splitDot(removeChar(removeChar("i64.mul", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("i64.mul", "$") then qid("\"" + "i64.mul" + "\"") else splitDot(
    removeChar(removeChar("i64.mul", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.mul", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.mul" + "\"") else splitDot(removeChar(removeChar(
    "i64.mul", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.mul", "_", "~"), "\n", " "))
*********** trial #289
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.mul"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.mul", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.mul"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #289
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.mul"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.mul", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.mul", 0, notFound) + "~" +
    substr("i64.mul", s notFound, sd(notFound, length("i64.mul"))), "_", "~")
    else "i64.mul" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.mul", 0, notFound) + "~" + substr(
    "i64.mul", s notFound, sd(notFound, length("i64.mul"))), "_", "~") else
    "i64.mul" fi
--->
"i64.mul"
*********** trial #290
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.mul"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.mul", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.mul"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #290
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.mul"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.mul", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.mul", 0, notFound) + " " +
    substr("i64.mul", s notFound, sd(notFound, length("i64.mul"))), "\n", " ")
    else "i64.mul" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.mul", 0, notFound) + " " + substr(
    "i64.mul", s notFound, sd(notFound, length("i64.mul"))), "\n", " ") else
    "i64.mul" fi
--->
"i64.mul"
*********** trial #291
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.mul"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.mul", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.mul"
N?:FindResult --> 3
*********** success #291
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.mul"
N?:FindResult --> 3
splitDot("i64.mul")
--->
if 3 :: Nat and (startsWith("i64.mul", "f") or startsWith("i64.mul", "i")) then
    qid(substr("i64.mul", 0, 3)) if substr("i64.mul", 3, sd(3, length(
    "i64.mul"))) =/= ".const" then qid(substr("i64.mul", 3, 1)) if (startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".demote") or startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".promote")) or startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".wrap") then
    splitConversion(substr("i64.mul", s 3, sd(3, length("i64.mul")))) else qid(
    substr("i64.mul", s 3, sd(3, length("i64.mul")))) fi else qid(substr(
    "i64.mul", 3, sd(3, length("i64.mul")))) fi else qid("i64.mul") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.mul", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.mul", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.mul", 0, 3)) if substr("i64.mul", 3, sd(3, length(
    "i64.mul"))) =/= ".const" then qid(substr("i64.mul", 3, 1)) if (startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".demote") or startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".promote")) or startsWith(
    substr("i64.mul", 3, sd(3, length("i64.mul"))), ".wrap") then
    splitConversion(substr("i64.mul", s 3, sd(3, length("i64.mul")))) else qid(
    substr("i64.mul", s 3, sd(3, length("i64.mul")))) fi else qid(substr(
    "i64.mul", 3, sd(3, length("i64.mul")))) fi else qid("i64.mul") fi
--->
qid(substr("i64.mul", 0, 3)) if substr("i64.mul", 3, sd(3, length("i64.mul")))
    =/= ".const" then qid(substr("i64.mul", 3, 1)) if (startsWith(substr(
    "i64.mul", 3, sd(3, length("i64.mul"))), ".demote") or startsWith(substr(
    "i64.mul", 3, sd(3, length("i64.mul"))), ".promote")) or startsWith(substr(
    "i64.mul", 3, sd(3, length("i64.mul"))), ".wrap") then splitConversion(
    substr("i64.mul", s 3, sd(3, length("i64.mul")))) else qid(substr(
    "i64.mul", s 3, sd(3, length("i64.mul")))) fi else qid(substr("i64.mul", 3,
    sd(3, length("i64.mul")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.mul", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.mul")
--->
7
*********** equation
(built-in equation for symbol sd)
sd(3, 7)
--->
4
*********** equation
(built-in equation for symbol substr)
substr("i64.mul", 3, 4)
--->
".mul"
*********** equation
(built-in equation for symbol _=/=_)
".mul" =/= ".const"
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.mul", 3, 1)) if (startsWith(".mul", ".demote") or
    startsWith(".mul", ".promote")) or startsWith(".mul", ".wrap") then
    splitConversion(substr("i64.mul", s 3, 4)) else qid(substr("i64.mul", s 3,
    4)) fi else qid(".mul") fi
--->
qid(substr("i64.mul", 3, 1)) if (startsWith(".mul", ".demote") or startsWith(
    ".mul", ".promote")) or startsWith(".mul", ".wrap") then splitConversion(
    substr("i64.mul", s 3, 4)) else qid(substr("i64.mul", s 3, 4)) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.mul", 3, 1)
--->
"."
*********** equation
(built-in equation for symbol qid)
qid(".")
--->
'.
*********** equation
(built-in equation for symbol startsWith)
startsWith(".mul", ".demote")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".mul", ".promote")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith(".mul", ".wrap")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then splitConversion(substr("i64.mul", s 3, 4)) else qid(substr(
    "i64.mul", s 3, 4)) fi
--->
qid(substr("i64.mul", s 3, 4))
*********** equation
(built-in equation for symbol substr)
substr("i64.mul", 4, 4)
--->
"mul"
*********** equation
(built-in equation for symbol qid)
qid("mul")
--->
'mul
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'end
QL:QidList --> '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('end '`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1
    '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`))
--->
if startsWith(string('end), "\"") then 'end else if startsWith(string('end),
    "$") then qid("\"" + string('end) + "\"") else splitDot(removeChar(
    removeChar(string('end), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('end)
--->
"end"
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'end else if startsWith("end", "$") then qid("\"" + "end" + "\"")
    else splitDot(removeChar(removeChar("end", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("end", "$") then qid("\"" + "end" + "\"") else splitDot(
    removeChar(removeChar("end", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "end" + "\"") else splitDot(removeChar(removeChar(
    "end", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("end", "_", "~"), "\n", " "))
*********** trial #292
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("end", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #292
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("end", "_", "~")
--->
if notFound :: Nat then removeChar(substr("end", 0, notFound) + "~" + substr(
    "end", s notFound, sd(notFound, length("end"))), "_", "~") else "end" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("end", 0, notFound) + "~" + substr("end", s
    notFound, sd(notFound, length("end"))), "_", "~") else "end" fi
--->
"end"
*********** trial #293
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("end", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #293
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "end"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("end", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("end", 0, notFound) + " " + substr(
    "end", s notFound, sd(notFound, length("end"))), "\n", " ") else "end" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("end", 0, notFound) + " " + substr("end", s
    notFound, sd(notFound, length("end"))), "\n", " ") else "end" fi
--->
"end"
*********** trial #294
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "end"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("end", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "end"
N?:FindResult --> notFound
*********** success #294
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "end"
N?:FindResult --> notFound
splitDot("end")
--->
if notFound :: Nat and (startsWith("end", "f") or startsWith("end", "i")) then
    qid(substr("end", 0, notFound)) if substr("end", notFound, sd(notFound,
    length("end"))) =/= ".const" then qid(substr("end", notFound, 1)) if (
    startsWith(substr("end", notFound, sd(notFound, length("end"))), ".demote")
    or startsWith(substr("end", notFound, sd(notFound, length("end"))),
    ".promote")) or startsWith(substr("end", notFound, sd(notFound, length(
    "end"))), ".wrap") then splitConversion(substr("end", s notFound, sd(
    notFound, length("end")))) else qid(substr("end", s notFound, sd(notFound,
    length("end")))) fi else qid(substr("end", notFound, sd(notFound, length(
    "end")))) fi else qid("end") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("end", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("end", 0, notFound)) if substr("end", notFound, sd(
    notFound, length("end"))) =/= ".const" then qid(substr("end", notFound, 1))
    if (startsWith(substr("end", notFound, sd(notFound, length("end"))),
    ".demote") or startsWith(substr("end", notFound, sd(notFound, length(
    "end"))), ".promote")) or startsWith(substr("end", notFound, sd(notFound,
    length("end"))), ".wrap") then splitConversion(substr("end", s notFound,
    sd(notFound, length("end")))) else qid(substr("end", s notFound, sd(
    notFound, length("end")))) fi else qid(substr("end", notFound, sd(notFound,
    length("end")))) fi else qid("end") fi
--->
qid("end")
*********** equation
(built-in equation for symbol qid)
qid("end")
--->
'end
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'global '$gb1
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #295
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #295
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #296
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #296
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #297
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #297
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('global '$gb1 '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #298
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #298
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #299
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #299
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #300
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #300
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'global
QL:QidList --> '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('global '$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`(
    'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('global), "\"") then 'global else if startsWith(string(
    'global), "$") then qid("\"" + string('global) + "\"") else splitDot(
    removeChar(removeChar(string('global), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('global)
--->
"global"
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'global else if startsWith("global", "$") then qid("\"" +
    "global" + "\"") else splitDot(removeChar(removeChar("global", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("global", "$") then qid("\"" + "global" + "\"") else splitDot(
    removeChar(removeChar("global", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "global" + "\"") else splitDot(removeChar(removeChar(
    "global", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("global", "_", "~"), "\n", " "))
*********** trial #301
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #301
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("global", "_", "~")
--->
if notFound :: Nat then removeChar(substr("global", 0, notFound) + "~" +
    substr("global", s notFound, sd(notFound, length("global"))), "_", "~")
    else "global" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global", 0, notFound) + "~" + substr("global",
    s notFound, sd(notFound, length("global"))), "_", "~") else "global" fi
--->
"global"
*********** trial #302
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #302
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("global", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("global", 0, notFound) + " " +
    substr("global", s notFound, sd(notFound, length("global"))), "\n", " ")
    else "global" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global", 0, notFound) + " " + substr("global",
    s notFound, sd(notFound, length("global"))), "\n", " ") else "global" fi
--->
"global"
*********** trial #303
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("global", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "global"
N?:FindResult --> notFound
*********** success #303
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global"
N?:FindResult --> notFound
splitDot("global")
--->
if notFound :: Nat and (startsWith("global", "f") or startsWith("global", "i"))
    then qid(substr("global", 0, notFound)) if substr("global", notFound, sd(
    notFound, length("global"))) =/= ".const" then qid(substr("global",
    notFound, 1)) if (startsWith(substr("global", notFound, sd(notFound,
    length("global"))), ".demote") or startsWith(substr("global", notFound, sd(
    notFound, length("global"))), ".promote")) or startsWith(substr("global",
    notFound, sd(notFound, length("global"))), ".wrap") then splitConversion(
    substr("global", s notFound, sd(notFound, length("global")))) else qid(
    substr("global", s notFound, sd(notFound, length("global")))) fi else qid(
    substr("global", notFound, sd(notFound, length("global")))) fi else qid(
    "global") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("global", 0, notFound)) if substr("global", notFound,
    sd(notFound, length("global"))) =/= ".const" then qid(substr("global",
    notFound, 1)) if (startsWith(substr("global", notFound, sd(notFound,
    length("global"))), ".demote") or startsWith(substr("global", notFound, sd(
    notFound, length("global"))), ".promote")) or startsWith(substr("global",
    notFound, sd(notFound, length("global"))), ".wrap") then splitConversion(
    substr("global", s notFound, sd(notFound, length("global")))) else qid(
    substr("global", s notFound, sd(notFound, length("global")))) fi else qid(
    substr("global", notFound, sd(notFound, length("global")))) fi else qid(
    "global") fi
--->
qid("global")
*********** equation
(built-in equation for symbol qid)
qid("global")
--->
'global
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$gb1
QL:QidList --> '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$gb1 '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$gb1), "\"") then '$gb1 else if startsWith(string('$gb1),
    "$") then qid("\"" + string('$gb1) + "\"") else splitDot(removeChar(
    removeChar(string('$gb1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$gb1)
--->
"$gb1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$gb1 else if startsWith("$gb1", "$") then qid("\"" + "$gb1" +
    "\"") else splitDot(removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
    fi
--->
if startsWith("$gb1", "$") then qid("\"" + "$gb1" + "\"") else splitDot(
    removeChar(removeChar("$gb1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$gb1", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$gb1" + "\"") else splitDot(removeChar(removeChar(
    "$gb1", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$gb1" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$gb1"
--->
"\"$gb1"
*********** equation
(built-in equation for symbol _+_)
"\"$gb1" + "\""
--->
"\"$gb1\""
*********** equation
(built-in equation for symbol qid)
qid("\"$gb1\"")
--->
'"$gb1"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #304
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #304
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #305
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #305
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #306
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #306
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'mut
QL:QidList --> 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`(
    'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('mut), "\"") then 'mut else if startsWith(string('mut),
    "$") then qid("\"" + string('mut) + "\"") else splitDot(removeChar(
    removeChar(string('mut), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64
    '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('mut)
--->
"mut"
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'mut else if startsWith("mut", "$") then qid("\"" + "mut" + "\"")
    else splitDot(removeChar(removeChar("mut", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("mut", "$") then qid("\"" + "mut" + "\"") else splitDot(
    removeChar(removeChar("mut", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "mut" + "\"") else splitDot(removeChar(removeChar(
    "mut", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("mut", "_", "~"), "\n", " "))
*********** trial #307
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("mut", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #307
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("mut", "_", "~")
--->
if notFound :: Nat then removeChar(substr("mut", 0, notFound) + "~" + substr(
    "mut", s notFound, sd(notFound, length("mut"))), "_", "~") else "mut" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("mut", 0, notFound) + "~" + substr("mut", s
    notFound, sd(notFound, length("mut"))), "_", "~") else "mut" fi
--->
"mut"
*********** trial #308
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("mut", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #308
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("mut", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("mut", 0, notFound) + " " + substr(
    "mut", s notFound, sd(notFound, length("mut"))), "\n", " ") else "mut" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("mut", 0, notFound) + " " + substr("mut", s
    notFound, sd(notFound, length("mut"))), "\n", " ") else "mut" fi
--->
"mut"
*********** trial #309
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "mut"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("mut", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "mut"
N?:FindResult --> notFound
*********** success #309
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "mut"
N?:FindResult --> notFound
splitDot("mut")
--->
if notFound :: Nat and (startsWith("mut", "f") or startsWith("mut", "i")) then
    qid(substr("mut", 0, notFound)) if substr("mut", notFound, sd(notFound,
    length("mut"))) =/= ".const" then qid(substr("mut", notFound, 1)) if (
    startsWith(substr("mut", notFound, sd(notFound, length("mut"))), ".demote")
    or startsWith(substr("mut", notFound, sd(notFound, length("mut"))),
    ".promote")) or startsWith(substr("mut", notFound, sd(notFound, length(
    "mut"))), ".wrap") then splitConversion(substr("mut", s notFound, sd(
    notFound, length("mut")))) else qid(substr("mut", s notFound, sd(notFound,
    length("mut")))) fi else qid(substr("mut", notFound, sd(notFound, length(
    "mut")))) fi else qid("mut") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("mut", 0, notFound)) if substr("mut", notFound, sd(
    notFound, length("mut"))) =/= ".const" then qid(substr("mut", notFound, 1))
    if (startsWith(substr("mut", notFound, sd(notFound, length("mut"))),
    ".demote") or startsWith(substr("mut", notFound, sd(notFound, length(
    "mut"))), ".promote")) or startsWith(substr("mut", notFound, sd(notFound,
    length("mut"))), ".wrap") then splitConversion(substr("mut", s notFound,
    sd(notFound, length("mut")))) else qid(substr("mut", s notFound, sd(
    notFound, length("mut")))) fi else qid(substr("mut", notFound, sd(notFound,
    length("mut")))) fi else qid("mut") fi
--->
qid("mut")
*********** equation
(built-in equation for symbol qid)
qid("mut")
--->
'mut
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut
    'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #310
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #310
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #311
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #311
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #312
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #312
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64
    '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'i64.const '1
    '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #313
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #313
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #314
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #314
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #315
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #315
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`)
    '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '1 '`)
    '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #316
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #316
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #317
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #317
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #318
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #318
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`)
tokenize-wasm('i64.const '1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #319
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #319
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #320
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #320
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #321
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #321
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '1
QL:QidList --> '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1
    '`) '`) '`)
tokenize-wasm('1 '`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const
    '1 '`) '`) '`))
--->
if startsWith(string('1), "\"") then '1 else if startsWith(string('1), "$")
    then qid("\"" + string('1) + "\"") else splitDot(removeChar(removeChar(
    string('1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('1)
--->
"1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '1 else if startsWith("1", "$") then qid("\"" + "1" + "\"") else
    splitDot(removeChar(removeChar("1", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("1", "$") then qid("\"" + "1" + "\"") else splitDot(removeChar(
    removeChar("1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "1" + "\"") else splitDot(removeChar(removeChar("1",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("1", "_", "~"), "\n", " "))
*********** trial #322
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #322
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("1", "_", "~")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + "~" + substr("1",
    s notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + "~" + substr("1", s
    notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
--->
"1"
*********** trial #323
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #323
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("1", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + " " + substr("1",
    s notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + " " + substr("1", s
    notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
--->
"1"
*********** trial #324
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("1", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "1"
N?:FindResult --> notFound
*********** success #324
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> notFound
splitDot("1")
--->
if notFound :: Nat and (startsWith("1", "f") or startsWith("1", "i")) then qid(
    substr("1", 0, notFound)) if substr("1", notFound, sd(notFound, length(
    "1"))) =/= ".const" then qid(substr("1", notFound, 1)) if (startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".demote") or startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".promote")) or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap") then
    splitConversion(substr("1", s notFound, sd(notFound, length("1")))) else
    qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(substr(
    "1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("1", 0, notFound)) if substr("1", notFound, sd(
    notFound, length("1"))) =/= ".const" then qid(substr("1", notFound, 1)) if
    (startsWith(substr("1", notFound, sd(notFound, length("1"))), ".demote") or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".promote"))
    or startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap")
    then splitConversion(substr("1", s notFound, sd(notFound, length("1"))))
    else qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(
    substr("1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
--->
qid("1")
*********** equation
(built-in equation for symbol qid)
qid("1")
--->
'1
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`)
tokenize-wasm('`) '`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1
    '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #325
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #325
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #326
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #326
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #327
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #327
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`)
tokenize-wasm('`) '`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`)
    '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'global
    '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #328
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #328
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #329
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #329
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #330
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #330
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`)
    '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('global '$result
    '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #331
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #331
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #332
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #332
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #333
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #333
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'global
QL:QidList --> '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('global '$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('global), "\"") then 'global else if startsWith(string(
    'global), "$") then qid("\"" + string('global) + "\"") else splitDot(
    removeChar(removeChar(string('global), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('global)
--->
"global"
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'global else if startsWith("global", "$") then qid("\"" +
    "global" + "\"") else splitDot(removeChar(removeChar("global", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("global", "$") then qid("\"" + "global" + "\"") else splitDot(
    removeChar(removeChar("global", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "global" + "\"") else splitDot(removeChar(removeChar(
    "global", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("global", "_", "~"), "\n", " "))
*********** trial #334
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #334
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("global", "_", "~")
--->
if notFound :: Nat then removeChar(substr("global", 0, notFound) + "~" +
    substr("global", s notFound, sd(notFound, length("global"))), "_", "~")
    else "global" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global", 0, notFound) + "~" + substr("global",
    s notFound, sd(notFound, length("global"))), "_", "~") else "global" fi
--->
"global"
*********** trial #335
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("global", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #335
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "global"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("global", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("global", 0, notFound) + " " +
    substr("global", s notFound, sd(notFound, length("global"))), "\n", " ")
    else "global" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("global", 0, notFound) + " " + substr("global",
    s notFound, sd(notFound, length("global"))), "\n", " ") else "global" fi
--->
"global"
*********** trial #336
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("global", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "global"
N?:FindResult --> notFound
*********** success #336
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "global"
N?:FindResult --> notFound
splitDot("global")
--->
if notFound :: Nat and (startsWith("global", "f") or startsWith("global", "i"))
    then qid(substr("global", 0, notFound)) if substr("global", notFound, sd(
    notFound, length("global"))) =/= ".const" then qid(substr("global",
    notFound, 1)) if (startsWith(substr("global", notFound, sd(notFound,
    length("global"))), ".demote") or startsWith(substr("global", notFound, sd(
    notFound, length("global"))), ".promote")) or startsWith(substr("global",
    notFound, sd(notFound, length("global"))), ".wrap") then splitConversion(
    substr("global", s notFound, sd(notFound, length("global")))) else qid(
    substr("global", s notFound, sd(notFound, length("global")))) fi else qid(
    substr("global", notFound, sd(notFound, length("global")))) fi else qid(
    "global") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("global", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("global", 0, notFound)) if substr("global", notFound,
    sd(notFound, length("global"))) =/= ".const" then qid(substr("global",
    notFound, 1)) if (startsWith(substr("global", notFound, sd(notFound,
    length("global"))), ".demote") or startsWith(substr("global", notFound, sd(
    notFound, length("global"))), ".promote")) or startsWith(substr("global",
    notFound, sd(notFound, length("global"))), ".wrap") then splitConversion(
    substr("global", s notFound, sd(notFound, length("global")))) else qid(
    substr("global", s notFound, sd(notFound, length("global")))) fi else qid(
    substr("global", notFound, sd(notFound, length("global")))) fi else qid(
    "global") fi
--->
qid("global")
*********** equation
(built-in equation for symbol qid)
qid("global")
--->
'global
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '$result
QL:QidList --> '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('$result '`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('$result), "\"") then '$result else if startsWith(string(
    '$result), "$") then qid("\"" + string('$result) + "\"") else splitDot(
    removeChar(removeChar(string('$result), "_", "~"), "\n", " ")) fi fi
    tokenize-wasm('`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('$result)
--->
"$result"
*********** equation
(built-in equation for symbol startsWith)
startsWith("$result", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '$result else if startsWith("$result", "$") then qid("\"" +
    "$result" + "\"") else splitDot(removeChar(removeChar("$result", "_", "~"),
    "\n", " ")) fi fi
--->
if startsWith("$result", "$") then qid("\"" + "$result" + "\"") else splitDot(
    removeChar(removeChar("$result", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("$result", "$")
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid("\"" + "$result" + "\"") else splitDot(removeChar(removeChar(
    "$result", "_", "~"), "\n", " ")) fi
--->
qid("\"" + "$result" + "\"")
*********** equation
(built-in equation for symbol _+_)
"\"" + "$result"
--->
"\"$result"
*********** equation
(built-in equation for symbol _+_)
"\"$result" + "\""
--->
"\"$result\""
*********** equation
(built-in equation for symbol qid)
qid("\"$result\"")
--->
'"$result"
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('mut 'i64 '`) '`(
    'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #337
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #337
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #338
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #338
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #339
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #339
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'mut
QL:QidList --> 'i64 '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('mut 'i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('mut), "\"") then 'mut else if startsWith(string('mut),
    "$") then qid("\"" + string('mut) + "\"") else splitDot(removeChar(
    removeChar(string('mut), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64
    '`) '`( 'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('mut)
--->
"mut"
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'mut else if startsWith("mut", "$") then qid("\"" + "mut" + "\"")
    else splitDot(removeChar(removeChar("mut", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("mut", "$") then qid("\"" + "mut" + "\"") else splitDot(
    removeChar(removeChar("mut", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "mut" + "\"") else splitDot(removeChar(removeChar(
    "mut", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("mut", "_", "~"), "\n", " "))
*********** trial #340
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("mut", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #340
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("mut", "_", "~")
--->
if notFound :: Nat then removeChar(substr("mut", 0, notFound) + "~" + substr(
    "mut", s notFound, sd(notFound, length("mut"))), "_", "~") else "mut" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("mut", 0, notFound) + "~" + substr("mut", s
    notFound, sd(notFound, length("mut"))), "_", "~") else "mut" fi
--->
"mut"
*********** trial #341
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("mut", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #341
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "mut"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("mut", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("mut", 0, notFound) + " " + substr(
    "mut", s notFound, sd(notFound, length("mut"))), "\n", " ") else "mut" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("mut", 0, notFound) + " " + substr("mut", s
    notFound, sd(notFound, length("mut"))), "\n", " ") else "mut" fi
--->
"mut"
*********** trial #342
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "mut"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("mut", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "mut"
N?:FindResult --> notFound
*********** success #342
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "mut"
N?:FindResult --> notFound
splitDot("mut")
--->
if notFound :: Nat and (startsWith("mut", "f") or startsWith("mut", "i")) then
    qid(substr("mut", 0, notFound)) if substr("mut", notFound, sd(notFound,
    length("mut"))) =/= ".const" then qid(substr("mut", notFound, 1)) if (
    startsWith(substr("mut", notFound, sd(notFound, length("mut"))), ".demote")
    or startsWith(substr("mut", notFound, sd(notFound, length("mut"))),
    ".promote")) or startsWith(substr("mut", notFound, sd(notFound, length(
    "mut"))), ".wrap") then splitConversion(substr("mut", s notFound, sd(
    notFound, length("mut")))) else qid(substr("mut", s notFound, sd(notFound,
    length("mut")))) fi else qid(substr("mut", notFound, sd(notFound, length(
    "mut")))) fi else qid("mut") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("mut", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("mut", 0, notFound)) if substr("mut", notFound, sd(
    notFound, length("mut"))) =/= ".const" then qid(substr("mut", notFound, 1))
    if (startsWith(substr("mut", notFound, sd(notFound, length("mut"))),
    ".demote") or startsWith(substr("mut", notFound, sd(notFound, length(
    "mut"))), ".promote")) or startsWith(substr("mut", notFound, sd(notFound,
    length("mut"))), ".wrap") then splitConversion(substr("mut", s notFound,
    sd(notFound, length("mut")))) else qid(substr("mut", s notFound, sd(
    notFound, length("mut")))) fi else qid(substr("mut", notFound, sd(notFound,
    length("mut")))) fi else qid("mut") fi
--->
qid("mut")
*********** equation
(built-in equation for symbol qid)
qid("mut")
--->
'mut
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64
QL:QidList --> '`) '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('i64 '`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64), "\"") then 'i64 else if startsWith(string('i64),
    "$") then qid("\"" + string('i64) + "\"") else splitDot(removeChar(
    removeChar(string('i64), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`(
    'i64.const '1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64)
--->
"i64"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64 else if startsWith("i64", "$") then qid("\"" + "i64" + "\"")
    else splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("i64", "$") then qid("\"" + "i64" + "\"") else splitDot(
    removeChar(removeChar("i64", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64" + "\"") else splitDot(removeChar(removeChar(
    "i64", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64", "_", "~"), "\n", " "))
*********** trial #343
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #343
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + "~" + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + "~" + substr("i64", s
    notFound, sd(notFound, length("i64"))), "_", "~") else "i64" fi
--->
"i64"
*********** trial #344
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #344
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64", 0, notFound) + " " + substr(
    "i64", s notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64", 0, notFound) + " " + substr("i64", s
    notFound, sd(notFound, length("i64"))), "\n", " ") else "i64" fi
--->
"i64"
*********** trial #345
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64"
N?:FindResult --> notFound
*********** success #345
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64"
N?:FindResult --> notFound
splitDot("i64")
--->
if notFound :: Nat and (startsWith("i64", "f") or startsWith("i64", "i")) then
    qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(notFound,
    length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1)) if (
    startsWith(substr("i64", notFound, sd(notFound, length("i64"))), ".demote")
    or startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".promote")) or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".wrap") then splitConversion(substr("i64", s notFound, sd(
    notFound, length("i64")))) else qid(substr("i64", s notFound, sd(notFound,
    length("i64")))) fi else qid(substr("i64", notFound, sd(notFound, length(
    "i64")))) fi else qid("i64") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64", 0, notFound)) if substr("i64", notFound, sd(
    notFound, length("i64"))) =/= ".const" then qid(substr("i64", notFound, 1))
    if (startsWith(substr("i64", notFound, sd(notFound, length("i64"))),
    ".demote") or startsWith(substr("i64", notFound, sd(notFound, length(
    "i64"))), ".promote")) or startsWith(substr("i64", notFound, sd(notFound,
    length("i64"))), ".wrap") then splitConversion(substr("i64", s notFound,
    sd(notFound, length("i64")))) else qid(substr("i64", s notFound, sd(
    notFound, length("i64")))) fi else qid(substr("i64", notFound, sd(notFound,
    length("i64")))) fi else qid("i64") fi
--->
qid("i64")
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`( 'i64.const '1 '`) '`) '`)
tokenize-wasm('`) '`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`( 'i64.const '1
    '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #346
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #346
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #347
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #347
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #348
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #348
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`(
QL:QidList --> 'i64.const '1 '`) '`) '`)
tokenize-wasm('`( 'i64.const '1 '`) '`) '`))
--->
if startsWith(string('`(), "\"") then '`( else if startsWith(string('`(), "$")
    then qid("\"" + string('`() + "\"") else splitDot(removeChar(removeChar(
    string('`(), "_", "~"), "\n", " ")) fi fi tokenize-wasm('i64.const '1 '`)
    '`) '`))
*********** equation
(built-in equation for symbol string)
string('`()
--->
"`("
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`( else if startsWith("`(", "$") then qid("\"" + "`(" + "\"")
    else splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`(", "$") then qid("\"" + "`(" + "\"") else splitDot(removeChar(
    removeChar("`(", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`(" + "\"") else splitDot(removeChar(removeChar("`(",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`(", "_", "~"), "\n", " "))
*********** trial #349
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #349
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`(", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + "~" + substr(
    "`(", s notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + "~" + substr("`(", s
    notFound, sd(notFound, length("`("))), "_", "~") else "`(" fi
--->
"`("
*********** trial #350
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`(", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #350
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`("
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`(", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`(", 0, notFound) + " " + substr(
    "`(", s notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`(", 0, notFound) + " " + substr("`(", s
    notFound, sd(notFound, length("`("))), "\n", " ") else "`(" fi
--->
"`("
*********** trial #351
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`(", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`("
N?:FindResult --> notFound
*********** success #351
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`("
N?:FindResult --> notFound
splitDot("`(")
--->
if notFound :: Nat and (startsWith("`(", "f") or startsWith("`(", "i")) then
    qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(notFound,
    length("`("))) =/= ".const" then qid(substr("`(", notFound, 1)) if (
    startsWith(substr("`(", notFound, sd(notFound, length("`("))), ".demote")
    or startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".promote")) or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`(", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`(", 0, notFound)) if substr("`(", notFound, sd(
    notFound, length("`("))) =/= ".const" then qid(substr("`(", notFound, 1))
    if (startsWith(substr("`(", notFound, sd(notFound, length("`("))),
    ".demote") or startsWith(substr("`(", notFound, sd(notFound, length(
    "`("))), ".promote")) or startsWith(substr("`(", notFound, sd(notFound,
    length("`("))), ".wrap") then splitConversion(substr("`(", s notFound, sd(
    notFound, length("`(")))) else qid(substr("`(", s notFound, sd(notFound,
    length("`(")))) fi else qid(substr("`(", notFound, sd(notFound, length(
    "`(")))) fi else qid("`(") fi
--->
qid("`(")
*********** equation
(built-in equation for symbol qid)
qid("`(")
--->
'`(
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> 'i64.const
QL:QidList --> '1 '`) '`) '`)
tokenize-wasm('i64.const '1 '`) '`) '`))
--->
if startsWith(string('i64.const), "\"") then 'i64.const else if startsWith(
    string('i64.const), "$") then qid("\"" + string('i64.const) + "\"") else
    splitDot(removeChar(removeChar(string('i64.const), "_", "~"), "\n", " "))
    fi fi tokenize-wasm('1 '`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('i64.const)
--->
"i64.const"
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then 'i64.const else if startsWith("i64.const", "$") then qid("\"" +
    "i64.const" + "\"") else splitDot(removeChar(removeChar("i64.const", "_",
    "~"), "\n", " ")) fi fi
--->
if startsWith("i64.const", "$") then qid("\"" + "i64.const" + "\"") else
    splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "i64.const" + "\"") else splitDot(removeChar(
    removeChar("i64.const", "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("i64.const", "_", "~"), "\n", " "))
*********** trial #352
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #352
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("i64.const", "_", "~")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + "~" +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "_",
    "~") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + "~" + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "_", "~") else
    "i64.const" fi
--->
"i64.const"
*********** trial #353
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #353
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "i64.const"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("i64.const", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("i64.const", 0, notFound) + " " +
    substr("i64.const", s notFound, sd(notFound, length("i64.const"))), "\n",
    " ") else "i64.const" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("i64.const", 0, notFound) + " " + substr(
    "i64.const", s notFound, sd(notFound, length("i64.const"))), "\n", " ")
    else "i64.const" fi
--->
"i64.const"
*********** trial #354
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("i64.const", ".", 0)
--->
3
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "i64.const"
N?:FindResult --> 3
*********** success #354
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "i64.const"
N?:FindResult --> 3
splitDot("i64.const")
--->
if 3 :: Nat and (startsWith("i64.const", "f") or startsWith("i64.const", "i"))
    then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
*********** equation
(built-in equation for symbol _::`Nat)
3 :: Nat
--->
true
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("i64.const", "i")
--->
true
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> true
true or false
--->
false and true xor false xor true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> false
true and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> true
true xor false
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3,
    length("i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi else qid("i64.const") fi
--->
qid(substr("i64.const", 0, 3)) if substr("i64.const", 3, sd(3, length(
    "i64.const"))) =/= ".const" then qid(substr("i64.const", 3, 1)) if (
    startsWith(substr("i64.const", 3, sd(3, length("i64.const"))), ".demote")
    or startsWith(substr("i64.const", 3, sd(3, length("i64.const"))),
    ".promote")) or startsWith(substr("i64.const", 3, sd(3, length(
    "i64.const"))), ".wrap") then splitConversion(substr("i64.const", s 3, sd(
    3, length("i64.const")))) else qid(substr("i64.const", s 3, sd(3, length(
    "i64.const")))) fi else qid(substr("i64.const", 3, sd(3, length(
    "i64.const")))) fi
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 0, 3)
--->
"i64"
*********** equation
(built-in equation for symbol qid)
qid("i64")
--->
'i64
*********** equation
(built-in equation for symbol length)
length("i64.const")
--->
9
*********** equation
(built-in equation for symbol sd)
sd(3, 9)
--->
6
*********** equation
(built-in equation for symbol substr)
substr("i64.const", 3, 6)
--->
".const"
*********** equation
(built-in equation for symbol _=/=_)
".const" =/= ".const"
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("i64.const", 3, 1)) if (startsWith(".const",
    ".demote") or startsWith(".const", ".promote")) or startsWith(".const",
    ".wrap") then splitConversion(substr("i64.const", s 3, 6)) else qid(substr(
    "i64.const", s 3, 6)) fi else qid(".const") fi
--->
qid(".const")
*********** equation
(built-in equation for symbol qid)
qid(".const")
--->
'.const
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '1
QL:QidList --> '`) '`) '`)
tokenize-wasm('1 '`) '`) '`))
--->
if startsWith(string('1), "\"") then '1 else if startsWith(string('1), "$")
    then qid("\"" + string('1) + "\"") else splitDot(removeChar(removeChar(
    string('1), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`) '`))
*********** equation
(built-in equation for symbol string)
string('1)
--->
"1"
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '1 else if startsWith("1", "$") then qid("\"" + "1" + "\"") else
    splitDot(removeChar(removeChar("1", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("1", "$") then qid("\"" + "1" + "\"") else splitDot(removeChar(
    removeChar("1", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "1" + "\"") else splitDot(removeChar(removeChar("1",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("1", "_", "~"), "\n", " "))
*********** trial #355
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #355
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("1", "_", "~")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + "~" + substr("1",
    s notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + "~" + substr("1", s
    notFound, sd(notFound, length("1"))), "_", "~") else "1" fi
--->
"1"
*********** trial #356
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("1", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #356
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "1"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("1", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("1", 0, notFound) + " " + substr("1",
    s notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("1", 0, notFound) + " " + substr("1", s
    notFound, sd(notFound, length("1"))), "\n", " ") else "1" fi
--->
"1"
*********** trial #357
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("1", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "1"
N?:FindResult --> notFound
*********** success #357
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "1"
N?:FindResult --> notFound
splitDot("1")
--->
if notFound :: Nat and (startsWith("1", "f") or startsWith("1", "i")) then qid(
    substr("1", 0, notFound)) if substr("1", notFound, sd(notFound, length(
    "1"))) =/= ".const" then qid(substr("1", notFound, 1)) if (startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".demote") or startsWith(
    substr("1", notFound, sd(notFound, length("1"))), ".promote")) or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap") then
    splitConversion(substr("1", s notFound, sd(notFound, length("1")))) else
    qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(substr(
    "1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("1", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("1", 0, notFound)) if substr("1", notFound, sd(
    notFound, length("1"))) =/= ".const" then qid(substr("1", notFound, 1)) if
    (startsWith(substr("1", notFound, sd(notFound, length("1"))), ".demote") or
    startsWith(substr("1", notFound, sd(notFound, length("1"))), ".promote"))
    or startsWith(substr("1", notFound, sd(notFound, length("1"))), ".wrap")
    then splitConversion(substr("1", s notFound, sd(notFound, length("1"))))
    else qid(substr("1", s notFound, sd(notFound, length("1")))) fi else qid(
    substr("1", notFound, sd(notFound, length("1")))) fi else qid("1") fi
--->
qid("1")
*********** equation
(built-in equation for symbol qid)
qid("1")
--->
'1
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`) '`)
tokenize-wasm('`) '`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`) '`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #358
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #358
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #359
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #359
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #360
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #360
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> '`)
tokenize-wasm('`) '`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm('`))
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #361
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #361
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #362
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #362
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #363
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #363
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm(Q:Qid QL:QidList) = if startsWith(string(Q:Qid), "\"") then
    Q:Qid else if startsWith(string(Q:Qid), "$") then qid("\"" + string(Q:Qid)
    + "\"") else splitDot(removeChar(removeChar(string(Q:Qid), "_", "~"), "\n",
    " ")) fi fi tokenize-wasm(QL:QidList) .
Q:Qid --> '`)
QL:QidList --> (nil).TypeList
tokenize-wasm('`))
--->
if startsWith(string('`)), "\"") then '`) else if startsWith(string('`)), "$")
    then qid("\"" + string('`)) + "\"") else splitDot(removeChar(removeChar(
    string('`)), "_", "~"), "\n", " ")) fi fi tokenize-wasm((nil).TypeList)
*********** equation
(built-in equation for symbol string)
string('`))
--->
"`)"
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "\"")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then '`) else if startsWith("`)", "$") then qid("\"" + "`)" + "\"")
    else splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " ")) fi fi
--->
if startsWith("`)", "$") then qid("\"" + "`)" + "\"") else splitDot(removeChar(
    removeChar("`)", "_", "~"), "\n", " ")) fi
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "$")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid("\"" + "`)" + "\"") else splitDot(removeChar(removeChar("`)",
    "_", "~"), "\n", " ")) fi
--->
splitDot(removeChar(removeChar("`)", "_", "~"), "\n", " "))
*********** trial #364
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "_", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
*********** success #364
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "_"
C2:String --> "~"
N?:FindResult --> notFound
removeChar("`)", "_", "~")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + "~" + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + "~" + substr("`)", s
    notFound, sd(notFound, length("`)"))), "_", "~") else "`)" fi
--->
"`)"
*********** trial #365
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, C:String, 0)
*********** equation
(built-in equation for symbol find)
find("`)", "\n", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, C:String, 0)
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
*********** success #365
*********** equation
ceq removeChar(S:String, C:String, C2:String) = if N?:FindResult :: Nat then
    removeChar(substr(S:String, 0, N?:FindResult) + C2:String + substr(
    S:String, s N?:FindResult, sd(N?:FindResult, length(S:String))), C:String,
    C2:String) else S:String fi if N?:FindResult := find(S:String, C:String, 0)
    .
S:String --> "`)"
C:String --> "\n"
C2:String --> " "
N?:FindResult --> notFound
removeChar("`)", "\n", " ")
--->
if notFound :: Nat then removeChar(substr("`)", 0, notFound) + " " + substr(
    "`)", s notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then removeChar(substr("`)", 0, notFound) + " " + substr("`)", s
    notFound, sd(notFound, length("`)"))), "\n", " ") else "`)" fi
--->
"`)"
*********** trial #366
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> (unbound)
*********** solving condition fragment
N?:FindResult := find(S:String, ".", 0)
*********** equation
(built-in equation for symbol find)
find("`)", ".", 0)
--->
notFound
*********** success for condition fragment
N?:FindResult := find(S:String, ".", 0)
S:String --> "`)"
N?:FindResult --> notFound
*********** success #366
*********** equation
ceq splitDot(S:String) = if N?:FindResult :: Nat and (startsWith(S:String, "f")
    or startsWith(S:String, "i")) then qid(substr(S:String, 0, N?:FindResult))
    if substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))) =/=
    ".const" then qid(substr(S:String, N?:FindResult, 1)) if (startsWith(
    substr(S:String, N?:FindResult, sd(N?:FindResult, length(S:String))),
    ".demote") or startsWith(substr(S:String, N?:FindResult, sd(N?:FindResult,
    length(S:String))), ".promote")) or startsWith(substr(S:String,
    N?:FindResult, sd(N?:FindResult, length(S:String))), ".wrap") then
    splitConversion(substr(S:String, s N?:FindResult, sd(N?:FindResult, length(
    S:String)))) else qid(substr(S:String, s N?:FindResult, sd(N?:FindResult,
    length(S:String)))) fi else qid(substr(S:String, N?:FindResult, sd(
    N?:FindResult, length(S:String)))) fi else qid(S:String) fi if
    N?:FindResult := find(S:String, ".", 0) .
S:String --> "`)"
N?:FindResult --> notFound
splitDot("`)")
--->
if notFound :: Nat and (startsWith("`)", "f") or startsWith("`)", "i")) then
    qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(notFound,
    length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1)) if (
    startsWith(substr("`)", notFound, sd(notFound, length("`)"))), ".demote")
    or startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".promote")) or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
*********** equation
(built-in equation for symbol _::`Nat)
notFound :: Nat
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "f")
--->
false
*********** equation
(built-in equation for symbol startsWith)
startsWith("`)", "i")
--->
false
*********** equation
eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .
A:Bool --> false
B:Bool --> false
false or false
--->
false and false xor false xor false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false xor A:Bool = A:Bool .
A:Bool --> false
false xor false
--->
false
*********** equation
eq false and A:Bool = false .
A:Bool --> false
false and false
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then qid(substr("`)", 0, notFound)) if substr("`)", notFound, sd(
    notFound, length("`)"))) =/= ".const" then qid(substr("`)", notFound, 1))
    if (startsWith(substr("`)", notFound, sd(notFound, length("`)"))),
    ".demote") or startsWith(substr("`)", notFound, sd(notFound, length(
    "`)"))), ".promote")) or startsWith(substr("`)", notFound, sd(notFound,
    length("`)"))), ".wrap") then splitConversion(substr("`)", s notFound, sd(
    notFound, length("`)")))) else qid(substr("`)", s notFound, sd(notFound,
    length("`)")))) fi else qid(substr("`)", notFound, sd(notFound, length(
    "`)")))) fi else qid("`)") fi
--->
qid("`)")
*********** equation
(built-in equation for symbol qid)
qid("`)")
--->
'`)
*********** equation
eq tokenize-wasm((nil).TypeList) = nil .
empty substitution
tokenize-wasm((nil).TypeList)
--->
(nil).QidList
*********** equation
eq metaParse(M:Module, Q:QidList, T:Type?) = metaParse(M:Module, none,
    Q:QidList, T:Type?) .
M:Module --> sth 'WASMMOD is
  including 'WASMMOD .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth
Q:QidList --> '`( 'module '`( 'type '"$type0" '`( 'func '`( 'result 'i64 '`)
    '`) '`) '`( 'type '"$type1" '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '"$type2" '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '"$start" '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64 '.const '5
    'global.set '"$gb1" 'global.get '"$gb1" 'block '`( 'type '"$type2" '`) 'br
    '0 'call '"$factorial" 'end '`) '`( 'func '"$factorial" '`( 'type '"$type1"
    '`) 'i64 '.const '0 'local.get '0 'i64 '. 'eq 'if '`( 'result 'i64 '`) 'i64
    '.const '1 'else 'local.get '0 'local.get '0 'i64 '.const '1 'i64 '. 'sub
    'call '"$factorial" 'i64 '. 'mul 'end '`) '`( 'global '"$gb1" '`( 'mut 'i64
    '`) '`( 'i64 '.const '1 '`) '`) '`( 'global '"$result" '`( 'mut 'i64 '`)
    '`( 'i64 '.const '1 '`) '`) '`)
T:Type? --> 'WASMModule
metaParse(sth 'WASMMOD is
  including 'WASMMOD .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth, '`( 'module '`( 'type '"$type0" '`( 'func '`( 'result 'i64 '`) '`) '`)
    '`( 'type '"$type1" '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`) '`)
    '`) '`( 'type '"$type2" '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64 '`)
    '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func '"$start" '`(
    'result 'i64 '`) '`( 'local 'i32 '`) 'i64 '.const '5 'global.set '"$gb1"
    'global.get '"$gb1" 'block '`( 'type '"$type2" '`) 'br '0 'call
    '"$factorial" 'end '`) '`( 'func '"$factorial" '`( 'type '"$type1" '`) 'i64
    '.const '0 'local.get '0 'i64 '. 'eq 'if '`( 'result 'i64 '`) 'i64 '.const
    '1 'else 'local.get '0 'local.get '0 'i64 '.const '1 'i64 '. 'sub 'call
    '"$factorial" 'i64 '. 'mul 'end '`) '`( 'global '"$gb1" '`( 'mut 'i64 '`)
    '`( 'i64 '.const '1 '`) '`) '`( 'global '"$result" '`( 'mut 'i64 '`) '`(
    'i64 '.const '1 '`) '`) '`), 'WASMModule)
--->
metaParse(sth 'WASMMOD is
  including 'WASMMOD .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth, none, '`( 'module '`( 'type '"$type0" '`( 'func '`( 'result 'i64 '`)
    '`) '`) '`( 'type '"$type1" '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '"$type2" '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '"$start" '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64 '.const '5
    'global.set '"$gb1" 'global.get '"$gb1" 'block '`( 'type '"$type2" '`) 'br
    '0 'call '"$factorial" 'end '`) '`( 'func '"$factorial" '`( 'type '"$type1"
    '`) 'i64 '.const '0 'local.get '0 'i64 '. 'eq 'if '`( 'result 'i64 '`) 'i64
    '.const '1 'else 'local.get '0 'local.get '0 'i64 '.const '1 'i64 '. 'sub
    'call '"$factorial" 'i64 '. 'mul 'end '`) '`( 'global '"$gb1" '`( 'mut 'i64
    '`) '`( 'i64 '.const '1 '`) '`) '`( 'global '"$result" '`( 'mut 'i64 '`)
    '`( 'i64 '.const '1 '`) '`) '`), 'WASMModule)
*********** equation
(built-in equation for symbol metaParse)
metaParse(sth 'WASMMOD is
  including 'WASMMOD .
  sorts none .
  none
  none
  none
  none
  none
  none
  none
endsth, none, '`( 'module '`( 'type '"$type0" '`( 'func '`( 'result 'i64 '`)
    '`) '`) '`( 'type '"$type1" '`( 'func '`( 'param 'i64 '`) '`( 'result 'i64
    '`) '`) '`) '`( 'type '"$type2" '`( 'func '`( 'param 'i64 '`) '`( 'result
    'i64 '`) '`) '`) '`( 'export '"$start" '`( 'func '0 '`) '`) '`( 'func
    '"$start" '`( 'result 'i64 '`) '`( 'local 'i32 '`) 'i64 '.const '5
    'global.set '"$gb1" 'global.get '"$gb1" 'block '`( 'type '"$type2" '`) 'br
    '0 'call '"$factorial" 'end '`) '`( 'func '"$factorial" '`( 'type '"$type1"
    '`) 'i64 '.const '0 'local.get '0 'i64 '. 'eq 'if '`( 'result 'i64 '`) 'i64
    '.const '1 'else 'local.get '0 'local.get '0 'i64 '.const '1 'i64 '. 'sub
    'call '"$factorial" 'i64 '. 'mul 'end '`) '`( 'global '"$gb1" '`( 'mut 'i64
    '`) '`( 'i64 '.const '1 '`) '`) '`( 'global '"$result" '`( 'mut 'i64 '`)
    '`( 'i64 '.const '1 '`) '`) '`), 'WASMModule)
--->
{'module_['__['type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]],
    '__['type__['"$type1".String, 'func_['__['param_['i64.IntTypeToken],
    'result_['i64.IntTypeToken]]]], '__['type__['"$type2".String, 'func_['__[
    'param_['i64.IntTypeToken], 'result_['i64.IntTypeToken]]]], '__['export__[
    '"$start".String, 'func_['0.Zero]], '__['func____['"$start".String,
    'result_['i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], '__['global.set_['"$gb1".String], '__[
    'global.get_['"$gb1".String], '__['block_['type_['"$type2".String]], '__[
    'br_['0.Zero], '__['call_['"$factorial".String], 'end.Inst]]]]]]], '__[
    'func___['"$factorial".String, 'type_['"$type1".String], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], '__['local.get_['0.Zero], '__['_._[
    'i64.IntTypeToken, 'eq.RelopToken], '__['if_['result_['i64.IntTypeToken]],
    '__['_.const_['i64.IntTypeToken, 's_['0.Zero]], '__['else.Inst, '__[
    'local.get_['0.Zero], '__['local.get_['0.Zero], '__['_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '__['_._['i64.IntTypeToken,
    'sub.BinopToken], '__['call_['"$factorial".String], '__['_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]]]], '__[
    'global__`(_`)['"$gb1".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]],
    'global__`(_`)['"$result".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]]]]]]]]]],
    'WASMModule}
*********** equation
eq getTerm({T:Term, T:Type}) = T:Term .
T:Term --> 'module_['__['type__['"$type0".String, 'func_['result_[
    'i64.IntTypeToken]]], '__['type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]], '__['type__[
    '"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]], '__['export__['"$start".String, 'func_['0.Zero]],
    '__['func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]], '__[
    'global.set_['"$gb1".String], '__['global.get_['"$gb1".String], '__[
    'block_['type_['"$type2".String]], '__['br_['0.Zero], '__['call_[
    '"$factorial".String], 'end.Inst]]]]]]], '__['func___['"$factorial".String,
    'type_['"$type1".String], '__['_.const_['i64.IntTypeToken, '0.Zero], '__[
    'local.get_['0.Zero], '__['_._['i64.IntTypeToken, 'eq.RelopToken], '__[
    'if_['result_['i64.IntTypeToken]], '__['_.const_['i64.IntTypeToken, 's_[
    '0.Zero]], '__['else.Inst, '__['local.get_['0.Zero], '__['local.get_[
    '0.Zero], '__['_.const_['i64.IntTypeToken, 's_['0.Zero]], '__['_._[
    'i64.IntTypeToken, 'sub.BinopToken], '__['call_['"$factorial".String], '__[
    '_._['i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]]]], '__[
    'global__`(_`)['"$gb1".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]],
    'global__`(_`)['"$result".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]]]]]]]]]]
T:Type --> 'WASMModule
getTerm({'module_['__['type__['"$type0".String, 'func_['result_[
    'i64.IntTypeToken]]], '__['type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]], '__['type__[
    '"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]], '__['export__['"$start".String, 'func_['0.Zero]],
    '__['func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]], '__[
    'global.set_['"$gb1".String], '__['global.get_['"$gb1".String], '__[
    'block_['type_['"$type2".String]], '__['br_['0.Zero], '__['call_[
    '"$factorial".String], 'end.Inst]]]]]]], '__['func___['"$factorial".String,
    'type_['"$type1".String], '__['_.const_['i64.IntTypeToken, '0.Zero], '__[
    'local.get_['0.Zero], '__['_._['i64.IntTypeToken, 'eq.RelopToken], '__[
    'if_['result_['i64.IntTypeToken]], '__['_.const_['i64.IntTypeToken, 's_[
    '0.Zero]], '__['else.Inst, '__['local.get_['0.Zero], '__['local.get_[
    '0.Zero], '__['_.const_['i64.IntTypeToken, 's_['0.Zero]], '__['_._[
    'i64.IntTypeToken, 'sub.BinopToken], '__['call_['"$factorial".String], '__[
    '_._['i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]]]], '__[
    'global__`(_`)['"$gb1".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]],
    'global__`(_`)['"$result".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]]]]]]]]]],
    'WASMModule})
--->
'module_['__['type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]],
    '__['type__['"$type1".String, 'func_['__['param_['i64.IntTypeToken],
    'result_['i64.IntTypeToken]]]], '__['type__['"$type2".String, 'func_['__[
    'param_['i64.IntTypeToken], 'result_['i64.IntTypeToken]]]], '__['export__[
    '"$start".String, 'func_['0.Zero]], '__['func____['"$start".String,
    'result_['i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], '__['global.set_['"$gb1".String], '__[
    'global.get_['"$gb1".String], '__['block_['type_['"$type2".String]], '__[
    'br_['0.Zero], '__['call_['"$factorial".String], 'end.Inst]]]]]]], '__[
    'func___['"$factorial".String, 'type_['"$type1".String], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], '__['local.get_['0.Zero], '__['_._[
    'i64.IntTypeToken, 'eq.RelopToken], '__['if_['result_['i64.IntTypeToken]],
    '__['_.const_['i64.IntTypeToken, 's_['0.Zero]], '__['else.Inst, '__[
    'local.get_['0.Zero], '__['local.get_['0.Zero], '__['_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '__['_._['i64.IntTypeToken,
    'sub.BinopToken], '__['call_['"$factorial".String], '__['_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]]]], '__[
    'global__`(_`)['"$gb1".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]],
    'global__`(_`)['"$result".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]]]]]]]]]]
*********** equation
(built-in equation for symbol downTerm)
downTerm('module_['__['type__['"$type0".String, 'func_['result_[
    'i64.IntTypeToken]]], '__['type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]], '__['type__[
    '"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]], '__['export__['"$start".String, 'func_['0.Zero]],
    '__['func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]], '__[
    'global.set_['"$gb1".String], '__['global.get_['"$gb1".String], '__[
    'block_['type_['"$type2".String]], '__['br_['0.Zero], '__['call_[
    '"$factorial".String], 'end.Inst]]]]]]], '__['func___['"$factorial".String,
    'type_['"$type1".String], '__['_.const_['i64.IntTypeToken, '0.Zero], '__[
    'local.get_['0.Zero], '__['_._['i64.IntTypeToken, 'eq.RelopToken], '__[
    'if_['result_['i64.IntTypeToken]], '__['_.const_['i64.IntTypeToken, 's_[
    '0.Zero]], '__['else.Inst, '__['local.get_['0.Zero], '__['local.get_[
    '0.Zero], '__['_.const_['i64.IntTypeToken, 's_['0.Zero]], '__['_._[
    'i64.IntTypeToken, 'sub.BinopToken], '__['call_['"$factorial".String], '__[
    '_._['i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]]]], '__[
    'global__`(_`)['"$gb1".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]],
    'global__`(_`)['"$result".String, '__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], '_.const_['i64.IntTypeToken, 's_['0.Zero]]]]]]]]]]],
    errorMod)
--->
module (type "$type0" (func result i64)) (type "$type1" (func (param i64) (
    result i64))) (type "$type2" (func (param i64) (result i64))) (((global
    "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)) (
func "$factorial"
  type "$type1"
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)) (export "$start" func 0)
*********** equation
eq 
func Str:String
  FuncTypeDef:FuncTypeDef
IL:List{Inst}
 = 
func Str:String FuncTypeDef:FuncTypeDef
  (local nil)
IL:List{Inst}
 .
Str:String --> "$factorial"
FuncTypeDef:FuncTypeDef --> type "$type1"
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

func "$factorial"
  type "$type1"
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

--->

func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq run-module-func(WASMModule:WASMModule, Str:String) = read-module(
{start Str:String, indctr [0, 0, 0]}

#
WASMModule:WASMModule
#
{typeIndCtx empty} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
empty
#

) .
WASMModule:WASMModule --> module (type "$type0" (func result i64)) (type
    "$type1" (func (param i64) (result i64))) (type "$type2" (func (param i64)
    (result i64))) (export "$start" func 0) global "$gb1" (mut i64)(i64 .const
    (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$start"
run-module-func(module (type "$type0" (func result i64)) (type "$type1" (func (
    param i64) (result i64))) (type "$type2" (func (param i64) (result i64))) (
    export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), "$start")
--->
read-module(
{start "$start", indctr [0, 0, 0]}

#
module (type "$type0" (func result i64)) (type "$type1" (func (param i64) (
    result i64))) (type "$type2" (func (param i64) (result i64))) (export
    "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx empty} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
empty
#

)
*********** equation
eq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (type Str:String FuncType:FuncType)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat + 1, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
insert(Str:String, TCtr:Nat, IndTypeCtx:TypeIndCtx) IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
insert(TCtr:Nat, type Str:String FuncType:FuncType, TypeStore:Map{Addr,
    ModuleContent})
#

) .
StartFunc:Starter --> start "$start"
TCtr:Nat --> (0).Zero
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (type "$type1" (func (param i64) (result i64)))
    (type "$type2" (func (param i64) (result i64))) (export "$start" func 0)
    global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$type0"
FuncType:FuncType --> func result i64
IndTypeCtx:TypeIndCtx --> {typeIndCtx empty}
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
read-module(
{start "$start", indctr [0, 0, 0]}

#
module (type "$type0" (func result i64)) (type "$type1" (func (param i64) (
    result i64))) (type "$type2" (func (param i64) (result i64))) (export
    "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx empty} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
empty
#

)
--->
read-module(
{start "$start", indctr [0 + 1, 0, 0]}

#
module (type "$type1" (func (param i64) (result i64))) (type "$type2" (func (
    param i64) (result i64))) (export "$start" func 0) global "$gb1" (mut i64)(
    i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
insert("$type0", 0, {typeIndCtx empty}) {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
insert(0, type "$type0" (func result i64), empty)
#

)
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq insert(Str:String, Ctr:Nat, {typeIndCtx IndTypeCtxSTR:Map{String,Addr}}) = {
    typeIndCtx insert(Str:String, Ctr:Nat, IndTypeCtxSTR:Map{String,Addr})} .
Str:String --> "$type0"
Ctr:Nat --> (0).Zero
IndTypeCtxSTR:Map{String,Addr} --> (empty).Map{String,Addr}
insert("$type0", (0).Zero, {typeIndCtx empty})
--->
{typeIndCtx insert("$type0", 0, empty)}
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$type0"
R:Addr --> (0).Zero
M:Map{String,Addr} --> (empty).Map{String,Addr}
insert("$type0", (0).Zero, (empty).Map{String,Addr})
--->
(empty).Map{String,Addr}, "$type0" |-> (0).Zero
*********** equation
eq insert(D:Addr, R:ModuleContent, M:Map{Addr,ModuleContent}) = M:Map{Addr,
    ModuleContent}, D:Addr |-> R:ModuleContent [owise] .
D:Addr --> (0).Zero
R:ModuleContent --> type "$type0" (func result i64)
M:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
insert((0).Zero, type "$type0" (func result i64), (empty).Map{Addr,
    ModuleContent})
--->
(empty).Map{Addr,ModuleContent}, (0).Zero |-> type "$type0" (func result i64)
*********** equation
eq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (type Str:String FuncType:FuncType)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat + 1, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
insert(Str:String, TCtr:Nat, IndTypeCtx:TypeIndCtx) IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
insert(TCtr:Nat, type Str:String FuncType:FuncType, TypeStore:Map{Addr,
    ModuleContent})
#

) .
StartFunc:Starter --> start "$start"
TCtr:Nat --> (1).NzNat
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (type "$type2" (func (param i64) (result i64)))
    (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$type1"
FuncType:FuncType --> func (param i64) (result i64)
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0}
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64)
read-module(
{start "$start", indctr [1, 0, 0]}

#
module (type "$type1" (func (param i64) (result i64))) (type "$type2" (func (
    param i64) (result i64))) (export "$start" func 0) global "$gb1" (mut i64)(
    i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx "$type0" |-> 0} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
0 |-> type "$type0" (func result i64)
#

)
--->
read-module(
{start "$start", indctr [1 + 1, 0, 0]}

#
module (type "$type2" (func (param i64) (result i64))) (export "$start" func 0)
    global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
insert("$type1", 1, {typeIndCtx "$type0" |-> 0}) {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
insert(1, type "$type1" (func (param i64) (result i64)), 0 |-> type "$type0" (
    func result i64))
#

)
*********** equation
(built-in equation for symbol _+_)
(1).NzNat + (1).NzNat
--->
2
*********** equation
eq insert(Str:String, Ctr:Nat, {typeIndCtx IndTypeCtxSTR:Map{String,Addr}}) = {
    typeIndCtx insert(Str:String, Ctr:Nat, IndTypeCtxSTR:Map{String,Addr})} .
Str:String --> "$type1"
Ctr:Nat --> (1).NzNat
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero
insert("$type1", (1).NzNat, {typeIndCtx "$type0" |-> 0})
--->
{typeIndCtx insert("$type1", 1, "$type0" |-> 0)}
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$type1"
R:Addr --> (1).NzNat
M:Map{String,Addr} --> "$type0" |-> (0).Zero
insert("$type1", (1).NzNat, "$type0" |-> (0).Zero)
--->
"$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
*********** equation
eq insert(D:Addr, R:ModuleContent, M:Map{Addr,ModuleContent}) = M:Map{Addr,
    ModuleContent}, D:Addr |-> R:ModuleContent [owise] .
D:Addr --> (1).NzNat
R:ModuleContent --> type "$type1" (func (param i64) (result i64))
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64)
insert((1).NzNat, type "$type1" (func (param i64) (result i64)), (0).Zero |->
    type "$type0" (func result i64))
--->
(0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (func
    (param i64) (result i64))
*********** equation
eq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (type Str:String FuncType:FuncType)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat + 1, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
insert(Str:String, TCtr:Nat, IndTypeCtx:TypeIndCtx) IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
insert(TCtr:Nat, type Str:String FuncType:FuncType, TypeStore:Map{Addr,
    ModuleContent})
#

) .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 2
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$type2"
FuncType:FuncType --> func (param i64) (result i64)
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1}
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64))
read-module(
{start "$start", indctr [2, 0, 0]}

#
module (type "$type2" (func (param i64) (result i64))) (export "$start" func 0)
    global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)))
#

)
--->
read-module(
{start "$start", indctr [2 + 1, 0, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
insert("$type2", 2, {typeIndCtx "$type0" |-> 0, "$type1" |-> 1}) {funcIndCtx
    empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
insert(2, type "$type2" (func (param i64) (result i64)), (0 |-> type "$type0" (
    func result i64), 1 |-> type "$type1" (func (param i64) (result i64))))
#

)
*********** equation
(built-in equation for symbol _+_)
(1).NzNat + 2
--->
3
*********** equation
eq insert(Str:String, Ctr:Nat, {typeIndCtx IndTypeCtxSTR:Map{String,Addr}}) = {
    typeIndCtx insert(Str:String, Ctr:Nat, IndTypeCtxSTR:Map{String,Addr})} .
Str:String --> "$type2"
Ctr:Nat --> 2
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat
insert("$type2", 2, {typeIndCtx "$type0" |-> 0, "$type1" |-> 1})
--->
{typeIndCtx insert("$type2", 2, ("$type0" |-> 0, "$type1" |-> 1))}
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$type2"
R:Addr --> 2
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
insert("$type2", 2, ("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat))
--->
("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat), "$type2" |-> 2
*********** equation
eq insert(D:Addr, R:ModuleContent, M:Map{Addr,ModuleContent}) = M:Map{Addr,
    ModuleContent}, D:Addr |-> R:ModuleContent [owise] .
D:Addr --> 2
R:ModuleContent --> type "$type2" (func (param i64) (result i64))
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), (
    1).NzNat |-> type "$type1" (func (param i64) (result i64))
insert(2, type "$type2" (func (param i64) (result i64)), ((0).Zero |-> type
    "$type0" (func result i64), (1).NzNat |-> type "$type1" (func (param i64) (
    result i64))))
--->
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64))), 2 |-> type "$type2" (func (param i64) (
    result i64))
*********** trial #367
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat + 1, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} insert(Str:String, FCtr:Nat,
    IndFuncCtx:FuncIndCtx) 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
insert(FCtr:Nat, 
func Str:String get-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,
    ModuleContent}, IndTypeCtxSTR:Map{String,Addr})
  LocalsRef:LocalsRef
IL:List{Inst}
, FuncStore:Map{Addr,ModuleContent})
#
TypeStore:Map{Addr,ModuleContent}
#

) if valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$factorial"
FuncTypeDef:FuncTypeDef --> type "$type1"
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** solving condition fragment
valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true
*********** equation
eq valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true [owise] .
FuncTypeDef:FuncTypeDef --> type "$type1"
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
valid-functype(type "$type1", (0 |-> type "$type0" (func result i64), 1 |->
    type "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (
    param i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |->
    2))
--->
true
*********** success for condition fragment
valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$factorial"
FuncTypeDef:FuncTypeDef --> type "$type1"
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** success #367
*********** equation
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat + 1, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} insert(Str:String, FCtr:Nat,
    IndFuncCtx:FuncIndCtx) 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
insert(FCtr:Nat, 
func Str:String get-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,
    ModuleContent}, IndTypeCtxSTR:Map{String,Addr})
  LocalsRef:LocalsRef
IL:List{Inst}
, FuncStore:Map{Addr,ModuleContent})
#
TypeStore:Map{Addr,ModuleContent}
#

) if valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (0).Zero
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
Str:String --> "$factorial"
FuncTypeDef:FuncTypeDef --> type "$type1"
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx empty}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 0, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$factorial" type "$type1"
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx empty} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
empty
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
read-module(
{start "$start", indctr [3, 0 + 1, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} insert(
    "$factorial", 0, {funcIndCtx empty}) 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
insert(0, 
func "$factorial" get-functype(type "$type1", (0 |-> type "$type0" (func result
    i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2 |-> type
    "$type2" (func (param i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1,
    "$type2" |-> 2))
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, empty)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq insert(Str:String, Ctr:Nat, {funcIndCtx IndFuncCtxSTR:Map{String,Addr}}) = {
    funcIndCtx insert(Str:String, Ctr:Nat, IndFuncCtxSTR:Map{String,Addr})} .
Str:String --> "$factorial"
Ctr:Nat --> (0).Zero
IndFuncCtxSTR:Map{String,Addr} --> (empty).Map{String,Addr}
insert("$factorial", (0).Zero, {funcIndCtx empty})
--->
{funcIndCtx insert("$factorial", 0, empty)}
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$factorial"
R:Addr --> (0).Zero
M:Map{String,Addr} --> (empty).Map{String,Addr}
insert("$factorial", (0).Zero, (empty).Map{String,Addr})
--->
(empty).Map{String,Addr}, "$factorial" |-> (0).Zero
*********** equation
eq get-functype(type Str:String, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = get-functype-typedef(TypeStore:Map{Addr,
    ModuleContent}[IndTypeCtxSTR:Map{String,Addr}[Str:String]]) .
Str:String --> "$type1"
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
get-functype(type "$type1", (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2))
--->
get-functype-typedef((0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64)))[("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2)[
    "$type1"]])
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type2" |-> 2
D:String --> "$type1"
R:Addr --> (1).NzNat
("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat, "$type2" |-> 2)["$type1"]
--->
if $hasMapping(("$type0" |-> (0).Zero, "$type2" |-> 2), "$type1") then (
    undefined).Rat else (1).NzNat fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type2" |-> 2
D:String --> "$type1"
$hasMapping(("$type0" |-> (0).Zero, "$type2" |-> 2), "$type1")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (1).NzNat fi
--->
(1).NzNat
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), 2
    |-> type "$type2" (func (param i64) (result i64))
D:Addr --> (1).NzNat
R:ModuleContent --> type "$type1" (func (param i64) (result i64))
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))[(1).NzNat]
--->
if $hasMapping(((0).Zero |-> type "$type0" (func result i64), 2 |-> type
    "$type2" (func (param i64) (result i64))), (1).NzNat) then (
    undefined).FuncDefList else type "$type1" (func (param i64) (result i64))
    fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), 2
    |-> type "$type2" (func (param i64) (result i64))
D:Addr --> (1).NzNat
$hasMapping(((0).Zero |-> type "$type0" (func result i64), 2 |-> type "$type2"
    (func (param i64) (result i64))), (1).NzNat)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else type "$type1" (func (param i64) (
    result i64)) fi
--->
type "$type1" (func (param i64) (result i64))
*********** equation
eq get-functype-typedef(type Str:String (func ParamResultType:ParamResultType))
    = ParamResultType:ParamResultType .
Str:String --> "$type1"
ParamResultType:ParamResultType --> (param i64) (result i64)
get-functype-typedef(type "$type1" (func (param i64) (result i64)))
--->
(param i64) (result i64)
*********** equation
eq insert(D:Addr, R:ModuleContent, M:Map{Addr,ModuleContent}) = M:Map{Addr,
    ModuleContent}, D:Addr |-> R:ModuleContent [owise] .
D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

M:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
insert((0).Zero, 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (empty).Map{Addr,ModuleContent})
--->
(empty).Map{Addr,ModuleContent}, (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** trial #368
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat + 1, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} insert(Str:String, FCtr:Nat,
    IndFuncCtx:FuncIndCtx) 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
insert(FCtr:Nat, 
func Str:String get-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,
    ModuleContent}, IndTypeCtxSTR:Map{String,Addr})
  LocalsRef:LocalsRef
IL:List{Inst}
, FuncStore:Map{Addr,ModuleContent})
#
TypeStore:Map{Addr,ModuleContent}
#

) if valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (1).NzNat
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** solving condition fragment
valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true
*********** equation
eq valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true [owise] .
FuncTypeDef:FuncTypeDef --> result i64
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
valid-functype(result i64, (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2))
--->
true
*********** success for condition fragment
valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (1).NzNat
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** success #368
*********** equation
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent (
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat + 1, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} insert(Str:String, FCtr:Nat,
    IndFuncCtx:FuncIndCtx) 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
insert(FCtr:Nat, 
func Str:String get-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,
    ModuleContent}, IndTypeCtxSTR:Map{String,Addr})
  LocalsRef:LocalsRef
IL:List{Inst}
, FuncStore:Map{Addr,ModuleContent})
#
TypeStore:Map{Addr,ModuleContent}
#

) if valid-functype(FuncTypeDef:FuncTypeDef, TypeStore:Map{Addr,ModuleContent},
    IndTypeCtxSTR:Map{String,Addr}) = true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> (1).NzNat
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$gb1" (mut
    i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 1, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
) (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
read-module(
{start "$start", indctr [3, 1 + 1, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} insert("$start", 1,
    {funcIndCtx "$factorial" |-> 0}) 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
insert(1, 
func "$start" get-functype(result i64, (0 |-> type "$type0" (func result i64),
    1 |-> type "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (
    func (param i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2))
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, 0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
(built-in equation for symbol _+_)
(1).NzNat + (1).NzNat
--->
2
*********** equation
eq insert(Str:String, Ctr:Nat, {funcIndCtx IndFuncCtxSTR:Map{String,Addr}}) = {
    funcIndCtx insert(Str:String, Ctr:Nat, IndFuncCtxSTR:Map{String,Addr})} .
Str:String --> "$start"
Ctr:Nat --> (1).NzNat
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero
insert("$start", (1).NzNat, {funcIndCtx "$factorial" |-> 0})
--->
{funcIndCtx insert("$start", 1, "$factorial" |-> 0)}
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$start"
R:Addr --> (1).NzNat
M:Map{String,Addr} --> "$factorial" |-> (0).Zero
insert("$start", (1).NzNat, "$factorial" |-> (0).Zero)
--->
"$factorial" |-> (0).Zero, "$start" |-> (1).NzNat
*********** equation
eq get-functype(ParamResultType:ParamResultType, TypeStore:Map{Addr,
    ModuleContent}, IndTypeCtxSTR:Map{String,Addr}) =
    ParamResultType:ParamResultType .
ParamResultType:ParamResultType --> result i64
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
get-functype(result i64, (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2))
--->
result i64
*********** equation
eq insert(D:Addr, R:ModuleContent, M:Map{Addr,ModuleContent}) = M:Map{Addr,
    ModuleContent}, D:Addr |-> R:ModuleContent [owise] .
D:Addr --> (1).NzNat
R:ModuleContent --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

M:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

insert((1).NzNat, 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
(0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

*********** trial #369
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent global Str:String GlobalType:GlobalType(
    IntT:IntTypeToken .const IntN:Int
)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat + 1]}

#
module ModuleContent:ModuleContent
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
insert(Str:String, GCtr:Nat, GlobalAddrs:Map{String,Addr}) <-> insert(GCtr:Nat,
    {type GlobalType:GlobalType, value const(IntT:IntTypeToken, val(
    IntN:Int))}, GlobalsStore:Map{Addr,GlobalInstance})
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) if IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int =
    true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$result" (mut
    i64)(i64 .const (1).NzNat
)
Str:String --> "$gb1"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** solving condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
*********** equation
eq bit-width(T:TypeToken) = 64 [owise] .
T:TypeToken --> i64
bit-width(i64)
--->
64
*********** equation
(built-in equation for symbol _^_)
2 ^ 64
--->
18446744073709551616
*********** equation
(built-in equation for symbol _<_)
(1).NzNat < 18446744073709551616
--->
true
*********** equation
(built-in equation for symbol _<=_)
(0).Zero <= (1).NzNat
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$result" (mut
    i64)(i64 .const (1).NzNat
)
Str:String --> "$gb1"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** success #369
*********** equation
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent global Str:String GlobalType:GlobalType(
    IntT:IntTypeToken .const IntN:Int
)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat + 1]}

#
module ModuleContent:ModuleContent
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
insert(Str:String, GCtr:Nat, GlobalAddrs:Map{String,Addr}) <-> insert(GCtr:Nat,
    {type GlobalType:GlobalType, value const(IntT:IntTypeToken, val(
    IntN:Int))}, GlobalsStore:Map{Addr,GlobalInstance})
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) if IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int =
    true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (0).Zero
ModuleContent:ModuleContent --> (export "$start" func 0) global "$result" (mut
    i64)(i64 .const (1).NzNat
)
Str:String --> "$gb1"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> (empty).Map{String,Addr}
GlobalsStore:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 2, 0]}

#
module (export "$start" func 0) global "$gb1" (mut i64)(i64 .const (1).NzNat
) global "$result" (mut i64)(i64 .const (1).NzNat
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
empty <-> empty
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
read-module(
{start "$start", indctr [3, 2, 0 + 1]}

#
module (export "$start" func 0) global "$result" (mut i64)(i64 .const (1).NzNat
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
insert("$gb1", 0, empty) <-> insert(0, {type mut i64, value const(i64, val((
    1).NzNat))}, empty)
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$gb1"
R:Addr --> (0).Zero
M:Map{String,Addr} --> (empty).Map{String,Addr}
insert("$gb1", (0).Zero, (empty).Map{String,Addr})
--->
(empty).Map{String,Addr}, "$gb1" |-> (0).Zero
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val((1).NzNat)
Value: const(i64, val((1).NzNat)) becomes IntValue
*********** equation
eq insert(D:Addr, R:GlobalInstance, M:Map{Addr,GlobalInstance}) = M:Map{Addr,
    GlobalInstance}, D:Addr |-> R:GlobalInstance [owise] .
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
M:Map{Addr,GlobalInstance} --> (empty).Map{Addr,GlobalInstance}
insert((0).Zero, {type mut i64, value const(i64, val((1).NzNat))}, (empty).Map{
    Addr,GlobalInstance})
--->
(empty).Map{Addr,GlobalInstance}, (0).Zero |-> {type mut i64, value const(i64,
    val((1).NzNat))}
*********** trial #370
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent global Str:String GlobalType:GlobalType(
    IntT:IntTypeToken .const IntN:Int
)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat + 1]}

#
module ModuleContent:ModuleContent
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
insert(Str:String, GCtr:Nat, GlobalAddrs:Map{String,Addr}) <-> insert(GCtr:Nat,
    {type GlobalType:GlobalType, value const(IntT:IntTypeToken, val(
    IntN:Int))}, GlobalsStore:Map{Addr,GlobalInstance})
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) if IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int =
    true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (1).NzNat
ModuleContent:ModuleContent --> export "$start" func 0
Str:String --> "$result"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** solving condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
*********** equation
eq bit-width(T:TypeToken) = 64 [owise] .
T:TypeToken --> i64
bit-width(i64)
--->
64
*********** equation
(built-in equation for symbol _^_)
2 ^ 64
--->
18446744073709551616
*********** equation
(built-in equation for symbol _<_)
(1).NzNat < 18446744073709551616
--->
true
*********** equation
(built-in equation for symbol _<=_)
(0).Zero <= (1).NzNat
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (1).NzNat
ModuleContent:ModuleContent --> export "$start" func 0
Str:String --> "$result"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
*********** success #370
*********** equation
ceq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent global Str:String GlobalType:GlobalType(
    IntT:IntTypeToken .const IntN:Int
)
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat + 1]}

#
module ModuleContent:ModuleContent
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
insert(Str:String, GCtr:Nat, GlobalAddrs:Map{String,Addr}) <-> insert(GCtr:Nat,
    {type GlobalType:GlobalType, value const(IntT:IntTypeToken, val(
    IntN:Int))}, GlobalsStore:Map{Addr,GlobalInstance})
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) if IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int =
    true .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> (1).NzNat
ModuleContent:ModuleContent --> export "$start" func 0
Str:String --> "$result"
GlobalType:GlobalType --> mut i64
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 2, 1]}

#
module (export "$start" func 0) global "$result" (mut i64)(i64 .const (1).NzNat
)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
"$gb1" |-> 0 <-> 0 |-> {type mut i64, value const(i64, val((1).NzNat))}
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
read-module(
{start "$start", indctr [3, 2, 1 + 1]}

#
module (export "$start" func 0)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
insert("$result", 1, "$gb1" |-> 0) <-> insert(1, {type mut i64, value const(
    i64, val((1).NzNat))}, 0 |-> {type mut i64, value const(i64, val((
    1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
(built-in equation for symbol _+_)
(1).NzNat + (1).NzNat
--->
2
*********** equation
eq insert(D:String, R:Addr, M:Map{String,Addr}) = M:Map{String,Addr}, D:String
    |-> R:Addr [owise] .
D:String --> "$result"
R:Addr --> (1).NzNat
M:Map{String,Addr} --> "$gb1" |-> (0).Zero
insert("$result", (1).NzNat, "$gb1" |-> (0).Zero)
--->
"$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val((1).NzNat)
Value: const(i64, val((1).NzNat)) becomes IntValue
*********** equation
eq insert(D:Addr, R:GlobalInstance, M:Map{Addr,GlobalInstance}) = M:Map{Addr,
    GlobalInstance}, D:Addr |-> R:GlobalInstance [owise] .
D:Addr --> (1).NzNat
R:GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
M:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value const(i64,
    val((1).NzNat))}
insert((1).NzNat, {type mut i64, value const(i64, val((1).NzNat))}, (0).Zero
    |-> {type mut i64, value const(i64, val((1).NzNat))})
--->
(0).Zero |-> {type mut i64, value const(i64, val((1).NzNat))}, (1).NzNat |-> {
    type mut i64, value const(i64, val((1).NzNat))}
*********** equation
eq read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent ExportDef:ExportDef
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = read-module(
{StartFunc:Starter, indctr [TCtr:Nat, FCtr:Nat, GCtr:Nat]}

#
module ModuleContent:ModuleContent
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) .
StartFunc:Starter --> start "$start"
TCtr:Nat --> 3
FCtr:Nat --> 2
GCtr:Nat --> 2
ModuleContent:ModuleContent --> EmptyMod
ExportDef:ExportDef --> export "$start" func 0
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 2, 2]}

#
module (export "$start" func 0)
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
read-module(
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
eq read-module(
{start Str:String, indctr ComponentCtr:ComponentCtr}

#
module EmptyMod
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = validate-funcs-module(
{start Str:String, indctr ComponentCtr:ComponentCtr}

#
module EmptyMod
#
IndTypeCtx:TypeIndCtx IndFuncCtx:FuncIndCtx 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) .
Str:String --> "$start"
ComponentCtr:ComponentCtr --> [3, 2, 2]
IndTypeCtx:TypeIndCtx --> {typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2}
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
read-module(
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
validate-funcs-module(
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
*********** equation
eq validate-funcs-module(
{start Str:String, indctr ComponentCtr:ComponentCtr}

#
module EmptyMod
#
{typeIndCtx IndTypeCtxSTR:Map{String,Addr}} {funcIndCtx IndFuncCtxSTR:Map{
    String,Addr}} 
< uninitialized | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent}
#

) = if verify-funcList(get-funcList(FuncStore:Map{Addr,ModuleContent}),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr}) then 
{start Str:String, indctr ComponentCtr:ComponentCtr}

#
module EmptyMod
#
simulate-wasm({typeIndCtx IndTypeCtxSTR:Map{String,Addr}} {funcIndCtx
    IndFuncCtxSTR:Map{String,Addr}} 
< call IndFuncCtxSTR:Map{String,Addr}[Str:String]
 | ST:Stack | empty >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance}
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent})
#

 else Fail("Invalid module") fi .
Str:String --> "$start"
ComponentCtr:ComponentCtr --> [3, 2, 2]
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
ST:Stack --> EmptyStack
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
validate-funcs-module(
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< uninitialized | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
if verify-funcList(get-funcList((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (
    func result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2
    |-> type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
    then 
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
simulate-wasm({typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {
    funcIndCtx "$factorial" |-> 0, "$start" |-> 1} 
< call ("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$start"]
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
#

 else Fail("Invalid module") fi
*********** equation
eq get-funcList((FuncStore:Map{Addr,ModuleContent}, Addr:Addr |->
    FuncDef:FuncDef)) = FuncDef:FuncDef, get-funcList(FuncStore:Map{Addr,
    ModuleContent}) .
FuncStore:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

Addr:Addr --> (0).Zero
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-funcList((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
))
--->
(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
), get-funcList(1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
*********** equation
eq get-funcList((FuncStore:Map{Addr,ModuleContent}, Addr:Addr |->
    FuncDef:FuncDef)) = FuncDef:FuncDef, get-funcList(FuncStore:Map{Addr,
    ModuleContent}) .
FuncStore:Map{Addr,ModuleContent} --> (empty).Map{Addr,ModuleContent}
Addr:Addr --> (1).NzNat
FuncDef:FuncDef --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

get-funcList(1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), get-funcList(empty)
*********** equation
eq get-funcList(empty) = EmptyFuncDefL .
empty substitution
get-funcList(empty)
--->
EmptyFuncDefL
*********** equation
eq verify-funcList((
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
), FuncDefL:FuncDefList, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}) = verify-funcList(FuncDefL:FuncDefList, IndTypeCtxSTR:Map{
    String,Addr}, TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,
    Addr}, FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,
    GlobalInstance}, GlobalAddrs:Map{String,Addr}) and verify-IL(IL:List{Inst},
    nil, get-paramlistTList-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
) get-localsTList(LocalsRef:LocalsRef), reverse(get-resultlistTList-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    get-resultlist-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)) .
Str:String --> "$factorial"
FuncTypeDef:FuncTypeDef --> (param i64) (result i64)
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
FuncDefL:FuncDefList --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
verify-funcList((
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
), (
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func
    result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
--->
verify-funcList(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func
    result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
    and verify-IL(i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, nil, get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) get-localsTList(local nil), reverse(get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (
    func result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2
    |-> type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq verify-funcList((
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
), FuncDefL:FuncDefList, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}) = verify-funcList(FuncDefL:FuncDefList, IndTypeCtxSTR:Map{
    String,Addr}, TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,
    Addr}, FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,
    GlobalInstance}, GlobalAddrs:Map{String,Addr}) and verify-IL(IL:List{Inst},
    nil, get-paramlistTList-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
) get-localsTList(LocalsRef:LocalsRef), reverse(get-resultlistTList-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    get-resultlist-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
)) .
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
FuncDefL:FuncDefList --> EmptyFuncDefL
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
verify-funcList(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func
    result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
--->
verify-funcList(EmptyFuncDefL, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |->
    2), (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (
    param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result
    i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
    and verify-IL(i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, nil, get-paramlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
) get-localsTList(local i32), reverse(get-resultlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)), ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (
    func result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2
    |-> type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
))
*********** equation
eq verify-funcList(EmptyFuncDefL, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}) = true .
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
verify-funcList(EmptyFuncDefL, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |->
    2), (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (
    param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result
    i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1))
--->
true
*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

get-paramlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = param nil .
Str:String --> "$start"
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
get-paramlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
param nil
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> (nil).List{TypeToken}
aux-get-paramlistTList(param nil)
--->
(nil).List{TypeToken}
*********** equation
eq get-localsTList(local TList:List{TypeToken}) = TList:List{TypeToken} .
TList:List{TypeToken} --> i32
get-localsTList(local i32)
--->
i32
*********** equation
eq get-resultlistTList-func(FuncDef:FuncDef) = aux-get-resultlistTList(
    get-resultlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

get-resultlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
aux-get-resultlistTList(get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
))
*********** equation
eq get-resultlist-func(
func Str:String ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$start"
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** equation
eq reverse(L:List{TypeToken}) = $reverse(L:List{TypeToken}, nil) .
L:List{TypeToken} --> i64
reverse(i64)
--->
$reverse(i64, (nil).List{TypeToken})
*********** equation
eq $reverse(E:TypeToken L:List{TypeToken}, A:List{TypeToken}) = $reverse(
    L:List{TypeToken}, E:TypeToken A:List{TypeToken}) .
E:TypeToken --> i64
L:List{TypeToken} --> (nil).List{TypeToken}
A:List{TypeToken} --> (nil).List{TypeToken}
$reverse(i64, (nil).List{TypeToken})
--->
$reverse((nil).List{TypeToken}, i64 (nil).List{TypeToken})
*********** equation
eq $reverse((nil).List{TypeToken}, A:List{TypeToken}) = A:List{TypeToken} .
A:List{TypeToken} --> i64
$reverse((nil).List{TypeToken}, i64)
--->
i64
*********** equation
eq get-resultlist-func(
func Str:String ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$start"
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
--->
result i64
*********** equation
eq verify-IL(IntT:IntTypeToken .const IntN:Int
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, IntT:IntTypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, nil, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, i64 (nil).List{TypeToken}, i32, i64, ("$type0" |-> 0, "$type1" |-> 1,
    "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** trial #371
ceq verify-IL(global.set Str:String
 IL:List{Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if
    MutGlobalTypeIndicator:MutGlobalTypeIndicator T:TypeToken := global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) .
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
MutGlobalTypeIndicator:MutGlobalTypeIndicator --> (unbound)
*********** solving condition fragment
MutGlobalTypeIndicator:MutGlobalTypeIndicator T:TypeToken := global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]])
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
R:Addr --> (0).Zero
("$gb1" |-> (0).Zero, "$result" |-> (1).NzNat)["$gb1"]
--->
if $hasMapping("$result" |-> (1).NzNat, "$gb1") then (undefined).Rat else (
    0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
$hasMapping("$result" |-> (1).NzNat, "$gb1")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** equation
eq (M:Map{Addr,GlobalInstance}, D:Addr |-> R:GlobalInstance)[D:Addr] = if
    $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) then undefined else
    R:GlobalInstance fi .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
((0).Zero |-> {type mut i64, value const(i64, val((1).NzNat))}, (1).NzNat |-> {
    type mut i64, value const(i64, val((1).NzNat))})[(0).Zero]
--->
if $hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))},
    (0).Zero) then (undefined).GlobalInstance else {type mut i64, value const(
    i64, val((1).NzNat))} fi
*********** equation
eq $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) = false [owise] .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (
    0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).GlobalInstance else {type mut i64, value const(i64,
    val((1).NzNat))} fi
--->
{type mut i64, value const(i64, val((1).NzNat))}
*********** equation
eq global-type({type GlobalType:GlobalType, value Val:Value}) =
    GlobalType:GlobalType .
GlobalType:GlobalType --> mut i64
Val:Value --> const(i64, val((1).NzNat))
global-type({type mut i64, value const(i64, val((1).NzNat))})
--->
mut i64
*********** success for condition fragment
MutGlobalTypeIndicator:MutGlobalTypeIndicator T:TypeToken := global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]])
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
MutGlobalTypeIndicator:MutGlobalTypeIndicator --> mut
*********** success #371
*********** equation
ceq verify-IL(global.set Str:String
 IL:List{Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if
    MutGlobalTypeIndicator:MutGlobalTypeIndicator T:TypeToken := global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) .
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
MutGlobalTypeIndicator:MutGlobalTypeIndicator --> mut
verify-IL(global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, i64, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, nil, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** equation
eq verify-IL(global.get Str:String
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, get-GlobalTypeToken(global-type(GlobalsStore:Map{Addr,
    GlobalInstance}[GlobalAddrs:Map{String,Addr}[Str:String]])) TList:List{
    TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) .
Str:String --> "$gb1"
IL:List{Inst} --> block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end, nil, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(block type "$type2"
 br 0
 call "$factorial"
 end, get-GlobalTypeToken(global-type((0 |-> {type mut i64, value const(i64,
    val((1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})[(
    "$gb1" |-> 0, "$result" |-> 1)["$gb1"]])) (nil).List{TypeToken}, i32, i64,
    ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (
    func result i64), 1 |-> type "$type1" (func (param i64) (result i64)), 2
    |-> type "$type2" (func (param i64) (result i64))), ("$factorial" |-> 0,
    "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
R:Addr --> (0).Zero
("$gb1" |-> (0).Zero, "$result" |-> (1).NzNat)["$gb1"]
--->
if $hasMapping("$result" |-> (1).NzNat, "$gb1") then (undefined).Rat else (
    0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
$hasMapping("$result" |-> (1).NzNat, "$gb1")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** equation
eq (M:Map{Addr,GlobalInstance}, D:Addr |-> R:GlobalInstance)[D:Addr] = if
    $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) then undefined else
    R:GlobalInstance fi .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
((0).Zero |-> {type mut i64, value const(i64, val((1).NzNat))}, (1).NzNat |-> {
    type mut i64, value const(i64, val((1).NzNat))})[(0).Zero]
--->
if $hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))},
    (0).Zero) then (undefined).GlobalInstance else {type mut i64, value const(
    i64, val((1).NzNat))} fi
*********** equation
eq $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) = false [owise] .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (
    0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).GlobalInstance else {type mut i64, value const(i64,
    val((1).NzNat))} fi
--->
{type mut i64, value const(i64, val((1).NzNat))}
*********** equation
eq global-type({type GlobalType:GlobalType, value Val:Value}) =
    GlobalType:GlobalType .
GlobalType:GlobalType --> mut i64
Val:Value --> const(i64, val((1).NzNat))
global-type({type mut i64, value const(i64, val((1).NzNat))})
--->
mut i64
*********** equation
eq get-GlobalTypeToken(MutGlobalTypeIndicator:MutGlobalTypeIndicator
    T:TypeToken) = T:TypeToken .
MutGlobalTypeIndicator:MutGlobalTypeIndicator --> mut
T:TypeToken --> i64
get-GlobalTypeToken(mut i64)
--->
i64
*********** trial #372
ceq verify-IL(block TypeRef:TypeRef
 IL2:List{Inst} end IL:List{Inst}, TList':List{TypeToken} TList:List{
    TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{Inst},
    aux-get-resultlistTList(getResultType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent})))
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if TList':List{TypeToken} ==
    aux-get-paramlistTList(getParamType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent}))) and
    verify-IL(IL2:List{Inst}, TList':List{TypeToken}, TList1:List{TypeToken},
    aux-get-resultlistTList(getResultType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent}))),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent})), LabelsResultTypeList:ResultTypeList) =
    true .
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> (nil).List{Inst}
TList':List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
*********** solving condition fragment
TList':List{TypeToken} == aux-get-paramlistTList(getParamType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))) and verify-IL(IL2:List{Inst}, TList':List{TypeToken},
    TList1:List{TypeToken}, aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{
    String,Addr}, TypeStore:Map{Addr,ModuleContent})),
    LabelsResultTypeList:ResultTypeList) = true
*********** equation
eq expand(type Str:String, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}) = get-functype-typedef(TypeStore:Map{Addr,ModuleContent}[
    IndTypeCtxSTR:Map{String,Addr}[Str:String]]) .
Str:String --> "$type2"
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
expand(type "$type2", ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
--->
get-functype-typedef((0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64)))[("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2)[
    "$type2"]])
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
D:String --> "$type2"
R:Addr --> 2
("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat, "$type2" |-> 2)["$type2"]
--->
if $hasMapping(("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat), "$type2") then
    (undefined).Rat else 2 fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
D:String --> "$type2"
$hasMapping(("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat), "$type2")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else 2 fi
--->
2
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), (
    1).NzNat |-> type "$type1" (func (param i64) (result i64))
D:Addr --> 2
R:ModuleContent --> type "$type2" (func (param i64) (result i64))
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))[2]
--->
if $hasMapping(((0).Zero |-> type "$type0" (func result i64), (1).NzNat |->
    type "$type1" (func (param i64) (result i64))), 2) then (
    undefined).FuncDefList else type "$type2" (func (param i64) (result i64))
    fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), (
    1).NzNat |-> type "$type1" (func (param i64) (result i64))
D:Addr --> 2
$hasMapping(((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type
    "$type1" (func (param i64) (result i64))), 2)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else type "$type2" (func (param i64) (
    result i64)) fi
--->
type "$type2" (func (param i64) (result i64))
*********** equation
eq get-functype-typedef(type Str:String (func ParamResultType:ParamResultType))
    = ParamResultType:ParamResultType .
Str:String --> "$type2"
ParamResultType:ParamResultType --> (param i64) (result i64)
get-functype-typedef(type "$type2" (func (param i64) (result i64)))
--->
(param i64) (result i64)
*********** equation
eq getParamType((param TList1:List{TypeToken}) (result TList2:List{TypeToken}))
    = param TList1:List{TypeToken} .
TList1:List{TypeToken} --> i64
TList2:List{TypeToken} --> i64
getParamType((param i64) (result i64))
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
(built-in equation for symbol _==_)
i64 == i64
--->
true
*********** equation
eq getResultType((param TList1:List{TypeToken}) (result TList2:List{
    TypeToken})) = result TList2:List{TypeToken} .
TList1:List{TypeToken} --> i64
TList2:List{TypeToken} --> i64
getResultType((param i64) (result i64))
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** trial #373
ceq verify-IL(br N:Nat
 IL:List{Inst}, TListLabel:List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, Unknown, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TListLabel:List{
    TypeToken} == nthResultT(LabelsResultTypeList:ResultTypeList, N:Nat) = true
    .
N:Nat --> (0).Zero
IL:List{Inst} --> call "$factorial"

TListLabel:List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** solving condition fragment
TListLabel:List{TypeToken} == nthResultT(LabelsResultTypeList:ResultTypeList,
    N:Nat) = true
*********** equation
eq nthResultT((result TList:List{TypeToken}),
    LabelsResultTypeList:ResultTypeList, 0) = TList:List{TypeToken} .
TList:List{TypeToken} --> i64
LabelsResultTypeList:ResultTypeList --> result i64
nthResultT((result i64), (result i64), 0)
--->
i64
*********** equation
(built-in equation for symbol _==_)
i64 == i64
--->
true
*********** success for condition fragment
TListLabel:List{TypeToken} == nthResultT(LabelsResultTypeList:ResultTypeList,
    N:Nat) = true
N:Nat --> (0).Zero
IL:List{Inst} --> call "$factorial"

TListLabel:List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** success #373
*********** equation
ceq verify-IL(br N:Nat
 IL:List{Inst}, TListLabel:List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, Unknown, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TListLabel:List{
    TypeToken} == nthResultT(LabelsResultTypeList:ResultTypeList, N:Nat) = true
    .
N:Nat --> (0).Zero
IL:List{Inst} --> call "$factorial"

TListLabel:List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(br 0
 call "$factorial"
, i64, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type
    "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (result
    i64)), 2 |-> type "$type2" (func (param i64) (result i64))), ("$factorial"
    |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
verify-IL(call "$factorial"
, Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
*********** equation
eq verify-IL(call Str:String
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(call
    IndFuncCtxSTR:Map{String,Addr}[Str:String]
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
Str:String --> "$factorial"
IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> Unknown
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(call "$factorial"
, Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
verify-IL(call ("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)[
    "$factorial"]
 nil, Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$start" |-> (1).NzNat
D:String --> "$factorial"
R:Addr --> (0).Zero
("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$factorial"]
--->
if $hasMapping("$start" |-> (1).NzNat, "$factorial") then (undefined).Rat else
    (0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$start" |-> (1).NzNat
D:String --> "$factorial"
$hasMapping("$start" |-> (1).NzNat, "$factorial")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** trial #374
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, TList':List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, get-resultlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TList':List{
    TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[
    Addr:Addr]) = true .
Addr:Addr --> (0).Zero
IL:List{Inst} --> (nil).List{Inst}
TList':List{TypeToken} --> Unknown
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** solving condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)[(0).Zero]
--->
if $hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero) then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
--->

func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
(built-in equation for symbol _==_)
Unknown == i64
--->
false
*********** failure for condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** failure #374
*********** trial #375
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, TList':List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, get-resultlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TList':List{
    TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[
    Addr:Addr]) = true .
Addr:Addr --> (0).Zero
IL:List{Inst} --> (nil).List{Inst}
TList':List{TypeToken} --> (nil).List{TypeToken}
TList:List{TypeToken} --> Unknown
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** solving condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)[(0).Zero]
--->
if $hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero) then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
--->

func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
(built-in equation for symbol _==_)
(nil).List{TypeToken} == i64
--->
false
*********** failure for condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** failure #375
*********** trial #376
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, Unknown, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{Inst},
    get-resultlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr])
    Unknown, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if TList':List{TypeToken} :=
    get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr]) .
Addr:Addr --> (0).Zero
IL:List{Inst} --> (nil).List{Inst}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> (unbound)
*********** solving condition fragment
TList':List{TypeToken} := get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr])
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)[(0).Zero]
--->
if $hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero) then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
--->

func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** success for condition fragment
TList':List{TypeToken} := get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr])
Addr:Addr --> (0).Zero
IL:List{Inst} --> (nil).List{Inst}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> i64
*********** success #376
*********** equation
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, Unknown, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{Inst},
    get-resultlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr])
    Unknown, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if TList':List{TypeToken} :=
    get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr]) .
Addr:Addr --> (0).Zero
IL:List{Inst} --> (nil).List{Inst}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> i64
verify-IL(call (0).Zero
, Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
verify-IL(nil, get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
*********** equation
eq get-resultlistTList-func(FuncDef:FuncDef) = aux-get-resultlistTList(
    get-resultlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-resultlistTList(get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-resultlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** trial #377
ceq verify-IL(nil, TList:List{TypeToken} Unknown, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true if TList:List{
    TypeToken} TList':List{TypeToken} := TListRes:List{TypeToken} .
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> (unbound)
*********** solving condition fragment
TList:List{TypeToken} TList':List{TypeToken} := TListRes:List{TypeToken}
*********** success for condition fragment
TList:List{TypeToken} TList':List{TypeToken} := TListRes:List{TypeToken}
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> (nil).List{TypeToken}
*********** success #377
*********** equation
ceq verify-IL(nil, TList:List{TypeToken} Unknown, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true if TList:List{
    TypeToken} TList':List{TypeToken} := TListRes:List{TypeToken} .
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
TList':List{TypeToken} --> (nil).List{TypeToken}
verify-IL(nil, i64 Unknown, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2"
    |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (
    param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result
    i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
TList':List{TypeToken} == aux-get-paramlistTList(getParamType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))) and verify-IL(IL2:List{Inst}, TList':List{TypeToken},
    TList1:List{TypeToken}, aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{
    String,Addr}, TypeStore:Map{Addr,ModuleContent})),
    LabelsResultTypeList:ResultTypeList) = true
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> (nil).List{Inst}
TList':List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
*********** success #372
*********** equation
ceq verify-IL(block TypeRef:TypeRef
 IL2:List{Inst} end IL:List{Inst}, TList':List{TypeToken} TList:List{
    TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{Inst},
    aux-get-resultlistTList(getResultType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent})))
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if TList':List{TypeToken} ==
    aux-get-paramlistTList(getParamType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent}))) and
    verify-IL(IL2:List{Inst}, TList':List{TypeToken}, TList1:List{TypeToken},
    aux-get-resultlistTList(getResultType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent}))),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent})), LabelsResultTypeList:ResultTypeList) =
    true .
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> (nil).List{Inst}
TList':List{TypeToken} --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i32
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(block type "$type2"
 br 0
 call "$factorial"
 end, i64, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(nil, i64 (nil).List{TypeToken}, i32, i64, ("$type0" |-> 0, "$type1"
    |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** equation
eq verify-IL(nil, TListRes:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true .
TListRes:List{TypeToken} --> i64
TList1:List{TypeToken} --> i32
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(nil, i64, i32, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2),
    (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param
    i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
eq get-localsTList(local TList:List{TypeToken}) = TList:List{TypeToken} .
TList:List{TypeToken} --> (nil).List{TypeToken}
get-localsTList(local nil)
--->
(nil).List{TypeToken}
*********** equation
eq get-resultlistTList-func(FuncDef:FuncDef) = aux-get-resultlistTList(
    get-resultlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-resultlistTList(get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-resultlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** equation
eq reverse(L:List{TypeToken}) = $reverse(L:List{TypeToken}, nil) .
L:List{TypeToken} --> i64
reverse(i64)
--->
$reverse(i64, (nil).List{TypeToken})
*********** equation
eq $reverse(E:TypeToken L:List{TypeToken}, A:List{TypeToken}) = $reverse(
    L:List{TypeToken}, E:TypeToken A:List{TypeToken}) .
E:TypeToken --> i64
L:List{TypeToken} --> (nil).List{TypeToken}
A:List{TypeToken} --> (nil).List{TypeToken}
$reverse(i64, (nil).List{TypeToken})
--->
$reverse((nil).List{TypeToken}, i64 (nil).List{TypeToken})
*********** equation
eq $reverse((nil).List{TypeToken}, A:List{TypeToken}) = A:List{TypeToken} .
A:List{TypeToken} --> i64
$reverse((nil).List{TypeToken}, i64)
--->
i64
*********** equation
eq get-resultlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
result i64
*********** equation
eq verify-IL(IntT:IntTypeToken .const IntN:Int
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, IntT:IntTypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
IntT:IntTypeToken --> i64
IntN:Int --> (0).Zero
IL:List{Inst} --> local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1" |-> 1,
    "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** trial #378
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
T:TypeToken --> (unbound)
*********** solving condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
*********** equation
eq nthT(T:TypeToken TList:List{TypeToken}, 0) = T:TypeToken .
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
nthT(i64, 0)
--->
i64
*********** success for condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
T:TypeToken --> i64
*********** success #378
*********** equation
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
T:TypeToken --> i64
verify-IL(local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** equation
eq verify-IL(T:TypeToken . relopT:RelopToken
 IL:List{Inst}, T:TypeToken T:TypeToken TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, i32 TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
T:TypeToken --> i64
relopT:RelopToken --> eq
IL:List{Inst} --> if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL(if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i32 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1" |-> 1,
    "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
*********** equation
eq verify-IL(if BlockType:BlockType
 IL1:List{Inst} else
 IL2:List{Inst} end IL:List{Inst}, i32 TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL((block BlockType:BlockType
 IL1:List{Inst} end) IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, getResultType(BlockType:BlockType),
    LabelsResultTypeList:ResultTypeList) and verify-IL((block
    BlockType:BlockType
 IL2:List{Inst} end) IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, getResultType(BlockType:BlockType),
    LabelsResultTypeList:ResultTypeList) .
BlockType:BlockType --> result i64
IL1:List{Inst} --> i64 .const (1).NzNat

IL2:List{Inst} --> local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> result i64
verify-IL(if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, i32, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    result i64)
--->
verify-IL((block (result i64)
 i64 .const (1).NzNat
 end) nil, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    getResultType(result i64), (result i64)) and verify-IL((block (result i64)
 (local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
) end) nil, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1),
    getResultType(result i64), (result i64))
*********** equation
eq getResultType(result TList2:List{TypeToken}) = result TList2:List{TypeToken}
    .
TList2:List{TypeToken} --> i64
getResultType(result i64)
--->
result i64
*********** trial #379
ceq verify-IL(block ResultType:ResultType
 IL2:List{Inst} end IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, aux-get-resultlistTList(ResultType:ResultType)
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if verify-IL(IL2:List{Inst}, nil,
    TList1:List{TypeToken}, aux-get-resultlistTList(ResultType:ResultType),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    ResultType:ResultType, LabelsResultTypeList:ResultTypeList) = true .
ResultType:ResultType --> result i64
IL2:List{Inst} --> i64 .const (1).NzNat

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** solving condition fragment
verify-IL(IL2:List{Inst}, nil, TList1:List{TypeToken}, aux-get-resultlistTList(
    ResultType:ResultType), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, ResultType:ResultType, LabelsResultTypeList:ResultTypeList) =
    true
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** equation
eq verify-IL(IntT:IntTypeToken .const IntN:Int
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, IntT:IntTypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(i64 .const (1).NzNat
, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type
    "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (result
    i64)), 2 |-> type "$type2" (func (param i64) (result i64))), ("$factorial"
    |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(nil, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1"
    |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq verify-IL(nil, TListRes:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true .
TListRes:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(nil, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2),
    (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param
    i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
true
*********** success for condition fragment
verify-IL(IL2:List{Inst}, nil, TList1:List{TypeToken}, aux-get-resultlistTList(
    ResultType:ResultType), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, ResultType:ResultType, LabelsResultTypeList:ResultTypeList) =
    true
ResultType:ResultType --> result i64
IL2:List{Inst} --> i64 .const (1).NzNat

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** success #379
*********** equation
ceq verify-IL(block ResultType:ResultType
 IL2:List{Inst} end IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, aux-get-resultlistTList(ResultType:ResultType)
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if verify-IL(IL2:List{Inst}, nil,
    TList1:List{TypeToken}, aux-get-resultlistTList(ResultType:ResultType),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    ResultType:ResultType, LabelsResultTypeList:ResultTypeList) = true .
ResultType:ResultType --> result i64
IL2:List{Inst} --> i64 .const (1).NzNat

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(block (result i64)
 i64 .const (1).NzNat
 end, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
verify-IL(nil, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1"
    |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
*********** equation
eq verify-IL(nil, TListRes:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true .
TListRes:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(nil, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2),
    (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param
    i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
true
*********** trial #380
ceq verify-IL(block ResultType:ResultType
 IL2:List{Inst} end IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, aux-get-resultlistTList(ResultType:ResultType)
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if verify-IL(IL2:List{Inst}, nil,
    TList1:List{TypeToken}, aux-get-resultlistTList(ResultType:ResultType),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    ResultType:ResultType, LabelsResultTypeList:ResultTypeList) = true .
ResultType:ResultType --> result i64
IL2:List{Inst} --> local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** solving condition fragment
verify-IL(IL2:List{Inst}, nil, TList1:List{TypeToken}, aux-get-resultlistTList(
    ResultType:ResultType), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, ResultType:ResultType, LabelsResultTypeList:ResultTypeList) =
    true
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** trial #381
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> (unbound)
*********** solving condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
*********** equation
eq nthT(T:TypeToken TList:List{TypeToken}, 0) = T:TypeToken .
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
nthT(i64, 0)
--->
i64
*********** success for condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
ValR:ValRef --> (0).Zero
IL:List{Inst} --> local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> i64
*********** success #381
*********** equation
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> i64
verify-IL(local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type
    "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (result
    i64)), 2 |-> type "$type2" (func (param i64) (result i64))), ("$factorial"
    |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1" |-> 1,
    "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** trial #382
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> (unbound)
*********** solving condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
*********** equation
eq nthT(T:TypeToken TList:List{TypeToken}, 0) = T:TypeToken .
T:TypeToken --> i64
TList:List{TypeToken} --> (nil).List{TypeToken}
nthT(i64, 0)
--->
i64
*********** success for condition fragment
T:TypeToken := nthT(TList1:List{TypeToken}, ValR:ValRef)
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> i64
*********** success #382
*********** equation
ceq verify-IL(local.get ValR:ValRef
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if T:TypeToken := nthT(
    TList1:List{TypeToken}, ValR:ValRef) .
ValR:ValRef --> (0).Zero
IL:List{Inst} --> i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
T:TypeToken --> i64
verify-IL(local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type
    "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (result
    i64)), 2 |-> type "$type2" (func (param i64) (result i64))), ("$factorial"
    |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq verify-IL(IntT:IntTypeToken .const IntN:Int
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(IL:List{
    Inst}, IntT:IntTypeToken TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
IntT:IntTypeToken --> i64
IntN:Int --> (1).NzNat
IL:List{Inst} --> i64 . sub
 call "$factorial"
 i64 . mul

TList:List{TypeToken} --> i64 i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(i64 . sub
 call "$factorial"
 i64 . mul
, i64 i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq verify-IL(T:TypeToken . binopT:BinopToken
 IL:List{Inst}, T:TypeToken T:TypeToken TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) .
T:TypeToken --> i64
binopT:BinopToken --> sub
IL:List{Inst} --> call "$factorial"
 i64 . mul

TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(i64 . sub
 call "$factorial"
 i64 . mul
, i64 i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0
    |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64)
    (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(call "$factorial"
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq verify-IL(call Str:String
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = verify-IL(call
    IndFuncCtxSTR:Map{String,Addr}[Str:String]
 IL:List{Inst}, TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{
    TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) .
Str:String --> "$factorial"
IL:List{Inst} --> i64 . mul

TList:List{TypeToken} --> i64 i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(call "$factorial"
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(call ("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)[
    "$factorial"]
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$start" |-> (1).NzNat
D:String --> "$factorial"
R:Addr --> (0).Zero
("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$factorial"]
--->
if $hasMapping("$start" |-> (1).NzNat, "$factorial") then (undefined).Rat else
    (0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$start" |-> (1).NzNat
D:String --> "$factorial"
$hasMapping("$start" |-> (1).NzNat, "$factorial")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** trial #383
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, TList':List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, get-resultlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TList':List{
    TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[
    Addr:Addr]) = true .
Addr:Addr --> (0).Zero
IL:List{Inst} --> i64 . mul

TList':List{TypeToken} --> (nil).List{TypeToken}
TList:List{TypeToken} --> i64 i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
*********** solving condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)[(0).Zero]
--->
if $hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero) then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
--->

func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
(built-in equation for symbol _==_)
(nil).List{TypeToken} == i64
--->
false
*********** failure for condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** failure #383
*********** trial #384
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, TList':List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, get-resultlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TList':List{
    TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[
    Addr:Addr]) = true .
Addr:Addr --> (0).Zero
IL:List{Inst} --> i64 . mul

TList':List{TypeToken} --> i64
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
*********** solving condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
R:ModuleContent --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)[(0).Zero]
--->
if $hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero) then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
, (0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
 fi
--->

func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-paramlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-paramlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ParamType:ParamType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-paramlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
(built-in equation for symbol _==_)
i64 == i64
--->
true
*********** success for condition fragment
TList':List{TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) = true
Addr:Addr --> (0).Zero
IL:List{Inst} --> i64 . mul

TList':List{TypeToken} --> i64
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
*********** success #384
*********** equation
ceq verify-IL(call Addr:Addr
 IL:List{Inst}, TList':List{TypeToken} TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, get-resultlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]) TList:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) if TList':List{
    TypeToken} == get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[
    Addr:Addr]) = true .
Addr:Addr --> (0).Zero
IL:List{Inst} --> i64 . mul

TList':List{TypeToken} --> i64
TList:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(call (0).Zero
 i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(i64 . mul
, get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
) i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |-> type
    "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (result
    i64)), 2 |-> type "$type2" (func (param i64) (result i64))), ("$factorial"
    |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq get-resultlistTList-func(FuncDef:FuncDef) = aux-get-resultlistTList(
    get-resultlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst

get-resultlistTList-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
aux-get-resultlistTList(get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
))
*********** equation
eq get-resultlist-func(
func Str:String ParamType:ParamType ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$factorial"
ParamType:ParamType --> param i64
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local nil
IL:List{Inst} --> i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
get-resultlist-func(
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
)
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** equation
eq verify-IL(T:TypeToken . binopT:BinopToken
 IL:List{Inst}, T:TypeToken T:TypeToken TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, T:TypeToken TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) .
T:TypeToken --> i64
binopT:BinopToken --> mul
IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(i64 . mul
, i64 i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
verify-IL(nil, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1"
    |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
*********** equation
eq verify-IL(nil, TListRes:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true .
TListRes:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64), (result
    i64)
verify-IL(nil, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2),
    (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param
    i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64), (result i64))
--->
true
*********** success for condition fragment
verify-IL(IL2:List{Inst}, nil, TList1:List{TypeToken}, aux-get-resultlistTList(
    ResultType:ResultType), IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, ResultType:ResultType, LabelsResultTypeList:ResultTypeList) =
    true
ResultType:ResultType --> result i64
IL2:List{Inst} --> local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
*********** success #380
*********** equation
ceq verify-IL(block ResultType:ResultType
 IL2:List{Inst} end IL:List{Inst}, TList:List{TypeToken}, TList1:List{
    TypeToken}, TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr},
    FuncStore:Map{Addr,ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance},
    GlobalAddrs:Map{String,Addr}, LabelsResultTypeList:ResultTypeList) =
    verify-IL(IL:List{Inst}, aux-get-resultlistTList(ResultType:ResultType)
    TList:List{TypeToken}, TList1:List{TypeToken}, TListRes:List{TypeToken},
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    LabelsResultTypeList:ResultTypeList) if verify-IL(IL2:List{Inst}, nil,
    TList1:List{TypeToken}, aux-get-resultlistTList(ResultType:ResultType),
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent},
    IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,ModuleContent},
    GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{String,Addr},
    ResultType:ResultType, LabelsResultTypeList:ResultTypeList) = true .
ResultType:ResultType --> result i64
IL2:List{Inst} --> local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul

IL:List{Inst} --> (nil).List{Inst}
TList:List{TypeToken} --> (nil).List{TypeToken}
TList1:List{TypeToken} --> i64
TListRes:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(block (result i64)
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end, nil, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
verify-IL(nil, i64 (nil).List{TypeToken}, i64, i64, ("$type0" |-> 0, "$type1"
    |-> 1, "$type2" |-> 2), (0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64))), ("$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
*********** equation
eq verify-IL(nil, TListRes:List{TypeToken}, TList1:List{TypeToken},
    TListRes:List{TypeToken}, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{
    Addr,ModuleContent}, IndFuncCtxSTR:Map{String,Addr}, FuncStore:Map{Addr,
    ModuleContent}, GlobalsStore:Map{Addr,GlobalInstance}, GlobalAddrs:Map{
    String,Addr}, LabelsResultTypeList:ResultTypeList) = true .
TListRes:List{TypeToken} --> i64
TList1:List{TypeToken} --> i64
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
IndFuncCtxSTR:Map{String,Addr} --> "$factorial" |-> (0).Zero, "$start" |-> (
    1).NzNat
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst

GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
LabelsResultTypeList:ResultTypeList --> (result i64), (result i64)
verify-IL(nil, i64, i64, i64, ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2),
    (0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param
    i64) (result i64)), 2 |-> type "$type2" (func (param i64) (result i64))), (
    "$factorial" |-> 0, "$start" |-> 1), (0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
), (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))}), ("$gb1" |-> 0, "$result" |-> 1), (
    result i64), (result i64))
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** equation
(built-in equation for symbol if_then_else_fi)
if true then 
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
simulate-wasm({typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {
    funcIndCtx "$factorial" |-> 0, "$start" |-> 1} 
< call ("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$start"]
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
#

 else Fail("Invalid module") fi
--->

{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
simulate-wasm({typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {
    funcIndCtx "$factorial" |-> 0, "$start" |-> 1} 
< call ("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$start"]
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
#


*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$factorial" |-> (0).Zero
D:String --> "$start"
R:Addr --> (1).NzNat
("$factorial" |-> (0).Zero, "$start" |-> (1).NzNat)["$start"]
--->
if $hasMapping("$factorial" |-> (0).Zero, "$start") then (undefined).Rat else (
    1).NzNat fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$factorial" |-> (0).Zero
D:String --> "$start"
$hasMapping("$factorial" |-> (0).Zero, "$start")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (1).NzNat fi
--->
(1).NzNat
*********** equation
eq simulate-wasm(WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim) =
    WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim .
WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim --> {typeIndCtx "$type0" |->
    0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx "$factorial" |-> 0, "$start"
    |-> 1} 
< call (1).NzNat
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))
simulate-wasm({typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {
    funcIndCtx "$factorial" |-> 0, "$start" |-> 1} 
< call (1).NzNat
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
--->
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< call (1).NzNat
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))
*********** equation
(built-in equation for symbol upTerm)
upTerm(
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< call (1).NzNat
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#

)
--->
'__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3['0.Zero],
    's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['_`,_['_|->_['"$type0".String, '0.Zero], '_|->_[
    '"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String, 's_^2[
    '0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_['"$factorial".String,
    '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]], '_#_['_#_['<_|_|_>[
    'call_['s_['0.Zero]], 'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]]]]]]]
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val((1).NzNat)
Value: const(i64, val((1).NzNat)) becomes IntValue
*********** rule
rl [call] : 
< call Addr:Addr
 IL:List{Inst} | ST:Stack | LocalSTRList:List{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} => 
< get-IL-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr]) exit-func(
    get-resultlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr]))
    exit-block(IL:List{Inst}) | label("func", nil, size(
    get-resultlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr])))
$ st-popN(ST:Stack, size(get-paramlistTList-func(FuncStore:Map{Addr,
    ModuleContent}[Addr:Addr]))) | init-store(get-paramlistTList-func(
    FuncStore:Map{Addr,ModuleContent}[Addr:Addr]) get-localsTList-func(
    FuncStore:Map{Addr,ModuleContent}[Addr:Addr]), st-getTopVals(ST:Stack,
    get-paramlistTList-func(FuncStore:Map{Addr,ModuleContent}[Addr:Addr])),
    empty) LocalSTRList:List{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} .
Addr:Addr --> (1).NzNat
IL:List{Inst} --> (nil).List{Inst}
ST:Stack --> EmptyStack
LocalSTRList:List{Map{ValRef,Value}} --> (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {type mut i64,
    value const(i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end


< call (1).NzNat
 | EmptyStack | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->

< get-IL-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1]) exit-func(get-resultlistTList-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1])) exit-block(nil) | label("func", nil, size(get-resultlistTList-func((0
    |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1])))
$ st-popN(EmptyStack, size(get-paramlistTList-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1]))) | init-store(get-paramlistTList-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1]) get-localsTList-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1]), st-getTopVals(EmptyStack, get-paramlistTList-func((0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[1])), empty) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end

D:Addr --> (1).NzNat
R:ModuleContent --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)[(1).NzNat]
--->
if $hasMapping((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat) then (undefined).FuncDefList else 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
 fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end

D:Addr --> (1).NzNat
$hasMapping((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
 fi
--->

func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

*********** equation
eq get-IL-func(
func Str:String FuncTypeDef:FuncTypeDef
  LocalsRef:LocalsRef
IL:List{Inst}
) = IL:List{Inst} .
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
get-IL-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
*********** equation
eq get-resultlistTList-func(FuncDef:FuncDef) = aux-get-resultlistTList(
    get-resultlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

get-resultlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
aux-get-resultlistTList(get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
))
*********** equation
eq get-resultlist-func(
func Str:String ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = ResultType:ResultType .
Str:String --> "$start"
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
get-resultlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** equation
eq size(L:List{TypeToken}) = $size(L:List{TypeToken}, (0).Zero) .
L:List{TypeToken} --> i64
size(i64)
--->
$size(i64, (0).Zero)
*********** equation
eq $size(E:TypeToken L:List{TypeToken}, C:Nat) = $size(L:List{TypeToken}, C:Nat
    + (1).NzNat) .
E:TypeToken --> i64
L:List{TypeToken} --> (nil).List{TypeToken}
C:Nat --> (0).Zero
$size(i64, (0).Zero)
--->
$size((nil).List{TypeToken}, (0).Zero + (1).NzNat)
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq $size((nil).List{TypeToken}, C:Nat) = C:Nat .
C:Nat --> (1).NzNat
$size((nil).List{TypeToken}, (1).NzNat)
--->
(1).NzNat
*********** equation
eq get-paramlistTList-func(FuncDef:FuncDef) = aux-get-paramlistTList(
    get-paramlist-func(FuncDef:FuncDef)) .
FuncDef:FuncDef --> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

get-paramlistTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
aux-get-paramlistTList(get-paramlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
))
*********** equation
eq get-paramlist-func(
func Str:String ResultType:ResultType
  LocalsRef:LocalsRef
IL:List{Inst}
) = param nil .
Str:String --> "$start"
ResultType:ResultType --> result i64
LocalsRef:LocalsRef --> local i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
get-paramlist-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
param nil
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> (nil).List{TypeToken}
aux-get-paramlistTList(param nil)
--->
(nil).List{TypeToken}
*********** equation
eq size(L:List{TypeToken}) = $size(L:List{TypeToken}, (0).Zero) .
L:List{TypeToken} --> (nil).List{TypeToken}
size((nil).List{TypeToken})
--->
$size((nil).List{TypeToken}, (0).Zero)
*********** equation
eq $size((nil).List{TypeToken}, C:Nat) = C:Nat .
C:Nat --> (0).Zero
$size((nil).List{TypeToken}, (0).Zero)
--->
(0).Zero
*********** equation
eq st-popN(ST:Stack, 0) = ST:Stack .
ST:Stack --> EmptyStack
st-popN(EmptyStack, 0)
--->
EmptyStack
*********** equation
eq get-localsTList-func(
func Str:String FuncTypeDef:FuncTypeDef
  (local TList:List{TypeToken})
IL:List{Inst}
) = TList:List{TypeToken} .
Str:String --> "$start"
FuncTypeDef:FuncTypeDef --> result i64
TList:List{TypeToken} --> i32
IL:List{Inst} --> i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
get-localsTList-func(
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->
i32
*********** equation
eq st-getTopVals(ST:Stack, nil) = EmptyStack .
ST:Stack --> EmptyStack
st-getTopVals(EmptyStack, nil)
--->
EmptyStack
*********** equation
eq init-store(NeTList:NeList{TypeToken}, ST:Stack, LocalSTR:Map{ValRef,Value})
    = inizialize-store(0, NeTList:NeList{TypeToken}, ST:Stack, LocalSTR:Map{
    ValRef,Value}) .
NeTList:NeList{TypeToken} --> i32
ST:Stack --> EmptyStack
LocalSTR:Map{ValRef,Value} --> (empty).Map{ValRef,Value}
init-store(i32, EmptyStack, empty)
--->
inizialize-store(0, i32, EmptyStack, empty)
*********** equation
eq inizialize-store(N:Nat, T:TypeToken TList:List{TypeToken}, EmptyStack,
    LocalSTR:Map{ValRef,Value}) = insert(N:Nat, defaultVal(T:TypeToken),
    inizialize-store(N:Nat + 1, TList:List{TypeToken}, EmptyStack,
    LocalSTR:Map{ValRef,Value})) .
N:Nat --> (0).Zero
T:TypeToken --> i32
TList:List{TypeToken} --> (nil).List{TypeToken}
LocalSTR:Map{ValRef,Value} --> (empty).Map{ValRef,Value}
inizialize-store(0, i32, EmptyStack, empty)
--->
insert((0).Zero, defaultVal(i32), inizialize-store(0 + 1, nil, EmptyStack,
    empty))
*********** equation
eq defaultVal(IntT:IntTypeToken) = const(IntT:IntTypeToken, val((0).Zero)) .
IntT:IntTypeToken --> i32
defaultVal(i32)
--->
const(i32, val((0).Zero))
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i32
ValWrapper:ValWrapper --> val((0).Zero)
Value: const(i32, val((0).Zero)) becomes IntValue
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq inizialize-store(N:Nat, nil, ST:Stack, LocalSTR:Map{ValRef,Value}) =
    LocalSTR:Map{ValRef,Value} .
N:Nat --> (1).NzNat
ST:Stack --> EmptyStack
LocalSTR:Map{ValRef,Value} --> (empty).Map{ValRef,Value}
inizialize-store(1, nil, EmptyStack, empty)
--->
(empty).Map{ValRef,Value}
*********** equation
eq insert(D:ValRef, R:Value, M:Map{ValRef,Value}) = M:Map{ValRef,Value},
    D:ValRef |-> R:Value [owise] .
D:ValRef --> (0).Zero
R:Value --> const(i32, val((0).Zero))
M:Map{ValRef,Value} --> (empty).Map{ValRef,Value}
insert((0).Zero, const(i32, val((0).Zero)), (empty).Map{ValRef,Value})
--->
(empty).Map{ValRef,Value}, (0).Zero |-> const(i32, val((0).Zero))
*********** trial #385
crl [int-const-signed] : 
< IntT:IntTypeToken .const IntN:Int
 IL:List{Inst} | ST:Stack | LocalSTRList:List{Map{ValRef,Value}} > => 
< IL:List{Inst} | st-push(ST:Stack, const(IntT:IntTypeToken, ValW1:ValWrapper))
    | LocalSTRList:List{Map{ValRef,Value}} > if ValW1:ValWrapper := unsigned(
    val(IntN:Int), bit-width(IntT:IntTypeToken)) .
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ValW1:ValWrapper --> (unbound)
*********** solving condition fragment
ValW1:ValWrapper := unsigned(val(IntN:Int), bit-width(IntT:IntTypeToken))
*********** equation
eq bit-width(T:TypeToken) = 64 [owise] .
T:TypeToken --> i64
bit-width(i64)
--->
64
*********** trial #386
ceq unsigned(val(Int1:Int), N:Nat) = val(Int1:Int) if Int1:Int < 2 ^ (N:Nat - (
    1).NzNat) and (0).Zero <= Int1:Int = true .
Int1:Int --> 5
N:Nat --> 64
*********** solving condition fragment
Int1:Int < 2 ^ (N:Nat - (1).NzNat) and (0).Zero <= Int1:Int = true
*********** equation
(built-in equation for symbol _-_)
64 - (1).NzNat
--->
63
*********** equation
(built-in equation for symbol _^_)
2 ^ 63
--->
9223372036854775808
*********** equation
(built-in equation for symbol _<_)
5 < 9223372036854775808
--->
true
*********** equation
(built-in equation for symbol _<=_)
(0).Zero <= 5
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
Int1:Int < 2 ^ (N:Nat - (1).NzNat) and (0).Zero <= Int1:Int = true
Int1:Int --> 5
N:Nat --> 64
*********** success #386
*********** equation
ceq unsigned(val(Int1:Int), N:Nat) = val(Int1:Int) if Int1:Int < 2 ^ (N:Nat - (
    1).NzNat) and (0).Zero <= Int1:Int = true .
Int1:Int --> 5
N:Nat --> 64
unsigned(val(5), 64)
--->
val(5)
*********** success for condition fragment
ValW1:ValWrapper := unsigned(val(IntN:Int), bit-width(IntT:IntTypeToken))
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ValW1:ValWrapper --> val(5)
*********** success #385
*********** rule
crl [int-const-signed] : 
< IntT:IntTypeToken .const IntN:Int
 IL:List{Inst} | ST:Stack | LocalSTRList:List{Map{ValRef,Value}} > => 
< IL:List{Inst} | st-push(ST:Stack, const(IntT:IntTypeToken, ValW1:ValWrapper))
    | LocalSTRList:List{Map{ValRef,Value}} > if ValW1:ValWrapper := unsigned(
    val(IntN:Int), bit-width(IntT:IntTypeToken)) .
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ValW1:ValWrapper --> val(5)

< i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | label("func", nil, 1) | (0 |-> const(i32,
    val((0).Zero))) empty >
--->

< global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | st-push(label("func", nil, 1), const(i64,
    val(5))) | (0 |-> const(i32, val((0).Zero))) empty >
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val(5)
Value: const(i64, val(5)) becomes IntValue
*********** equation
eq st-push(ST:Stack, STElem:StackElem) = STElem:StackElem
$ ST:Stack .
ST:Stack --> label("func", nil, 1)
STElem:StackElem --> const(i64, val(5))
st-push(label("func", nil, 1), const(i64, val(5)))
--->
const(i64, val(5))
$ label("func", nil, 1)
*********** re-solving condition fragment
ValW1:ValWrapper := unsigned(val(IntN:Int), bit-width(IntT:IntTypeToken))
*********** failure for condition fragment
ValW1:ValWrapper := unsigned(val(IntN:Int), bit-width(IntT:IntTypeToken))
*********** failure #385
*********** trial #387
crl [int-const] : 
< IntT:IntTypeToken .const IntN:Int
 IL:List{Inst} | ST:Stack | LocalSTRList:List{Map{ValRef,Value}} > => 
< IL:List{Inst} | st-push(ST:Stack, const(IntT:IntTypeToken, val(IntN:Int))) |
    LocalSTRList:List{Map{ValRef,Value}} > if IntN:Int < 2 ^ bit-width(
    IntT:IntTypeToken) and (0).Zero <= IntN:Int = true .
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
*********** solving condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
*********** equation
eq bit-width(T:TypeToken) = 64 [owise] .
T:TypeToken --> i64
bit-width(i64)
--->
64
*********** equation
(built-in equation for symbol _^_)
2 ^ 64
--->
18446744073709551616
*********** equation
(built-in equation for symbol _<_)
5 < 18446744073709551616
--->
true
*********** equation
(built-in equation for symbol _<=_)
(0).Zero <= 5
--->
true
*********** equation
eq true and A:Bool = A:Bool .
A:Bool --> true
true and true
--->
true
*********** success for condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
*********** success #387
*********** rule
crl [int-const] : 
< IntT:IntTypeToken .const IntN:Int
 IL:List{Inst} | ST:Stack | LocalSTRList:List{Map{ValRef,Value}} > => 
< IL:List{Inst} | st-push(ST:Stack, const(IntT:IntTypeToken, val(IntN:Int))) |
    LocalSTRList:List{Map{ValRef,Value}} > if IntN:Int < 2 ^ bit-width(
    IntT:IntTypeToken) and (0).Zero <= IntN:Int = true .
IntT:IntTypeToken --> i64
IntN:Int --> 5
IL:List{Inst} --> global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
LocalSTRList:List{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}

< i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | label("func", nil, 1) | (0 |-> const(i32,
    val((0).Zero))) empty >
--->

< global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | st-push(label("func", nil, 1), const(i64,
    val(5))) | (0 |-> const(i32, val((0).Zero))) empty >
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val(5)
Value: const(i64, val(5)) becomes IntValue
*********** equation
eq st-push(ST:Stack, STElem:StackElem) = STElem:StackElem
$ ST:Stack .
ST:Stack --> label("func", nil, 1)
STElem:StackElem --> const(i64, val(5))
st-push(label("func", nil, 1), const(i64, val(5)))
--->
const(i64, val(5))
$ label("func", nil, 1)
*********** re-solving condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
*********** failure for condition fragment
IntN:Int < 2 ^ bit-width(IntT:IntTypeToken) and (0).Zero <= IntN:Int = true
*********** failure #387
*********** trial #388
crl [global.set] : 
< global.set Str:String
 IL:List{Inst} | const(T:TypeToken, ValW1:ValWrapper)
$ ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance} => 
< IL:List{Inst} | ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> insert(GlobalAddrs:Map{String,Addr}[
    Str:String], {type mut T:TypeToken, value const(T:TypeToken,
    ValW1:ValWrapper)}, GlobalsStore:Map{Addr,GlobalInstance}) if global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true .
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
T:TypeToken --> i64
ValW1:ValWrapper --> val(5)
ST:Stack --> label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
*********** solving condition fragment
global-type(GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
R:Addr --> (0).Zero
("$gb1" |-> (0).Zero, "$result" |-> (1).NzNat)["$gb1"]
--->
if $hasMapping("$result" |-> (1).NzNat, "$gb1") then (undefined).Rat else (
    0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
$hasMapping("$result" |-> (1).NzNat, "$gb1")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** equation
eq (M:Map{Addr,GlobalInstance}, D:Addr |-> R:GlobalInstance)[D:Addr] = if
    $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) then undefined else
    R:GlobalInstance fi .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
((0).Zero |-> {type mut i64, value const(i64, val((1).NzNat))}, (1).NzNat |-> {
    type mut i64, value const(i64, val((1).NzNat))})[(0).Zero]
--->
if $hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))},
    (0).Zero) then (undefined).GlobalInstance else {type mut i64, value const(
    i64, val((1).NzNat))} fi
*********** equation
eq $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) = false [owise] .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (
    0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).GlobalInstance else {type mut i64, value const(i64,
    val((1).NzNat))} fi
--->
{type mut i64, value const(i64, val((1).NzNat))}
*********** equation
eq global-type({type GlobalType:GlobalType, value Val:Value}) =
    GlobalType:GlobalType .
GlobalType:GlobalType --> mut i64
Val:Value --> const(i64, val((1).NzNat))
global-type({type mut i64, value const(i64, val((1).NzNat))})
--->
mut i64
*********** equation
(built-in equation for symbol _==_)
mut i64 == mut i64
--->
true
*********** success for condition fragment
global-type(GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
T:TypeToken --> i64
ValW1:ValWrapper --> val(5)
ST:Stack --> label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
*********** success #388
*********** rule
crl [global.set] : 
< global.set Str:String
 IL:List{Inst} | const(T:TypeToken, ValW1:ValWrapper)
$ ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance} => 
< IL:List{Inst} | ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> insert(GlobalAddrs:Map{String,Addr}[
    Str:String], {type mut T:TypeToken, value const(T:TypeToken,
    ValW1:ValWrapper)}, GlobalsStore:Map{Addr,GlobalInstance}) if global-type(
    GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true .
Str:String --> "$gb1"
IL:List{Inst} --> global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
T:TypeToken --> i64
ValW1:ValWrapper --> val(5)
ST:Stack --> label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}

< global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    (1).NzNat))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
--->

< global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | label("func", nil, 1) | (0 |-> const(i32,
    val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> insert(0, {type mut i64, value const(i64,
    val(5))}, (0 |-> {type mut i64, value const(i64, val((1).NzNat))}, 1 |-> {
    type mut i64, value const(i64, val((1).NzNat))}))
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val(5)
Value: const(i64, val(5)) becomes IntValue
*********** equation
eq insert(D:Addr, R:GlobalInstance, (M:Map{Addr,GlobalInstance}, D:Addr |->
    R':GlobalInstance)) = if $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr)
    then insert(D:Addr, R:GlobalInstance, M:Map{Addr,GlobalInstance}) else
    M:Map{Addr,GlobalInstance}, D:Addr |-> R:GlobalInstance fi .
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val(5))}
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
R':GlobalInstance --> {type mut i64, value const(i64, val((1).NzNat))}
insert((0).Zero, {type mut i64, value const(i64, val(5))}, ((0).Zero |-> {type
    mut i64, value const(i64, val((1).NzNat))}, (1).NzNat |-> {type mut i64,
    value const(i64, val((1).NzNat))}))
--->
if $hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))},
    (0).Zero) then insert((0).Zero, {type mut i64, value const(i64, val(5))}, (
    1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}) else (
    1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (0).Zero |->
    {type mut i64, value const(i64, val(5))} fi
*********** equation
eq $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) = false [owise] .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (
    0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then insert((0).Zero, {type mut i64, value const(i64, val(5))}, (
    1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}) else (
    1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (0).Zero |->
    {type mut i64, value const(i64, val(5))} fi
--->
(1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (0).Zero |-> {
    type mut i64, value const(i64, val(5))}
*********** re-solving condition fragment
global-type(GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true
*********** failure for condition fragment
global-type(GlobalsStore:Map{Addr,GlobalInstance}[GlobalAddrs:Map{String,Addr}[
    Str:String]]) == mut T:TypeToken = true
*********** failure #388
*********** rule
rl [global.get] : 
< global.get Str:String
 IL:List{Inst} | ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance} => 
< IL:List{Inst} | st-push(ST:Stack, global-val(GlobalsStore:Map{Addr,
    GlobalInstance}[GlobalAddrs:Map{String,Addr}[Str:String]])) |
    NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalAddrs:Map{String,Addr} <-> GlobalsStore:Map{Addr,GlobalInstance} .
Str:String --> "$gb1"
IL:List{Inst} --> block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil)
ST:Stack --> label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalAddrs:Map{String,Addr} --> "$gb1" |-> (0).Zero, "$result" |-> (1).NzNat
GlobalsStore:Map{Addr,GlobalInstance} --> (0).Zero |-> {type mut i64, value
    const(i64, val(5))}, (1).NzNat |-> {type mut i64, value const(i64, val((
    1).NzNat))}

< global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | label("func", nil, 1) | (0 |-> const(i32,
    val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
--->

< block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | st-push(label("func", nil, 1),
    global-val((0 |-> {type mut i64, value const(i64, val(5))}, 1 |-> {type mut
    i64, value const(i64, val((1).NzNat))})[("$gb1" |-> 0, "$result" |-> 1)[
    "$gb1"]])) | (0 |-> const(i32, val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
R:Addr --> (0).Zero
("$gb1" |-> (0).Zero, "$result" |-> (1).NzNat)["$gb1"]
--->
if $hasMapping("$result" |-> (1).NzNat, "$gb1") then (undefined).Rat else (
    0).Zero fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$result" |-> (1).NzNat
D:String --> "$gb1"
$hasMapping("$result" |-> (1).NzNat, "$gb1")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else (0).Zero fi
--->
(0).Zero
*********** equation
eq (M:Map{Addr,GlobalInstance}, D:Addr |-> R:GlobalInstance)[D:Addr] = if
    $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) then undefined else
    R:GlobalInstance fi .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
R:GlobalInstance --> {type mut i64, value const(i64, val(5))}
((0).Zero |-> {type mut i64, value const(i64, val(5))}, (1).NzNat |-> {type mut
    i64, value const(i64, val((1).NzNat))})[(0).Zero]
--->
if $hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))},
    (0).Zero) then (undefined).GlobalInstance else {type mut i64, value const(
    i64, val(5))} fi
*********** equation
eq $hasMapping(M:Map{Addr,GlobalInstance}, D:Addr) = false [owise] .
M:Map{Addr,GlobalInstance} --> (1).NzNat |-> {type mut i64, value const(i64,
    val((1).NzNat))}
D:Addr --> (0).Zero
$hasMapping((1).NzNat |-> {type mut i64, value const(i64, val((1).NzNat))}, (
    0).Zero)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).GlobalInstance else {type mut i64, value const(i64,
    val(5))} fi
--->
{type mut i64, value const(i64, val(5))}
*********** equation
eq global-val({type GlobalType:GlobalType, value Val:Value}) = Val:Value .
GlobalType:GlobalType --> mut i64
Val:Value --> const(i64, val(5))
global-val({type mut i64, value const(i64, val(5))})
--->
const(i64, val(5))
*********** equation
eq st-push(ST:Stack, STElem:StackElem) = STElem:StackElem
$ ST:Stack .
ST:Stack --> label("func", nil, 1)
STElem:StackElem --> const(i64, val(5))
st-push(label("func", nil, 1), const(i64, val(5)))
--->
const(i64, val(5))
$ label("func", nil, 1)
*********** trial #389
crl [block-tref] : {typeIndCtx IndTypeCtxSTR:Map{String,Addr}}
    IndFuncCtx:FuncIndCtx 
< block TypeRef:TypeRef
 IL2:List{Inst} end IL:List{Inst} | ST1:Stack | NeLocalSTRList:NeList{Map{
    ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent} => {typeIndCtx IndTypeCtxSTR:Map{String,
    Addr}} IndFuncCtx:FuncIndCtx 
< IL2:List{Inst} exit-block(IL:List{Inst}) | ST':Stack
$ label("block", nil, size(TListRes:List{TypeToken}))
$ ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent} if ST':Stack := st-getTopVals(ST1:Stack,
    aux-get-paramlistTList(getParamType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent})))) /\
    ST':Stack
$ ST:Stack := ST1:Stack /\ TListRes:List{TypeToken} := aux-get-resultlistTList(
    getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}))) .
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
ST':Stack --> (unbound)
ST:Stack --> (unbound)
TListRes:List{TypeToken} --> (unbound)
*********** solving condition fragment
ST':Stack := st-getTopVals(ST1:Stack, aux-get-paramlistTList(getParamType(
    expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))))
*********** equation
eq expand(type Str:String, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}) = get-functype-typedef(TypeStore:Map{Addr,ModuleContent}[
    IndTypeCtxSTR:Map{String,Addr}[Str:String]]) .
Str:String --> "$type2"
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
expand(type "$type2", ("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2), (0 |->
    type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64))))
--->
get-functype-typedef((0 |-> type "$type0" (func result i64), 1 |-> type
    "$type1" (func (param i64) (result i64)), 2 |-> type "$type2" (func (param
    i64) (result i64)))[("$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2)[
    "$type2"]])
*********** equation
eq (M:Map{String,Addr}, D:String |-> R:Addr)[D:String] = if $hasMapping(M:Map{
    String,Addr}, D:String) then undefined else R:Addr fi .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
D:String --> "$type2"
R:Addr --> 2
("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat, "$type2" |-> 2)["$type2"]
--->
if $hasMapping(("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat), "$type2") then
    (undefined).Rat else 2 fi
*********** equation
eq $hasMapping(M:Map{String,Addr}, D:String) = false [owise] .
M:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (1).NzNat
D:String --> "$type2"
$hasMapping(("$type0" |-> (0).Zero, "$type1" |-> (1).NzNat), "$type2")
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).Rat else 2 fi
--->
2
*********** equation
eq (M:Map{Addr,ModuleContent}, D:Addr |-> R:ModuleContent)[D:Addr] = if
    $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) then undefined else
    R:ModuleContent fi .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), (
    1).NzNat |-> type "$type1" (func (param i64) (result i64))
D:Addr --> 2
R:ModuleContent --> type "$type2" (func (param i64) (result i64))
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))[2]
--->
if $hasMapping(((0).Zero |-> type "$type0" (func result i64), (1).NzNat |->
    type "$type1" (func (param i64) (result i64))), 2) then (
    undefined).FuncDefList else type "$type2" (func (param i64) (result i64))
    fi
*********** equation
eq $hasMapping(M:Map{Addr,ModuleContent}, D:Addr) = false [owise] .
M:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result i64), (
    1).NzNat |-> type "$type1" (func (param i64) (result i64))
D:Addr --> 2
$hasMapping(((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type
    "$type1" (func (param i64) (result i64))), 2)
--->
false
*********** equation
(built-in equation for symbol if_then_else_fi)
if false then (undefined).FuncDefList else type "$type2" (func (param i64) (
    result i64)) fi
--->
type "$type2" (func (param i64) (result i64))
*********** equation
eq get-functype-typedef(type Str:String (func ParamResultType:ParamResultType))
    = ParamResultType:ParamResultType .
Str:String --> "$type2"
ParamResultType:ParamResultType --> (param i64) (result i64)
get-functype-typedef(type "$type2" (func (param i64) (result i64)))
--->
(param i64) (result i64)
*********** equation
eq getParamType((param TList1:List{TypeToken}) (result TList2:List{TypeToken}))
    = param TList1:List{TypeToken} .
TList1:List{TypeToken} --> i64
TList2:List{TypeToken} --> i64
getParamType((param i64) (result i64))
--->
param i64
*********** equation
eq aux-get-paramlistTList(param TList:List{TypeToken}) = TList:List{TypeToken}
    .
TList:List{TypeToken} --> i64
aux-get-paramlistTList(param i64)
--->
i64
*********** equation
eq st-getTopVals(const(T:TypeToken, ValW1:ValWrapper)
$ ST:Stack, T:TypeToken TList:List{TypeToken}) = const(T:TypeToken,
    ValW1:ValWrapper)
$ st-getTopVals(ST:Stack, TList:List{TypeToken}) .
T:TypeToken --> i64
ValW1:ValWrapper --> val(5)
ST:Stack --> label("func", nil, 1)
TList:List{TypeToken} --> (nil).List{TypeToken}
st-getTopVals(const(i64, val(5))
$ label("func", nil, 1), i64)
--->
const(i64, val(5))
$ st-getTopVals(label("func", nil, 1), nil)
*********** equation
eq st-getTopVals(ST:Stack, nil) = EmptyStack .
ST:Stack --> label("func", nil, 1)
st-getTopVals(label("func", nil, 1), nil)
--->
EmptyStack
*********** success for condition fragment
ST':Stack := st-getTopVals(ST1:Stack, aux-get-paramlistTList(getParamType(
    expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
ST':Stack --> const(i64, val(5))
ST:Stack --> (unbound)
TListRes:List{TypeToken} --> (unbound)
*********** solving condition fragment
ST':Stack
$ ST:Stack := ST1:Stack
*********** success for condition fragment
ST':Stack
$ ST:Stack := ST1:Stack
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
ST':Stack --> const(i64, val(5))
ST:Stack --> label("func", nil, 1)
TListRes:List{TypeToken} --> (unbound)
*********** solving condition fragment
TListRes:List{TypeToken} := aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent})))
*********** equation
eq getResultType((param TList1:List{TypeToken}) (result TList2:List{
    TypeToken})) = result TList2:List{TypeToken} .
TList1:List{TypeToken} --> i64
TList2:List{TypeToken} --> i64
getResultType((param i64) (result i64))
--->
result i64
*********** equation
eq aux-get-resultlistTList(result TList:List{TypeToken}) = TList:List{
    TypeToken} .
TList:List{TypeToken} --> i64
aux-get-resultlistTList(result i64)
--->
i64
*********** success for condition fragment
TListRes:List{TypeToken} := aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent})))
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
ST':Stack --> const(i64, val(5))
ST:Stack --> label("func", nil, 1)
TListRes:List{TypeToken} --> i64
*********** success #389
*********** rule
crl [block-tref] : {typeIndCtx IndTypeCtxSTR:Map{String,Addr}}
    IndFuncCtx:FuncIndCtx 
< block TypeRef:TypeRef
 IL2:List{Inst} end IL:List{Inst} | ST1:Stack | NeLocalSTRList:NeList{Map{
    ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent} => {typeIndCtx IndTypeCtxSTR:Map{String,
    Addr}} IndFuncCtx:FuncIndCtx 
< IL2:List{Inst} exit-block(IL:List{Inst}) | ST':Stack
$ label("block", nil, size(TListRes:List{TypeToken}))
$ ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent}
#
TypeStore:Map{Addr,ModuleContent} if ST':Stack := st-getTopVals(ST1:Stack,
    aux-get-paramlistTList(getParamType(expand(TypeRef:TypeRef,
    IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,ModuleContent})))) /\
    ST':Stack
$ ST:Stack := ST1:Stack /\ TListRes:List{TypeToken} := aux-get-resultlistTList(
    getResultType(expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr},
    TypeStore:Map{Addr,ModuleContent}))) .
IndTypeCtxSTR:Map{String,Addr} --> "$type0" |-> (0).Zero, "$type1" |-> (
    1).NzNat, "$type2" |-> 2
IndFuncCtx:FuncIndCtx --> {funcIndCtx "$factorial" |-> 0, "$start" |-> 1}
TypeRef:TypeRef --> type "$type2"
IL2:List{Inst} --> br 0
 call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

TypeStore:Map{Addr,ModuleContent} --> (0).Zero |-> type "$type0" (func result
    i64), (1).NzNat |-> type "$type1" (func (param i64) (result i64)), 2 |->
    type "$type2" (func (param i64) (result i64))
ST':Stack --> const(i64, val(5))
ST:Stack --> label("func", nil, 1)
TListRes:List{TypeToken} --> i64
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< block type "$type2"
 br 0
 call "$factorial"
 end exit-func(i64) exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
#
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))
--->
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< (br 0
 call "$factorial"
) exit-block(exit-func(i64) exit-block(nil)) | const(i64, val(5))
$ label("block", nil, size(i64))
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
#
((0).Zero |-> type "$type0" (func result i64), (1).NzNat |-> type "$type1" (
    func (param i64) (result i64)), 2 |-> type "$type2" (func (param i64) (
    result i64)))
*********** equation
eq size(L:List{TypeToken}) = $size(L:List{TypeToken}, (0).Zero) .
L:List{TypeToken} --> i64
size(i64)
--->
$size(i64, (0).Zero)
*********** equation
eq $size(E:TypeToken L:List{TypeToken}, C:Nat) = $size(L:List{TypeToken}, C:Nat
    + (1).NzNat) .
E:TypeToken --> i64
L:List{TypeToken} --> (nil).List{TypeToken}
C:Nat --> (0).Zero
$size(i64, (0).Zero)
--->
$size((nil).List{TypeToken}, (0).Zero + (1).NzNat)
*********** equation
(built-in equation for symbol _+_)
(0).Zero + (1).NzNat
--->
(1).NzNat
*********** equation
eq $size((nil).List{TypeToken}, C:Nat) = C:Nat .
C:Nat --> (1).NzNat
$size((nil).List{TypeToken}, (1).NzNat)
--->
(1).NzNat
*********** re-solving condition fragment
TListRes:List{TypeToken} := aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent})))
*********** failure for condition fragment
TListRes:List{TypeToken} := aux-get-resultlistTList(getResultType(expand(
    TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent})))
*********** re-solving condition fragment
ST':Stack
$ ST:Stack := ST1:Stack
*********** failure for condition fragment
ST':Stack
$ ST:Stack := ST1:Stack
*********** re-solving condition fragment
ST':Stack := st-getTopVals(ST1:Stack, aux-get-paramlistTList(getParamType(
    expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))))
*********** failure for condition fragment
ST':Stack := st-getTopVals(ST1:Stack, aux-get-paramlistTList(getParamType(
    expand(TypeRef:TypeRef, IndTypeCtxSTR:Map{String,Addr}, TypeStore:Map{Addr,
    ModuleContent}))))
*********** failure #389
*********** trial #390
crl [br] : 
< br N:Nat
 IL2:List{Inst} exit-block(IL:List{Inst}) IL':List{Inst} | ST:Stack |
    NeLocalSTRList:NeList{Map{ValRef,Value}} > => 
< IL1:List{Inst} IL:List{Inst} | ST1:Stack | NeLocalSTRList:NeList{Map{ValRef,
    Value}} > if ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack) .
N:Nat --> (0).Zero
IL2:List{Inst} --> call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
IL':List{Inst} --> (nil).List{Inst}
ST:Stack --> const(i64, val(5))
$ label("block", nil, 1)
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ST1:Stack --> (unbound)
Str:String --> (unbound)
IL1:List{Inst} --> (unbound)
N1:Nat --> (unbound)
*********** solving condition fragment
ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack)
*********** equation
eq get-ith-stackandlabel(Val:Value
$ ST:Stack, N:Nat, TempST:Stack) = get-ith-stackandlabel(ST:Stack, N:Nat,
    TempST:Stack
$ Val:Value) .
Val:Value --> const(i64, val(5))
ST:Stack --> label("block", nil, 1)
$ label("func", nil, 1)
N:Nat --> (0).Zero
TempST:Stack --> EmptyStack
get-ith-stackandlabel(const(i64, val(5))
$ label("block", nil, 1)
$ label("func", nil, 1), 0, EmptyStack)
--->
get-ith-stackandlabel(label("block", nil, 1)
$ label("func", nil, 1), 0, EmptyStack
$ const(i64, val(5)))
*********** equation
eq get-ith-stackandlabel(label(Str:String, IL:List{Inst}, N:Nat)
$ ST:Stack, 0, TempST:Stack) = (reset-st-res(TempST:Stack, N:Nat)
$ ST:Stack) || label(Str:String, IL:List{Inst}, N:Nat) .
Str:String --> "block"
IL:List{Inst} --> (nil).List{Inst}
N:Nat --> (1).NzNat
ST:Stack --> label("func", nil, 1)
TempST:Stack --> const(i64, val(5))
get-ith-stackandlabel(label("block", nil, 1)
$ label("func", nil, 1), 0, const(i64, val(5)))
--->
(reset-st-res(const(i64, val(5)), 1)
$ label("func", nil, 1)) || label("block", nil, 1)
*********** equation
eq reset-st-res(Val:Value
$ ST:Stack, NzN:NzNat) = Val:Value
$ reset-st-res(ST:Stack, NzN:NzNat - 1) .
Val:Value --> const(i64, val(5))
ST:Stack --> EmptyStack
NzN:NzNat --> (1).NzNat
reset-st-res(const(i64, val(5)), 1)
--->
const(i64, val(5))
$ reset-st-res(EmptyStack, 1 - 1)
*********** equation
(built-in equation for symbol _-_)
(1).NzNat - (1).NzNat
--->
(0).Zero
*********** equation
eq reset-st-res(EmptyStack, N:Nat) = EmptyStack .
N:Nat --> (0).Zero
reset-st-res(EmptyStack, 0)
--->
EmptyStack
*********** success for condition fragment
ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack)
N:Nat --> (0).Zero
IL2:List{Inst} --> call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
IL':List{Inst} --> (nil).List{Inst}
ST:Stack --> const(i64, val(5))
$ label("block", nil, 1)
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
Str:String --> "block"
IL1:List{Inst} --> (nil).List{Inst}
N1:Nat --> (1).NzNat
*********** success #390
*********** rule
crl [br] : 
< br N:Nat
 IL2:List{Inst} exit-block(IL:List{Inst}) IL':List{Inst} | ST:Stack |
    NeLocalSTRList:NeList{Map{ValRef,Value}} > => 
< IL1:List{Inst} IL:List{Inst} | ST1:Stack | NeLocalSTRList:NeList{Map{ValRef,
    Value}} > if ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack) .
N:Nat --> (0).Zero
IL2:List{Inst} --> call "$factorial"

IL:List{Inst} --> exit-func(i64) exit-block(nil)
IL':List{Inst} --> (nil).List{Inst}
ST:Stack --> const(i64, val(5))
$ label("block", nil, 1)
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> ((0).Zero |-> const(i32, val((
    0).Zero))) (empty).Map{ValRef,Value}
ST1:Stack --> const(i64, val(5))
$ label("func", nil, 1)
Str:String --> "block"
IL1:List{Inst} --> (nil).List{Inst}
N1:Nat --> (1).NzNat

< br 0
 call "$factorial"
 exit-block(exit-func(i64) exit-block(nil)) | const(i64, val(5))
$ label("block", nil, 1)
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
--->

< nil exit-func(i64) exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
*********** re-solving condition fragment
ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack)
*********** failure for condition fragment
ST1:Stack || label(Str:String, IL1:List{Inst}, N1:Nat) :=
    get-ith-stackandlabel(ST:Stack, N:Nat, EmptyStack)
*********** failure #390
*********** trial #391
crl [exit-func] : 
< exit-func(TypeTokenList:List{TypeToken}) IL:List{Inst} | ST:Stack |
    LocalSTR:Map{ValRef,Value} NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} => 
< IL:List{Inst} | ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} if valid-stack(ST:Stack, reverse(
    TypeTokenList:List{TypeToken})) = true .
TypeTokenList:List{TypeToken} --> i64
IL:List{Inst} --> exit-block(nil)
ST:Stack --> const(i64, val(5))
$ label("func", nil, 1)
LocalSTR:Map{ValRef,Value} --> (0).Zero |-> const(i32, val((0).Zero))
NeLocalSTRList:NeList{Map{ValRef,Value}} --> (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

*********** solving condition fragment
valid-stack(ST:Stack, reverse(TypeTokenList:List{TypeToken})) = true
*********** equation
eq reverse(L:List{TypeToken}) = $reverse(L:List{TypeToken}, nil) .
L:List{TypeToken} --> i64
reverse(i64)
--->
$reverse(i64, (nil).List{TypeToken})
*********** equation
eq $reverse(E:TypeToken L:List{TypeToken}, A:List{TypeToken}) = $reverse(
    L:List{TypeToken}, E:TypeToken A:List{TypeToken}) .
E:TypeToken --> i64
L:List{TypeToken} --> (nil).List{TypeToken}
A:List{TypeToken} --> (nil).List{TypeToken}
$reverse(i64, (nil).List{TypeToken})
--->
$reverse((nil).List{TypeToken}, i64 (nil).List{TypeToken})
*********** equation
eq $reverse((nil).List{TypeToken}, A:List{TypeToken}) = A:List{TypeToken} .
A:List{TypeToken} --> i64
$reverse((nil).List{TypeToken}, i64)
--->
i64
*********** equation
eq valid-stack(const(T:TypeToken, ValW1:ValWrapper)
$ ST:Stack, T:TypeToken TList:List{TypeToken}) = valid-stack(ST:Stack,
    TList:List{TypeToken}) .
T:TypeToken --> i64
ValW1:ValWrapper --> val(5)
ST:Stack --> label("func", nil, 1)
TList:List{TypeToken} --> (nil).List{TypeToken}
valid-stack(const(i64, val(5))
$ label("func", nil, 1), i64)
--->
valid-stack(label("func", nil, 1), nil)
*********** equation
eq valid-stack(ST:Stack, nil) = true .
ST:Stack --> label("func", nil, 1)
valid-stack(label("func", nil, 1), nil)
--->
true
*********** success for condition fragment
valid-stack(ST:Stack, reverse(TypeTokenList:List{TypeToken})) = true
TypeTokenList:List{TypeToken} --> i64
IL:List{Inst} --> exit-block(nil)
ST:Stack --> const(i64, val(5))
$ label("func", nil, 1)
LocalSTR:Map{ValRef,Value} --> (0).Zero |-> const(i32, val((0).Zero))
NeLocalSTRList:NeList{Map{ValRef,Value}} --> (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end

*********** success #391
*********** rule
crl [exit-func] : 
< exit-func(TypeTokenList:List{TypeToken}) IL:List{Inst} | ST:Stack |
    LocalSTR:Map{ValRef,Value} NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} => 
< IL:List{Inst} | ST:Stack | NeLocalSTRList:NeList{Map{ValRef,Value}} >
#
GlobalInventory:GlobalInventory
#
FuncStore:Map{Addr,ModuleContent} if valid-stack(ST:Stack, reverse(
    TypeTokenList:List{TypeToken})) = true .
TypeTokenList:List{TypeToken} --> i64
IL:List{Inst} --> exit-block(nil)
ST:Stack --> const(i64, val(5))
$ label("func", nil, 1)
LocalSTR:Map{ValRef,Value} --> (0).Zero |-> const(i32, val((0).Zero))
NeLocalSTRList:NeList{Map{ValRef,Value}} --> (empty).Map{ValRef,Value}
GlobalInventory:GlobalInventory --> ("$gb1" |-> 0, "$result" |-> 1) <-> (0 |->
    {type mut i64, value const(i64, val(5))}, 1 |-> {type mut i64, value const(
    i64, val((1).NzNat))})
FuncStore:Map{Addr,ModuleContent} --> (0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end


< exit-func(i64) exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | (0 |-> const(i32, val((0).Zero))) empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
--->

< exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
((0).Zero |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 end
, (1).NzNat |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 end
)
*********** re-solving condition fragment
valid-stack(ST:Stack, reverse(TypeTokenList:List{TypeToken})) = true
*********** failure for condition fragment
valid-stack(ST:Stack, reverse(TypeTokenList:List{TypeToken})) = true
*********** failure #391
*********** rule
rl [end] : 
< exit-block(IL:List{Inst}) | NeST:NeStack | NeLocalSTRList:NeList{Map{ValRef,
    Value}} > => 
< IL:List{Inst} | get-st(reset-st(NeST:NeStack)) | NeLocalSTRList:NeList{Map{
    ValRef,Value}} > .
IL:List{Inst} --> (nil).List{Inst}
NeST:NeStack --> const(i64, val(5))
$ label("func", nil, 1)
NeLocalSTRList:NeList{Map{ValRef,Value}} --> (empty).Map{ValRef,Value}

< exit-block(nil) | const(i64, val(5))
$ label("func", nil, 1) | empty >
--->

< nil | get-st(reset-st(const(i64, val(5))
$ label("func", nil, 1))) | empty >
*********** equation
eq reset-st(Val:Value
$ ST:Stack) = (Val:Value
$ get-st(reset-st(ST:Stack))) || get-label(reset-st(ST:Stack)) .
Val:Value --> const(i64, val(5))
ST:Stack --> label("func", nil, 1)
reset-st(const(i64, val(5))
$ label("func", nil, 1))
--->
(const(i64, val(5))
$ get-st(reset-st(label("func", nil, 1)))) || get-label(reset-st(label("func",
    nil, 1)))
*********** equation
eq reset-st(Label:Label
$ ST:Stack) = ST:Stack || Label:Label .
Label:Label --> label("func", nil, 1)
ST:Stack --> EmptyStack
reset-st(label("func", nil, 1))
--->
EmptyStack || label("func", nil, 1)
*********** equation
eq get-st(ST:Stack || Label:Label) = ST:Stack .
ST:Stack --> EmptyStack
Label:Label --> label("func", nil, 1)
get-st(EmptyStack || label("func", nil, 1))
--->
EmptyStack
*********** equation
eq get-label(ST:Stack || Label:Label) = Label:Label .
ST:Stack --> EmptyStack
Label:Label --> label("func", nil, 1)
get-label(EmptyStack || label("func", nil, 1))
--->
label("func", nil, 1)
*********** equation
eq get-st(ST:Stack || Label:Label) = ST:Stack .
ST:Stack --> const(i64, val(5))
Label:Label --> label("func", nil, 1)
get-st(const(i64, val(5)) || label("func", nil, 1))
--->
const(i64, val(5))
*********** equation
(built-in equation for symbol metaSearch)
metaSearch(mod 'WASMMOD is
  including 'BOOL .
  protecting 'WASM-MODULECONTENT-MOD .
  protecting 'WASM-VERIFYFUNCDEF-MOD .
  protecting 'MAP{'ValRef, 'Value} .
  protecting 'LIST{'Map{'ValRef, 'Value}} .
  protecting 'MAP{'String, 'Addr} .
  protecting 'MAP{'Addr, 'GlobalInstance} .
  sorts 'ComponentCtr ; 'EmptyStack ; 'FuncIndCtx ; 'FuncStore ; 'GlobalIndCtx
    ; 'GlobalInventory ; 'IndCtx ; 'Label ; 'LocalIndCtx ; 'NeStack ; 'Stack ;
    'StackAndLabel ; 'StackElem ; 'Starter ; 'TypeIndCtx ;
    'WASMFuncGlobalIndSim ; 'WASMFuncGlobalSim ; 'WASMGlobalIndSim ;
    'WASMGlobalSim ; 'WASMLocalIndSim ; 'WASMLocalSim ; 'WASMModule ; 'WASMSim
    ; 'WASMSimTrigger ; 'WASMTypeFuncGlobalIndSim ; 'WASMTypeFuncGlobalSim ;
    'WasmTrigger .
  subsort 'EmptyStack < 'Stack .
  subsort 'FuncIndCtx < 'IndCtx .
  subsort 'GlobalIndCtx < 'IndCtx .
  subsort 'Label < 'StackElem .
  subsort 'List`{Inst`} < 'WASMLocalSim .
  subsort 'LocalIndCtx < 'IndCtx .
  subsort 'NeStack < 'Stack .
  subsort 'Stack < 'WASMLocalSim .
  subsort 'StackElem < 'NeStack .
  subsort 'TypeIndCtx < 'IndCtx .
  subsort 'Und < 'Label .
  subsort 'Value < 'StackElem .
  op '#_#_# : 'WASMModule 'WASMTypeFuncGlobalIndSim -> 'WASMSim [ctor format(
    'ni 'ni 'ni 'ni 'ni 'ni)] .
  op '<_|_|_> : 'List`{Inst`} 'Stack 'Map`{ValRef`,Value`} -> 'WASMLocalSim [
    ctor format('ni 'd 'd 'd 'd 'd 'd 'd)] .
  op 'EmptyStack : nil -> 'EmptyStack [ctor] .
  op 'Fail : 'String -> 'WASMSimTrigger [ctor] .
  op '_#_ : 'WASMFuncGlobalIndSim 'Map`{Addr`,ModuleContent`} ->
    'WASMTypeFuncGlobalSim [ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMGlobalSim 'Map`{Addr`,ModuleContent`} -> 'WASMFuncGlobalSim [
    ctor format('d 'ni 'ni 'd)] .
  op '_#_ : 'WASMLocalSim 'GlobalInventory -> 'WASMGlobalSim [ctor format('d
    'ni 'ni 'd)] .
  op '_$_ : 'StackElem 'Stack -> 'NeStack [ctor id('EmptyStack.EmptyStack)
    format('d 'ni 'd 'd)] .
  op '_<->_ : 'Map`{String`,Addr`} 'Map`{Addr`,GlobalInstance`} ->
    'GlobalInventory [ctor] .
  op '__ : 'FuncIndCtx 'WASMFuncGlobalSim -> 'WASMFuncGlobalIndSim [ctor] .
  op '__ : 'LocalIndCtx 'WASMLocalSim -> 'WASMLocalIndSim [ctor] .
  op '__ : 'TypeIndCtx 'WASMTypeFuncGlobalSim -> 'WASMTypeFuncGlobalIndSim [
    ctor] .
  op '__ : 'WasmTrigger 'WASMSim -> 'WASMSimTrigger [ctor format('ni 'ni 'ni)]
    .
  op '_||_ : 'Stack 'Label -> 'StackAndLabel [none] .
  op '`[_`,_`,_`] : 'Nat 'Nat 'Nat -> 'ComponentCtr [ctor] .
  op '`{_`,indctr_`} : 'Starter 'ComponentCtr -> 'WasmTrigger [ctor] .
  op '`{funcIndCtx_`} : 'Map`{String`,Addr`} -> 'FuncIndCtx [ctor] .
  op '`{localIndCtx_`} : 'Map`{String`,Addr`} -> 'LocalIndCtx [ctor] .
  op '`{typeIndCtx_`} : 'Map`{String`,Addr`} -> 'TypeIndCtx [ctor] .
  op 'aux-get-paramlistTList : 'ParamType -> 'List`{TypeToken`} [none] .
  op 'aux-get-resultlistTList : 'ResultType -> 'List`{TypeToken`} [none] .
  op 'count-locals-localsref : 'LocalsRef -> 'Nat [none] .
  op 'count-locals-paramlist : 'ParamType -> 'Nat [none] .
  op 'count-paramlist-func : 'FuncDef -> 'Nat [none] .
  op 'errorMod : nil -> '`[WASMModule`] [none] .
  op 'errorWASMSimTrigger : nil -> '`[WASMSimTrigger`] [none] .
  op 'exit-block : 'List`{Inst`} -> 'Inst [ctor] .
  op 'exit-func : 'List`{TypeToken`} -> 'Inst [ctor] .
  op 'expand : 'BlockType 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`} ->
    'ParamResultType [none] .
  op 'get-IL-func : 'FuncDef -> 'List`{Inst`} [none] .
  op 'get-funcList : 'Map`{Addr`,ModuleContent`} -> 'FuncDefList [none] .
  op 'get-inst-list-label : 'StackAndLabel -> 'List`{Inst`} [none] .
  op 'get-ith-stackandlabel : 'Stack 'Nat 'Stack -> 'StackAndLabel [none] .
  op 'get-label : 'StackAndLabel -> 'Label [none] .
  op 'get-localsTList : 'LocalsRef -> 'List`{TypeToken`} [none] .
  op 'get-localsTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-localsref-func : 'FuncDef -> 'LocalsRef [none] .
  op 'get-lth-label : 'Stack 'Nat -> 'Label [none] .
  op 'get-paramlist-func : 'FuncDef -> 'ParamType [none] .
  op 'get-paramlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-resultlist-func : 'FuncDef -> 'ResultType [none] .
  op 'get-resultlistTList-func : 'FuncDef -> 'List`{TypeToken`} [none] .
  op 'get-st : 'StackAndLabel -> 'Stack [none] .
  op 'global-type : 'GlobalInstance -> 'GlobalType [none] .
  op 'global-val : 'GlobalInstance -> 'Value [none] .
  op 'head : 'NeList`{Inst`} -> 'Inst [none] .
  op 'if-else : 'ValWrapper 'List`{Inst`} 'List`{Inst`} 'BlockType ->
    'List`{Inst`} [none] .
  op 'init-store : 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`} ->
    'Map`{ValRef`,Value`} [none] .
  op 'inizialize-store : 'Nat 'List`{TypeToken`} 'Stack 'Map`{ValRef`,Value`}
    -> 'Map`{ValRef`,Value`} [none] .
  op 'insert : 'String 'Nat 'IndCtx -> 'IndCtx [none] .
  op 'jump-to-L : 'StackAndLabel -> 'Inst [ctor] .
  op 'label : 'String 'List`{Inst`} 'Nat -> 'Label [ctor] .
  op 'lookup : 'Map`{ValRef`,Value`} 'ValRef -> 'Value [none] .
  op 'module_ : 'ModuleContent -> 'WASMModule [ctor prec(20)] .
  op 'nthResultT : 'ResultTypeList 'Nat -> 'List`{TypeToken`} [none] .
  op 'nthT : 'List`{TypeToken`} 'Nat -> 'TypeToken [none] .
  op 'read-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'reset-st : 'Stack -> 'StackAndLabel [none] .
  op 'reset-st-res : 'Stack 'Nat -> 'Stack [none] .
  op 'run-module-func : 'WASMModule 'Nat -> 'WASMSimTrigger [none] .
  op 'run-module-func : 'WASMModule 'String -> 'WASMSimTrigger [none] .
  op 'run-nomodule : 'List`{Inst`} -> 'WASMTypeFuncGlobalSim [none] .
  op 'selectVal : 'ValWrapper 'Value 'Value -> 'Value [none] .
  op 'simulate-wasm : 'WASMTypeFuncGlobalIndSim -> 'WASMTypeFuncGlobalIndSim [
    none] .
  op 'st-getTopVals : 'Stack 'List`{TypeToken`} -> 'Stack [none] .
  op 'st-head : 'NeStack -> 'StackElem [none] .
  op 'st-pop : 'NeStack -> 'Stack [none] .
  op 'st-popN : 'Stack 'Nat -> 'Stack [none] .
  op 'st-push : 'Stack 'StackElem -> 'NeStack [none] .
  op 'st-rev : 'Stack -> 'Stack [none] .
  op 'start_ : 'Nat -> 'Starter [ctor] .
  op 'start_ : 'String -> 'Starter [ctor] .
  op 'tail : 'NeList`{Inst`} -> 'List`{Inst`} [none] .
  op 'uninitialized : nil -> 'Inst [ctor] .
  op 'valid-stack : 'Stack 'List`{TypeToken`} -> 'Bool [none] .
  op 'validate-funcs-module : 'WASMSimTrigger -> 'WASMSimTrigger [none] .
  op 'verify-IL : 'List`{Inst`} 'List`{TypeToken`} 'List`{TypeToken`}
    'List`{TypeToken`} 'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{String`,Addr`} 'Map`{Addr`,ModuleContent`}
    'Map`{Addr`,GlobalInstance`} 'Map`{String`,Addr`} 'ResultTypeList -> 'Bool
    [none] .
  op 'verify-funcList : 'FuncDefList 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{String`,Addr`}
    'Map`{Addr`,ModuleContent`} 'Map`{Addr`,GlobalInstance`}
    'Map`{String`,Addr`} -> 'Bool [none] .
  none
  eq 'aux-get-paramlistTList['param_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'aux-get-resultlistTList['result_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'block_['TList:List`{TypeToken`}] = 'block_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'count-locals-localsref['local_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-localsref['local_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-localsref['local_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-locals-paramlist['param_['nil.List`{TypeToken`}]] = '0.Zero [none]
    .
  eq 'count-locals-paramlist['param_['__['T:TypeToken,
    'TypeTokenList:List`{TypeToken`}]]] = '_+_['s_['0.Zero],
    'count-locals-paramlist['param_['TypeTokenList:List`{TypeToken`}]]] [none]
    .
  eq 'count-paramlist-func['FuncDef:FuncDef] = 'count-locals-paramlist[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'expand['type_['Id:Id], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, 'Id:Id]] [none] .
  eq 'expand['type_['Str:String], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}] = 'get-functype-typedef['_`[_`][
    'TypeStore:Map`{Addr`,ModuleContent`}, '_`[_`][
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'Str:String]]] [none] .
  eq 'get-IL-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-IL-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'get-funcList['empty.Map`{Addr`,ModuleContent`}] =
    'EmptyFuncDefL.EmptyFuncDefL [none] .
  eq 'get-funcList['_`,_['FuncStore:Map`{Addr`,ModuleContent`}, '_|->_[
    'Addr:Addr, 'FuncDef:FuncDef]]] = '_`,_['FuncDef:FuncDef, 'get-funcList[
    'FuncStore:Map`{Addr`,ModuleContent`}]] [none] .
  eq 'get-inst-list-label['_||_['ST:Stack, 'label['Str:String,
    'IL:List`{Inst`}, 'N:Nat]]] = 'IL:List`{Inst`} [none] .
  eq 'get-ith-stackandlabel['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat,
    'TempST:Stack] = 'get-ith-stackandlabel['ST:Stack, '_-_['NzN:NzNat, 's_[
    '0.Zero]], 'TempST:Stack] [none] .
  eq 'get-ith-stackandlabel['_$_['Val:Value, 'ST:Stack], 'N:Nat, 'TempST:Stack]
    = 'get-ith-stackandlabel['ST:Stack, 'N:Nat, '_$_['TempST:Stack,
    'Val:Value]] [none] .
  eq 'get-ith-stackandlabel['_$_['label['Str:String, 'IL:List`{Inst`}, 'N:Nat],
    'ST:Stack], '0.Zero, 'TempST:Stack] = '_||_['_$_['reset-st-res[
    'TempST:Stack, 'N:Nat], 'ST:Stack], 'label['Str:String, 'IL:List`{Inst`},
    'N:Nat]] [none] .
  eq 'get-label['_||_['ST:Stack, 'Label:Label]] = 'Label:Label [none] .
  eq 'get-label['_||_['ST:Stack, 'und.Und]] = 'und.Und [none] .
  eq 'get-localsTList['local_['TList:List`{TypeToken`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsTList-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef, 'local_[
    'TList:List`{TypeToken`}], 'IL:List`{Inst`}]] = 'TList:List`{TypeToken`} [
    none] .
  eq 'get-localsTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'local_['TList:List`{TypeToken`}], 'IL:List`{Inst`}]] =
    'TList:List`{TypeToken`} [none] .
  eq 'get-localsref-func['func____['N:Nat, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-localsref-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'LocalsRef:LocalsRef [none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], '0.Zero] = 'Label:Label [
    none] .
  eq 'get-lth-label['_$_['Label:Label, 'ST:Stack], 'NzN:NzNat] =
    'get-lth-label['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]] [none] .
  eq 'get-lth-label['_$_['Val:Value, 'ST:Stack], 'N:Nat] = 'get-lth-label[
    'ST:Stack, 'N:Nat] [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ParamType:ParamType [none] .
  eq 'get-paramlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'param_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-paramlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ParamType:ParamType [none] .
  eq 'get-paramlistTList-func['FuncDef:FuncDef] = 'aux-get-paramlistTList[
    'get-paramlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['N:Nat, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['N:Nat, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ParamType:ParamType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'result_['nil.List`{TypeToken`}]
    [none] .
  eq 'get-resultlist-func['func____['Str:String, 'ResultType:ResultType,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] = 'ResultType:ResultType [none] .
  eq 'get-resultlist-func['func____['Str:String, '__['ParamType:ParamType,
    'ResultType:ResultType], 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]] =
    'ResultType:ResultType [none] .
  eq 'get-resultlistTList-func['FuncDef:FuncDef] = 'aux-get-resultlistTList[
    'get-resultlist-func['FuncDef:FuncDef]] [none] .
  eq 'get-st['_||_['ST:Stack, 'Label:Label]] = 'ST:Stack [none] .
  eq 'get-st['_||_['ST:Stack, 'und.Und]] = 'ST:Stack [none] .
  eq 'global-type['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'GlobalType:GlobalType [none] .
  eq 'global-val['`{type_`,value_`}['GlobalType:GlobalType, 'Val:Value]] =
    'Val:Value [none] .
  eq 'head['__['I1:Inst, 'IL:List`{Inst`}]] = 'I1:Inst [none] .
  eq 'if-else['val['0.Zero], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL2:List`{Inst`}, 'end.Inst]] [owise] .
  eq 'if-else['val['NzIntN:NzInt], 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType] = '__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]] [none] .
  eq 'if_['TList:List`{TypeToken`}] = 'if_['result_['TList:List`{TypeToken`}]]
    [none] .
  eq 'init-store['NeTList:NeList`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'inizialize-store['0.Zero,
    'NeTList:NeList`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}] [
    none] .
  eq 'init-store['nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, 'nil.List`{TypeToken`}, 'ST:Stack,
    'LocalSTR:Map`{ValRef`,Value`}] = 'LocalSTR:Map`{ValRef`,Value`} [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'EmptyStack.EmptyStack, 'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat,
    'defaultVal['T:TypeToken], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'EmptyStack.EmptyStack,
    'LocalSTR:Map`{ValRef`,Value`}]] [none] .
  eq 'inizialize-store['N:Nat, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'LocalSTR:Map`{ValRef`,Value`}] = 'insert['N:Nat, 'const['T:TypeToken,
    'ValW1:ValWrapper], 'inizialize-store['_+_['N:Nat, 's_['0.Zero]],
    'TList:List`{TypeToken`}, 'ST:Stack, 'LocalSTR:Map`{ValRef`,Value`}]] [
    none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}]] = '`{funcIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndFuncCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'insert['Str:String, 'Ctr:Nat, '`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}]] = '`{typeIndCtx_`}['insert[
    'Str:String, 'Ctr:Nat, 'IndTypeCtxSTR:Map`{String`,Addr`}]] [none] .
  eq 'lookup['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] = '_`[_`][
    'LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef] [none] .
  eq 'loop_['TList:List`{TypeToken`}] = 'loop_['result_[
    'TList:List`{TypeToken`}]] [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], '0.Zero] = 'TList:List`{TypeToken`}
    [none] .
  eq 'nthResultT['_`,_['result_['TList:List`{TypeToken`}],
    'LabelsResultTypeList:ResultTypeList], 'NzN:NzNat] = 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, '_-_['NzN:NzNat, 's_['0.Zero]]] [
    none] .
  eq 'nthResultT['result_['TList:List`{TypeToken`}], '0.Zero] =
    'TList:List`{TypeToken`} [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], '0.Zero] = 'T:TypeToken
    [none] .
  eq 'nthT['__['T:TypeToken, 'TList:List`{TypeToken`}], 'N:Nat] = 'nthT[
    'TList:List`{TypeToken`}, '_-_['N:Nat, 's_['0.Zero]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'ExportDef:ExportDef]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    '0.0.FiniteFloat]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken,
    'FloatN:Float]]]], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'FloatN:Float]]]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['FloatT:FloatTypeToken, 'IntN:Int]]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    'GCtr:Nat]], '#_#_#['module_['__['ModuleContent:ModuleContent,
    'global__`(_`)['Str:String, 'GlobalType:GlobalType, '_.const_[
    'FloatT:FloatTypeToken, 'float['IntN:Int]]]]], '__['IndTypeCtx:TypeIndCtx,
    '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Id:Id, 'FuncType:FuncType]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__['Id:Id,
    'FuncType:FuncType], 'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'type__['Str:String, 'FuncType:FuncType]]],
    '__['IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['_+_['TCtr:Nat, 's_[
    '0.Zero]], 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['insert['Str:String, 'TCtr:Nat,
    'IndTypeCtx:TypeIndCtx], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]], 'insert['TCtr:Nat, 'type__[
    'Str:String, 'FuncType:FuncType],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['N:Nat], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'read-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'validate-funcs-module['__[
    '`{_`,indctr_`}['start_['Str:String], 'ComponentCtr:ComponentCtr], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] [none] .
  eq 'reset-st['EmptyStack.EmptyStack] = '_||_['EmptyStack.EmptyStack,
    'und.Und] [none] .
  eq 'reset-st['_$_['Label:Label, 'ST:Stack]] = '_||_['ST:Stack, 'Label:Label]
    [none] .
  eq 'reset-st['_$_['Val:Value, 'ST:Stack]] = '_||_['_$_['Val:Value, 'get-st[
    'reset-st['ST:Stack]]], 'get-label['reset-st['ST:Stack]]] [none] .
  eq 'reset-st-res['EmptyStack.EmptyStack, 'N:Nat] = 'EmptyStack.EmptyStack [
    none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], '0.Zero] =
    'EmptyStack.EmptyStack [none] .
  eq 'reset-st-res['_$_['Val:Value, 'ST:Stack], 'NzN:NzNat] = '_$_['Val:Value,
    'reset-st-res['ST:Stack, '_-_['NzN:NzNat, 's_['0.Zero]]]] [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'N:Nat] = 'read-module['__[
    '`{_`,indctr_`}['start_['N:Nat], '`[_`,_`,_`]['0.Zero, '0.Zero, '0.Zero]],
    '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-module-func['WASMModule:WASMModule, 'Str:String] = 'read-module['__[
    '`{_`,indctr_`}['start_['Str:String], '`[_`,_`,_`]['0.Zero, '0.Zero,
    '0.Zero]], '#_#_#['WASMModule:WASMModule, '__['`{typeIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['uninitialized.Inst,
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}]]]]]
    [none] .
  eq 'run-nomodule['IL:List`{Inst`}] = '_#_['__['`{funcIndCtx_`}[
    'empty.Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['IL:List`{Inst`},
    'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'empty.Map`{String`,Addr`}, 'empty.Map`{Addr`,GlobalInstance`}]],
    'empty.Map`{Addr`,ModuleContent`}]], 'empty.Map`{Addr`,ModuleContent`}] [
    none] .
  eq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val2:Value [
    owise] .
  eq 'simulate-wasm['WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim] =
    'WASMTypeFuncGlobalIndSim:WASMTypeFuncGlobalIndSim [none] .
  eq 'st-getTopVals['ST:Stack, 'nil.List`{TypeToken`}] = 'EmptyStack.EmptyStack
    [none] .
  eq 'st-getTopVals['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'st-getTopVals['ST:Stack, 'TList:List`{TypeToken`}]] [
    none] .
  eq 'st-head['_$_['STElem:StackElem, 'ST:Stack]] = 'STElem:StackElem [none] .
  eq 'st-pop['_$_['STElem:StackElem, 'ST:Stack]] = 'ST:Stack [none] .
  eq 'st-popN['ST:Stack, '0.Zero] = 'ST:Stack [none] .
  eq 'st-push['EmptyStack.EmptyStack, 'STElem:StackElem] = 'STElem:StackElem [
    none] .
  eq 'st-push['ST:Stack, 'STElem:StackElem] = '_$_['STElem:StackElem,
    'ST:Stack] [none] .
  eq 'st-rev['EmptyStack.EmptyStack] = 'EmptyStack.EmptyStack [none] .
  eq 'st-rev['_$_['STElem:StackElem, 'ST:Stack]] = '_$_['st-rev['ST:Stack],
    'STElem:StackElem] [none] .
  eq 'tail['__['I1:Inst, 'IL:List`{Inst`}]] = 'IL:List`{Inst`} [none] .
  eq 'valid-stack['ST:Stack, 'TList:List`{TypeToken`}] = 'false.Bool [owise] .
  eq 'valid-stack['ST:Stack, 'nil.List`{TypeToken`}] = 'true.Bool [none] .
  eq 'valid-stack['_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    '__['T:TypeToken, 'TList:List`{TypeToken`}]] = 'valid-stack['ST:Stack,
    'TList:List`{TypeToken`}] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_['N:Nat],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod],
    'simulate-wasm['__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}],
    '_#_['__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['call_['N:Nat], 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'validate-funcs-module['__['`{_`,indctr_`}['start_['Str:String],
    'ComponentCtr:ComponentCtr], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    '`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'if_then_else_fi[
    'verify-funcList['get-funcList['FuncStore:Map`{Addr`,ModuleContent`}],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], '__['`{_`,indctr_`}['start_[
    'Str:String], 'ComponentCtr:ComponentCtr], '#_#_#['module_[
    'EmptyMod.EmptyMod], 'simulate-wasm['__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['`{funcIndCtx_`}[
    'IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_['<_|_|_>['call_['_`[_`][
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'Str:String]], 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]], 'Fail[
    '"Invalid module".String]] [none] .
  eq 'verify-IL['NeIL:NeList`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'false.Bool [owise] .
  eq 'verify-IL['nil.List`{Inst`}, 'TListRes:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool [none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['drop.Inst, 'IL:List`{Inst`}], '__['T:TypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['nop.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['select.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '__['IntT:IntTypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '__['T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f32.FloatTypeToken, 'demote~.CvtopToken,
    'f64.FloatTypeToken], 'IL:List`{Inst`}], '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['f64.FloatTypeToken, 'promote~.CvtopToken,
    'f32.FloatTypeToken], 'IL:List`{Inst`}], '__['f32.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['f64.FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken, 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.__['i32.IntTypeToken, 'wrap~.CvtopToken,
    'i64.IntTypeToken], 'IL:List`{Inst`}], '__['i64.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['FloatT:FloatTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['IntT:IntTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['IntT:IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['_.const_['v128.VecTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['v128.VecTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['call_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.get_['Str:String], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-GlobalTypeToken['global-type['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] [
    none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-IL['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    '_and_['verify-IL['__['__['block_['BlockType:BlockType], '__[
    'IL1:List`{Inst`}, 'end.Inst]], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]], 'verify-IL[
    '__['__['block_['BlockType:BlockType], '__['IL2:List`{Inst`}, 'end.Inst]],
    'IL:List`{Inst`}], 'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType[
    'BlockType:BlockType], 'LabelsResultTypeList:ResultTypeList]]] [none] .
  eq 'verify-funcList['EmptyFuncDefL.EmptyFuncDefL,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'true.Bool [none] .
  eq 'verify-funcList['FuncDefL:FuncDefList,
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = 'false.Bool [owise] .
  eq 'verify-funcList['_`,_['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____['Id:Id,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]]] [none]
    .
  eq 'verify-funcList['_`,_['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}], 'FuncDefL:FuncDefList],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}] = '_and_['verify-funcList[
    'FuncDefL:FuncDefList, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}], 'verify-IL['IL:List`{Inst`},
    'nil.List`{TypeToken`}, '__['get-paramlistTList-func['func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]],
    'get-localsTList['LocalsRef:LocalsRef]], 'reverse[
    'get-resultlistTList-func['func____['Str:String, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'get-resultlist-func['func____[
    'Str:String, 'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef,
    'IL:List`{Inst`}]]]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Id:Id, 'FuncTypeDef:FuncTypeDef,
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['Id:Id, 'func____[
    'Id:Id, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'func____['Str:String,
    'FuncTypeDef:FuncTypeDef, 'LocalsRef:LocalsRef, 'IL:List`{Inst`}]]], '__[
    '`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, '_+_['FCtr:Nat,
    's_['0.Zero]], 'GCtr:Nat]], '#_#_#['module_['ModuleContent:ModuleContent],
    '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['insert[
    'Str:String, 'FCtr:Nat, 'IndFuncCtx:FuncIndCtx], '_#_['_#_['<_|_|_>[
    'uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]], 'insert['FCtr:Nat, 'func____[
    'Str:String, 'get-functype['FuncTypeDef:FuncTypeDef,
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndTypeCtxSTR:Map`{String`,Addr`}],
    'LocalsRef:LocalsRef, 'IL:List`{Inst`}],
    'FuncStore:Map`{Addr`,ModuleContent`}]]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'valid-functype[
    'FuncTypeDef:FuncTypeDef, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndTypeCtxSTR:Map`{String`,Addr`}] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'ValW1:ValWrapper]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if 'ValW1:ValWrapper :=
    'unsigned['val['IntN:Int], 'bit-width['IntT:IntTypeToken]] [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['IntT:IntTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['IntT:IntTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'read-module['__['`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`][
    'TCtr:Nat, 'FCtr:Nat, 'GCtr:Nat]], '#_#_#['module_['__[
    'ModuleContent:ModuleContent, 'global__`(_`)['Str:String,
    'GlobalType:GlobalType, '_.const_['v128.VecTypeToken, 'IntN:Int]]]], '__[
    'IndTypeCtx:TypeIndCtx, '_#_['__['IndFuncCtx:FuncIndCtx, '_#_['_#_[
    '<_|_|_>['uninitialized.Inst, 'ST:Stack, 'empty.Map`{ValRef`,Value`}],
    '_<->_['GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] = 'read-module['__[
    '`{_`,indctr_`}['StartFunc:Starter, '`[_`,_`,_`]['TCtr:Nat, 'FCtr:Nat,
    '_+_['GCtr:Nat, 's_['0.Zero]]]], '#_#_#['module_[
    'ModuleContent:ModuleContent], '__['IndTypeCtx:TypeIndCtx, '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['uninitialized.Inst, 'ST:Stack,
    'empty.Map`{ValRef`,Value`}], '_<->_['insert['Str:String, 'GCtr:Nat,
    'GlobalAddrs:Map`{String`,Addr`}], 'insert['GCtr:Nat, '`{type_`,value_`}[
    'GlobalType:GlobalType, 'const['v128.VecTypeToken, 'val['IntN:Int]]],
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]]],
    'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]]]]] if '_and_['_<_['IntN:Int, '_^_[
    's_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_['0.Zero,
    'IntN:Int]] = 'true.Bool [none] .
  ceq 'selectVal['val['Int1:Int], 'Val1:Value, 'Val2:Value] = 'Val1:Value if
    '_=/=_['Int1:Int, '0.Zero] = 'true.Bool [none] .
  ceq 'st-popN['_$_['STElem:StackElem, 'ST:Stack], 'N:Nat] = 'st-popN[
    'ST:Stack, '_-_['N:Nat, 's_['0.Zero]]] if '_>_['N:Nat, '0.Zero] =
    'true.Bool [none] .
  ceq 'verify-IL['nil.List`{Inst`}, '__['TList:List`{TypeToken`},
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'true.Bool if '__['TList:List`{TypeToken`}, 'TList':List`{TypeToken`}] :=
    'TListRes:List`{TypeToken`} [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br_['N:Nat], 'IL:List`{Inst`}], '__[
    'TListLabel:List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], 'Unknown.UnkTypeToken,
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'TListLabel:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TListLabel:List`{TypeToken`}, 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat]] = 'true.Bool [none] .
  ceq 'verify-IL['__['br~if_['N:Nat], 'IL:List`{Inst`}], '__['i32.IntTypeToken,
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TListLabel:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TListLabel:List`{TypeToken`} := 'nthResultT[
    'LabelsResultTypeList:ResultTypeList, 'N:Nat] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}],
    'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'Unknown.UnkTypeToken], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'TList':List`{TypeToken`} := 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]] [none] .
  ceq 'verify-IL['__['call_['Addr:Addr], 'IL:List`{Inst`}], '__[
    'TList':List`{TypeToken`}, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]],
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['TList':List`{TypeToken`}, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['global.set_['Str:String], 'IL:List`{Inst`}], '__[
    'T:TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '__['MutGlobalTypeIndicator:MutGlobalTypeIndicator, 'T:TypeToken] :=
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]] [none] .
  ceq 'verify-IL['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}],
    'TList:List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T:TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'T:TypeToken := 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef] [none] .
  ceq 'verify-IL['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '__[
    'T':TypeToken, 'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['T':TypeToken, 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_==_['T':TypeToken, 'nthT['TList1:List`{TypeToken`}, 'ValR:ValRef]] =
    'true.Bool [none] .
  ceq 'verify-IL['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['block_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '_`,_['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'TList:List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList[
    'ResultType:ResultType], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'nil.List`{TypeToken`},
    'TList1:List`{TypeToken`}, 'aux-get-resultlistTList[
    'ResultType:ResultType], 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['ResultType:ResultType,
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'Unknown.UnkTypeToken, 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'Unknown.UnkTypeToken],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    'verify-IL['IL2:List`{Inst`}, 'aux-get-paramlistTList['getParamType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]] = 'true.Bool [none] .
  ceq 'verify-IL['__['loop_['TypeRef:TypeRef], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], '__['TList':List`{TypeToken`},
    'TList:List`{TypeToken`}], 'TList1:List`{TypeToken`},
    'TListRes:List`{TypeToken`}, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}, 'IndFuncCtxSTR:Map`{String`,Addr`},
    'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] =
    'verify-IL['IL:List`{Inst`}, '__['aux-get-resultlistTList['getResultType[
    'expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]], 'TList:List`{TypeToken`}],
    'TList1:List`{TypeToken`}, 'TListRes:List`{TypeToken`},
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, 'LabelsResultTypeList:ResultTypeList] if
    '_and_['_==_['TList':List`{TypeToken`}, 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]], 'verify-IL['IL2:List`{Inst`},
    'TList':List`{TypeToken`}, 'TList1:List`{TypeToken`},
    'aux-get-resultlistTList['getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]],
    'IndTypeCtxSTR:Map`{String`,Addr`}, 'TypeStore:Map`{Addr`,ModuleContent`},
    'IndFuncCtxSTR:Map`{String`,Addr`}, 'FuncStore:Map`{Addr`,ModuleContent`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`},
    'GlobalAddrs:Map`{String`,Addr`}, '__['getResultType['expand[
    'TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]],
    'LabelsResultTypeList:ResultTypeList]]] = 'true.Bool [none] .
  rl '<_|_|_>['__['drop.Inst, 'IL:List`{Inst`}], '_$_['Val:Value, 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('drop)] .
  rl '<_|_|_>['__['nop.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('nop)] .
  rl '<_|_|_>['__['select.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW2:ValWrapper], '_$_['Val2:Value, '_$_['Val1:Value,
    'ST:Stack]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['selectVal['ValW2:ValWrapper, 'Val1:Value,
    'Val2:Value], 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('select)] .
  rl '<_|_|_>['__['_._['IntT:IntTypeToken, 'eqz.TestopToken],
    'IL:List`{Inst`}], '_$_['const['IntT:IntTypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'ieq['ValW1:ValWrapper,
    'val['0.Zero]]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.eqz)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'binopT:BinopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper], 'und.Und], '<_|_|_>['IL:List`{Inst`}, 'st-push[
    'ST:Stack, 'binop['T:TypeToken, 'binopT:BinopToken, 'ValW1:ValWrapper,
    'ValW2:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'trap['"Binop result undefined".String]] [label('t.binop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'relopT:RelopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW2:ValWrapper], '_$_['const['T:TypeToken,
    'ValW1:ValWrapper], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, '_$_['const['i32.IntTypeToken, 'relop['T:TypeToken,
    'relopT:RelopToken, 'ValW1:ValWrapper, 'ValW2:ValWrapper]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('t.relop)] .
  rl '<_|_|_>['__['_._['T:TypeToken, 'unopT:UnopToken], 'IL:List`{Inst`}],
    '_$_['const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'unop['T:TypeToken, 'unopT:UnopToken,
    'ValW1:ValWrapper]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [
    label('t.unop)] .
  rl '<_|_|_>['__['_.__['T2:TypeToken, 'cvtopT:CvtopToken, 'T1:TypeToken],
    'IL:List`{Inst`}], '_$_['const['T1:TypeToken, 'ValW1:ValWrapper],
    'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    'if_then_else_fi['_=/=_['cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper], 'und.Und], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'cvtop['T1:TypeToken, 'T2:TypeToken,
    'cvtopT:CvtopToken, 'ValW1:ValWrapper]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], 'trap[
    '"Cvtop result undefined".String]] [label('t1.cvtop_t2)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'FloatN:Float],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => 'if_then_else_fi['_=/=_['FloatN:Float, '0.0.FiniteFloat], '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'correctFloat['const[
    'FloatT:FloatTypeToken, 'val['FloatN:Float]]]],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}], '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, 'correctFloat['const['FloatT:FloatTypeToken, 'val[
    'zero['pos.Sign]]]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label(
    'float-const)] .
  rl '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'IntN:Int],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]
    => '<_|_|_>['__['_.const_['FloatT:FloatTypeToken, 'float['IntN:Int]],
    'IL:List`{Inst`}], 'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] [
    label('int-as-float-const)] .
  rl '<_|_|_>['__['br~if_['N:Nat], 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'val['Int1:Int]], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => 'if_then_else_fi['_=/=_[
    'Int1:Int, '0.Zero], '<_|_|_>['__['br_['N:Nat], 'IL:List`{Inst`}],
    'ST:Stack, 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]] [label('br_if)] .
  rl '<_|_|_>['__['local.get_['ValR:ValRef], 'IL:List`{Inst`}], 'ST:Stack, '__[
    'LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'st-push['ST:Stack, '_`[_`]['LocalSTR:Map`{ValRef`,Value`}, 'ValR:ValRef]],
    '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.get)] .
  rl '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], '__['LocalSTR:Map`{ValRef`,Value`},
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] => '<_|_|_>['IL:List`{Inst`},
    'ST:Stack, '__['insert['ValR:ValRef, 'Val:Value,
    'LocalSTR:Map`{ValRef`,Value`}],
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}]] [label('local.set)] .
  rl '<_|_|_>['__['local.tee_['ValR:ValRef], 'IL:List`{Inst`}], '_$_[
    'Val:Value, 'ST:Stack], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] =>
    '<_|_|_>['__['local.set_['ValR:ValRef], 'IL:List`{Inst`}], 'st-push[
    'st-push['ST:Stack, 'Val:Value], 'Val:Value],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('local.tee)] .
  rl '<_|_|_>['__['block_['ResultType:ResultType], 'IL2:List`{Inst`},
    'end.Inst, 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"block".String, 'nil.List`{Inst`}, 'size['aux-get-resultlistTList[
    'ResultType:ResultType]]]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]
    [label('block-resultT)] .
  rl '<_|_|_>['__['loop_['ResultType:ResultType], 'IL2:List`{Inst`}, 'end.Inst,
    'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], 'st-push['ST:Stack,
    'label['"loop".String, '__['loop_['ResultType:ResultType], '__[
    'IL2:List`{Inst`}, 'end.Inst]], '0.Zero]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('loop-resultT)] .
  rl '<_|_|_>['__['if_['BlockType:BlockType], 'IL1:List`{Inst`}, 'else.Inst,
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], '_$_['const[
    'i32.IntTypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__['if-else[
    'ValW1:ValWrapper, 'IL1:List`{Inst`}, 'IL2:List`{Inst`},
    'BlockType:BlockType], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('if-else)] .
  rl '<_|_|_>['exit-block['IL:List`{Inst`}], 'NeST:NeStack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'get-st['reset-st['NeST:NeStack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] [label('end)] .
  rl '_#_['<_|_|_>['__['global.get_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'global-val['_`[_`][
    'GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] [label('global.get)] .
  rl '_#_['_#_['<_|_|_>['__['call_['Addr:Addr], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['__['get-IL-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]], '__['exit-func[
    'get-resultlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]]], 'exit-block['IL:List`{Inst`}]]], '_$_['label['"func".String,
    'nil.List`{Inst`}, 'size['get-resultlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]], 'st-popN['ST:Stack,
    'size['get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]]]], '__['init-store[
    '__['get-paramlistTList-func['_`[_`]['FuncStore:Map`{Addr`,ModuleContent`},
    'Addr:Addr]], 'get-localsTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]], 'st-getTopVals[
    'ST:Stack, 'get-paramlistTList-func['_`[_`][
    'FuncStore:Map`{Addr`,ModuleContent`}, 'Addr:Addr]]],
    'empty.Map`{ValRef`,Value`}], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}] [
    label('call)] .
  rl '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['Str:String], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    => '__['`{funcIndCtx_`}['IndFuncCtxSTR:Map`{String`,Addr`}], '_#_['_#_[
    '<_|_|_>['__['call_['_`[_`]['IndFuncCtxSTR:Map`{String`,Addr`},
    'Str:String]], 'IL:List`{Inst`}], 'ST:Stack,
    'LocalSTRList:List`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]]
    [label('call-by-name)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken,
    'ValW1:ValWrapper]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if
    'ValW1:ValWrapper := 'unsigned['val['IntN:Int], 'bit-width[
    'IntT:IntTypeToken]] [label('int-const-signed)] .
  crl '<_|_|_>['__['_.const_['IntT:IntTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['IntT:IntTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['IntT:IntTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('int-const)] .
  crl '<_|_|_>['__['_.const_['v128.VecTypeToken, 'IntN:Int], 'IL:List`{Inst`}],
    'ST:Stack, 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] => '<_|_|_>[
    'IL:List`{Inst`}, 'st-push['ST:Stack, 'const['v128.VecTypeToken, 'val[
    'IntN:Int]]], 'LocalSTRList:List`{Map`{ValRef`,Value`}`}] if '_and_['_<_[
    'IntN:Int, '_^_['s_^2['0.Zero], 'bit-width['v128.VecTypeToken]]], '_<=_[
    '0.Zero, 'IntN:Int]] = 'true.Bool [label('vec-const)] .
  crl '<_|_|_>['__['br_['N:Nat], 'IL2:List`{Inst`}, 'exit-block[
    'IL:List`{Inst`}], 'IL':List`{Inst`}], 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] => '<_|_|_>['__[
    'IL1:List`{Inst`}, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}] if '_||_['ST1:Stack,
    'label['Str:String, 'IL1:List`{Inst`}, 'N1:Nat]] := 'get-ith-stackandlabel[
    'ST:Stack, 'N:Nat, 'EmptyStack.EmptyStack] [label('br)] .
  crl '_#_['<_|_|_>['__['global.set_['Str:String], 'IL:List`{Inst`}], '_$_[
    'const['T:TypeToken, 'ValW1:ValWrapper], 'ST:Stack],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`},
    'GlobalsStore:Map`{Addr`,GlobalInstance`}]] => '_#_['<_|_|_>[
    'IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}], '_<->_[
    'GlobalAddrs:Map`{String`,Addr`}, 'insert['_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken], 'const['T:TypeToken,
    'ValW1:ValWrapper]], 'GlobalsStore:Map`{Addr`,GlobalInstance`}]]] if '_==_[
    'global-type['_`[_`]['GlobalsStore:Map`{Addr`,GlobalInstance`}, '_`[_`][
    'GlobalAddrs:Map`{String`,Addr`}, 'Str:String]]], '__[
    'mut.MutGlobalTypeIndicator, 'T:TypeToken]] = 'true.Bool [label(
    'global.set)] .
  crl '_#_['_#_['<_|_|_>['__['exit-func['TypeTokenList:List`{TypeToken`}],
    'IL:List`{Inst`}], 'ST:Stack, '__['LocalSTR:Map`{ValRef`,Value`},
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}]],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    => '_#_['_#_['<_|_|_>['IL:List`{Inst`}, 'ST:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]
    if 'valid-stack['ST:Stack, 'reverse['TypeTokenList:List`{TypeToken`}]] =
    'true.Bool [label('exit-func)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['block_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"block".String, 'nil.List`{Inst`}, 'size[
    'TListRes:List`{TypeToken`}]], 'ST:Stack]],
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListRes:List`{TypeToken`} := 'aux-get-resultlistTList[
    'getResultType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('block-tref)] .
  crl '__['`{typeIndCtx_`}['IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__[
    'IndFuncCtx:FuncIndCtx, '_#_['_#_['<_|_|_>['__['loop_['TypeRef:TypeRef],
    'IL2:List`{Inst`}, 'end.Inst, 'IL:List`{Inst`}], 'ST1:Stack,
    'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] => '__['`{typeIndCtx_`}[
    'IndTypeCtxSTR:Map`{String`,Addr`}], '_#_['__['IndFuncCtx:FuncIndCtx, '_#_[
    '_#_['<_|_|_>['__['IL2:List`{Inst`}, 'exit-block['IL:List`{Inst`}]], '_$_[
    'ST':Stack, '_$_['label['"loop".String, '__['loop_['TypeRef:TypeRef], '__[
    'IL2:List`{Inst`}, 'end.Inst]], 'size['TListParam:List`{TypeToken`}]],
    'ST:Stack]], 'NeLocalSTRList:NeList`{Map`{ValRef`,Value`}`}],
    'GlobalInventory:GlobalInventory], 'FuncStore:Map`{Addr`,ModuleContent`}]],
    'TypeStore:Map`{Addr`,ModuleContent`}]] if 'ST':Stack := 'st-getTopVals[
    'ST1:Stack, 'aux-get-paramlistTList['getParamType['expand['TypeRef:TypeRef,
    'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]]] /\ '_$_['ST':Stack, 'ST:Stack] :=
    'ST1:Stack /\ 'TListParam:List`{TypeToken`} := 'aux-get-paramlistTList[
    'getParamType['expand['TypeRef:TypeRef, 'IndTypeCtxSTR:Map`{String`,Addr`},
    'TypeStore:Map`{Addr`,ModuleContent`}]]] [label('loop-tref)] .
endm, '__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['call_['s_['0.Zero]], 'EmptyStack.EmptyStack,
    'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero],
    '_|->_['"$result".String, 's_['0.Zero]]], '_`,_['_|->_['0.Zero,
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]], '_|->_['s_['0.Zero],
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero,
    'func____['"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], 'w:WASMSimTrigger, nil, '!, unbounded, 0)
--->
{'__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3['0.Zero],
    's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_['EmptyMod.EmptyMod], '__[
    '`{typeIndCtx_`}['_`,_['_|->_['"$type0".String, '0.Zero], '_|->_[
    '"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String, 's_^2[
    '0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_['"$factorial".String,
    '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]], '_#_['_#_['<_|_|_>[
    'nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]],
    'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero],
    '_|->_['"$result".String, 's_['0.Zero]]], '_`,_['_|->_['0.Zero,
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero],
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero,
    'func____['"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], 'WASMSimTrigger, 
  'w:WASMSimTrigger <- '__['`{_`,indctr_`}['start_['"$start".String],
    '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_[
    '"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_[
    '"$type2".String, 's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_[
    '_|->_['"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_[
    '0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const[
    'i64.IntTypeToken, 'val['s_^5['0.Zero]]], 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]]}
*********** equation
eq getFormattedRes({OgTerm, Type, ResSubstitution}) = 
[
downTerm(OgTerm, errorWASMSimTrigger)
/
Type
/
formatSubs(ResSubstitution)
]
 .
OgTerm --> '__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]]
Type --> 'WASMSimTrigger
ResSubstitution --> 
  'w:WASMSimTrigger <- '__['`{_`,indctr_`}['start_['"$start".String],
    '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_[
    '"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_[
    '"$type2".String, 's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_[
    '_|->_['"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_[
    '0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const[
    'i64.IntTypeToken, 'val['s_^5['0.Zero]]], 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]]]]]]]
getFormattedRes({'__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`][
    's_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], 'WASMSimTrigger, 
  'w:WASMSimTrigger <- '__['`{_`,indctr_`}['start_['"$start".String],
    '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_[
    '"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_[
    '"$type2".String, 's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_[
    '_|->_['"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_[
    '0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const[
    'i64.IntTypeToken, 'val['s_^5['0.Zero]]], 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]]})
--->

[
downTerm('__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], errorWASMSimTrigger)
/
'WASMSimTrigger
/
formatSubs(
  'w:WASMSimTrigger <- '__['`{_`,indctr_`}['start_['"$start".String],
    '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_[
    '"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_[
    '"$type2".String, 's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_[
    '_|->_['"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_[
    '0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const[
    'i64.IntTypeToken, 'val['s_^5['0.Zero]]], 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]])
]

*********** equation
(built-in equation for symbol downTerm)
downTerm('__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], errorWASMSimTrigger)
--->

{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< nil | const(i64, val(5)) | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#


*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val(5)
Value: const(i64, val(5)) becomes IntValue
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val((1).NzNat)
Value: const(i64, val((1).NzNat)) becomes IntValue
*********** equation
eq formatSubs(ResSubstitution ; 
  ResVar <- ResTerm) = formatSubs(ResSubstitution) && ResVar <== downTerm(
    ResTerm, errorWASMSimTrigger) .
ResSubstitution --> (none).Substitution
ResVar --> 'w:WASMSimTrigger
ResTerm --> '__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]]
formatSubs(
  'w:WASMSimTrigger <- '__['`{_`,indctr_`}['start_['"$start".String],
    '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#[
    'module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_[
    '"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_[
    '"$type2".String, 's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_[
    '_|->_['"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_[
    '0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const[
    'i64.IntTypeToken, 'val['s_^5['0.Zero]]], 'empty.Map`{ValRef`,Value`}],
    '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero], '_|->_['"$result".String,
    's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[
    'mut.MutGlobalTypeIndicator, 'i64.IntTypeToken], 'const['i64.IntTypeToken,
    'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____[
    '"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]])
--->
formatSubs(none) && 'w:WASMSimTrigger <== downTerm('__['`{_`,indctr_`}['start_[
    '"$start".String], '`[_`,_`,_`]['s_^3['0.Zero], 's_^2['0.Zero], 's_^2[
    '0.Zero]]], '#_#_#['module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}[
    '_`,_['_|->_['"$type0".String, '0.Zero], '_|->_['"$type1".String, 's_[
    '0.Zero]], '_|->_['"$type2".String, 's_^2['0.Zero]]]], '_#_['__[
    '`{funcIndCtx_`}['_`,_['_|->_['"$factorial".String, '0.Zero], '_|->_[
    '"$start".String, 's_['0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`},
    'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]],
    'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_['"$gb1".String, '0.Zero],
    '_|->_['"$result".String, 's_['0.Zero]]], '_`,_['_|->_['0.Zero,
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero],
    '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i64.IntTypeToken],
    'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero,
    'func____['"$factorial".String, '__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]], 'local_['nil.List`{TypeToken`}], '__['_.const_[
    'i64.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i64.IntTypeToken,
    'eq.RelopToken], 'if_['result_['i64.IntTypeToken]], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], 'else.Inst, 'local.get_['0.Zero],
    'local.get_['0.Zero], '_.const_['i64.IntTypeToken, 's_['0.Zero]], '_._[
    'i64.IntTypeToken, 'sub.BinopToken], 'call_['"$factorial".String], '_._[
    'i64.IntTypeToken, 'mul.BinopToken], 'end.Inst]]], '_|->_['s_['0.Zero],
    'func____['"$start".String, 'result_['i64.IntTypeToken], 'local_[
    'i32.IntTypeToken], '__['_.const_['i64.IntTypeToken, 's_^5['0.Zero]],
    'global.set_['"$gb1".String], 'global.get_['"$gb1".String], 'block_['type_[
    '"$type2".String]], 'br_['0.Zero], 'call_['"$factorial".String],
    'end.Inst]]]]]], '_`,_['_|->_['0.Zero, 'type__['"$type0".String, 'func_[
    'result_['i64.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__[
    '"$type1".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero], 'type__['"$type2".String,
    'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], errorWASMSimTrigger)
*********** equation
eq formatSubs(none) = noCustomSubstitution .
empty substitution
formatSubs(none)
--->
noCustomSubstitution
*********** equation
(built-in equation for symbol downTerm)
downTerm('__['`{_`,indctr_`}['start_['"$start".String], '`[_`,_`,_`]['s_^3[
    '0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_[
    'EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"$type0".String,
    '0.Zero], '_|->_['"$type1".String, 's_['0.Zero]], '_|->_['"$type2".String,
    's_^2['0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_[
    '"$factorial".String, '0.Zero], '_|->_['"$start".String, 's_['0.Zero]]]],
    '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'const['i64.IntTypeToken, 'val['s_^5[
    '0.Zero]]], 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_[
    '"$gb1".String, '0.Zero], '_|->_['"$result".String, 's_['0.Zero]]], '_`,_[
    '_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_^5['0.Zero]]]]],
    '_|->_['s_['0.Zero], '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator,
    'i64.IntTypeToken], 'const['i64.IntTypeToken, 'val['s_['0.Zero]]]]]]]],
    '_`,_['_|->_['0.Zero, 'func____['"$factorial".String, '__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]], 'local_[
    'nil.List`{TypeToken`}], '__['_.const_['i64.IntTypeToken, '0.Zero],
    'local.get_['0.Zero], '_._['i64.IntTypeToken, 'eq.RelopToken], 'if_[
    'result_['i64.IntTypeToken]], '_.const_['i64.IntTypeToken, 's_['0.Zero]],
    'else.Inst, 'local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[
    'i64.IntTypeToken, 's_['0.Zero]], '_._['i64.IntTypeToken, 'sub.BinopToken],
    'call_['"$factorial".String], '_._['i64.IntTypeToken, 'mul.BinopToken],
    'end.Inst]]], '_|->_['s_['0.Zero], 'func____['"$start".String, 'result_[
    'i64.IntTypeToken], 'local_['i32.IntTypeToken], '__['_.const_[
    'i64.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"$gb1".String],
    'global.get_['"$gb1".String], 'block_['type_['"$type2".String]], 'br_[
    '0.Zero], 'call_['"$factorial".String], 'end.Inst]]]]]], '_`,_['_|->_[
    '0.Zero, 'type__['"$type0".String, 'func_['result_['i64.IntTypeToken]]]],
    '_|->_['s_['0.Zero], 'type__['"$type1".String, 'func_['__['param_[
    'i64.IntTypeToken], 'result_['i64.IntTypeToken]]]]], '_|->_['s_^2['0.Zero],
    'type__['"$type2".String, 'func_['__['param_['i64.IntTypeToken], 'result_[
    'i64.IntTypeToken]]]]]]]]]], errorWASMSimTrigger)
--->

{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< nil | const(i64, val(5)) | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#


*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val(5)
Value: const(i64, val(5)) becomes IntValue
*********** membership axiom
mb const(IntT:IntTypeToken, ValWrapper:ValWrapper) : IntValue .
IntT:IntTypeToken --> i64
ValWrapper:ValWrapper --> val((1).NzNat)
Value: const(i64, val((1).NzNat)) becomes IntValue
rewrites: 3893 in 130ms cpu (201ms real) (29946 rewrites/second)
result FormatedSearchResult: 
[

{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< nil | const(i64, val(5)) | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#


/
'WASMSimTrigger
/
'w:WASMSimTrigger <== 
{start "$start", indctr [3, 2, 2]}

#
module EmptyMod
#
{typeIndCtx "$type0" |-> 0, "$type1" |-> 1, "$type2" |-> 2} {funcIndCtx
    "$factorial" |-> 0, "$start" |-> 1} 
< nil | const(i64, val(5)) | empty >
#
("$gb1" |-> 0, "$result" |-> 1) <-> (0 |-> {type mut i64, value const(i64, val(
    5))}, 1 |-> {type mut i64, value const(i64, val((1).NzNat))})
#
(0 |-> 
func "$factorial" (param i64) (result i64)
  (local nil)
i64 .const (0).Zero
 local.get 0
 i64 . eq
 if (result i64)
 i64 .const (1).NzNat
 else
 local.get 0
 local.get 0
 i64 .const (1).NzNat
 i64 . sub
 call "$factorial"
 i64 . mul
 (end).Inst
, 1 |-> 
func "$start" (result i64)
  (local i32)
i64 .const 5
 global.set "$gb1"
 global.get "$gb1"
 block type "$type2"
 br 0
 call "$factorial"
 (end).Inst
)
#
(0 |-> type "$type0" (func result i64), 1 |-> type "$type1" (func (param i64) (
    result i64)), 2 |-> type "$type2" (func (param i64) (result i64)))
#


]

Bye.
