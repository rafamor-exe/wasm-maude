red local.set 3    local.get 2    local.get 3 .

rew < (local.get 3) | EmptyStack | 3 |-> 10 > .
search < (local.get 3) | EmptyStack | 3 |-> 10 > =>* < nil | 10 | 3 |-> 10 > .

rew < (local.get 3) (local.set 2) | EmptyStack | 3 |-> 10 > .
search < (local.get 3) (local.set 2) | EmptyStack | 3 |-> 10 > =>* < nil | EmptyStack | 2 |-> 10  3 |-> 10 > .

rew < (local.get 3) (local.get 2) (local.tee 2) | EmptyStack | 2 |-> 11, 3 |-> 10 > .
search < (local.get 3) (local.get 2) (local.tee 2) | EmptyStack | 2 |-> 11, 3 |-> 10 > =>* < nil | 11 $ 10 | 2 |-> 11, 3 |-> 10 > .

rew < (local.get 2) (local.tee 2) (local.set 3) | EmptyStack | 2 |-> 11, 3 |-> 10 > .
search < (local.get 2) (local.tee 2) (local.set 3) | EmptyStack | 2 |-> 11, 3 |-> 10 > =>* < nil | EmptyStack | 2 |-> 11, 3 |-> 11  > .

rew < (local.get 3) (local.get 2) (local.tee 2) (local.set 3) | EmptyStack | 2 |-> 11, 3 |-> 10 > .
search < (local.get 3) (local.get 2) (local.tee 2) (local.set 3) | EmptyStack | 2 |-> 11, 3 |-> 10 > =>* < nil | 10 | 2 |-> 11, 3 |-> 11  > .

rew < (i32.const 20) | EmptyStack | EmptyLocalStore > .
search < (i32.const 20) | EmptyStack | EmptyLocalStore > =>* < nil | 20 | EmptyLocalStore > .

rew < (i32.const 20) (i32.const 10) (i32.add) | EmptyStack | EmptyLocalStore > .

*** AFTER CHANGING SIGNED REPRESENTATION, NEGATIVE VALUES HAD TO BE MODIFIED TO COMPLY WITH THE SPEC 
rew < (i32.const 20) (i32.const 10) (i32.div_u) | EmptyStack | EmptyLocalStore > .
rew < (i32.const 20) (i32.const 10) ("i32.div_u") | EmptyStack | EmptyLocalStore > .
***rew < (i32.const -20) (i32.const 10) ("i32.div_u") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 20) (i32.const 0) ("i32.div_u") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 21) (i32.const 10) ("i32.rem_u") | EmptyStack | EmptyLocalStore > .
***rew < (i32.const -21) (i32.const 10) ("i32.rem_u") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 21) (i32.const 10) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
***rew < (i32.const -21) (i32.const 10) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 4294967275) (i32.const 10) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
***rew < (i32.const 21) (i32.const -10) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 21) (i32.const 4294967286) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
***rew < (i32.const -21) (i32.const -10) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .
rew < (i32.const 4294967275) (i32.const 4294967286) ("i32.rem_s") | EmptyStack | EmptyLocalStore > .

rew < (i32.const 20) (i32.const 10) (local.set 2) (local.set 3) (local.get 2) (local.get 3) (i32.mul) | EmptyStack | EmptyLocalStore > .
search < (i32.const 20) (i32.const 10) (local.set 2) (local.set 3) (local.get 2) (local.get 3) (i32.mul) | EmptyStack | EmptyLocalStore > =>* < nil | 200 | 2 |-> 10, 3 |-> 20  > .
rew < (i32.const 20) (i32.const 10) (local.set 2) (local.set 3) | EmptyStack | EmptyLocalStore > .
rew < (local.get 2) (local.get 3) (i32.mul) | EmptyStack | 2 |-> 10, 3 |-> 20  > .

rew < (i32.const 20) (local.set 2) (local.get 2) (local.set 3) (i32.const 10) (local.set 2) (local.get 2) (local.set 3) | EmptyStack | EmptyLocalStore > .

rew < (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20)| EmptyStack | EmptyLocalStore > .
search < (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20) (i32.const 20)| EmptyStack | EmptyLocalStore > =>* < nil | 20 $ 20 $ 20 $ 20 $ 20 $ 20 | EmptyLocalStore > .

rew < (i32.const 20) (i32.const 10) (local.set 2) (local.set 3) (local.get 2) (local.get 3) (i32.mul) | EmptyStack | EmptyLocalStore > .

red label("step1", 1, (i32.const 20) (i32.const 10)) .
rew < (local.set 2) | label("step1", 1, (i32.const 20) (i32.const 10)) | EmptyLocalStore > .

red if-else(0, nop, nop) .
***rew < (i32.const 20) (i32.const 0) (if (i32.const 20) (local.set 2) else (local.set 3) end) (i32.const 10) | EmptyStack | EmptyLocalStore > .
***rew < (i32.const 20) (i32.const 1) (if (i32.const 20) (local.set 2) else (local.set 3) end) (i32.const 10) | EmptyStack | EmptyLocalStore > .
rew < (i32.const 20) (i32.const 0) (if (i32.const 20) (local.set 2) else (i32.const 30) (local.set 3) end) (i32.const 10) | EmptyStack | EmptyLocalStore > .
rew < (i32.const 20) (i32.const 1) (if (i32.const 20) (local.set 2) else (i32.const 30) (local.set 3) end) (i32.const 10) | EmptyStack | EmptyLocalStore > .

*** Be careful, loop does not terminate. By definition it does not terminate I think.
rew < (loop "loop1" ) (i32.const 20) (if (i32.const 20) (local.set 2) else (i32.const 30) (local.set 3) end) end | EmptyStack | EmptyLocalStore > .

*** Test for br : It should continue from the continuation after the end of the block (assign 3 |-> 15 and 4 |-> 20 )
rew < (i32.const 20) (block "l1" (i32.const 15) (br 0) (local.set 1) (local.set 2)  end) (local.set 3) (local.set 4) | EmptyStack | EmptyLocalStore > .

*** Test br_if
rew < (i32.const 20) (block "l1" (i32.const 15) (i32.const 1) ("br_if" 0) (local.set 1) (local.set 2)  end) (local.set 3) (local.set 4) | EmptyStack | EmptyLocalStore > .
rew < (i32.const 20) (block "l1" (i32.const 15) (i32.const 0) ("br_if" 0) (local.set 1) (i32.const 1)  end)  (block "l2" ("br_if" 0) (local.set 3) (local.set 4) end) | EmptyStack | EmptyLocalStore > .

*** Test TypeDef
red (type 4 (func (param (i32 i32)) (result i32))) .

*** Test FuncDef
red   (func (0) (type 0) (param i32) (result i32) (local i32)  (i32.const 1036) end) .
rew < call 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local i32)  (i32.const 1036) end) .

rew < call 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local i32)  (i32.const 1036) end) .

rew (module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 0 (type 4) (param (i32 i32)) (result i32) (local i32) nop end)) .

rew < (global.set "gb1") | 20 | empty > # ("gb1" |-> 0) <-> (0 |-> {type mut i32 , value 10}) .
***rewrite in WASMMOD : < global.set "gb1" | 20 | empty > # "gb1" |-> 0 <-> 0 |-> {type mut i32, value 10} .
***rewrites: 5 in 0ms cpu (0ms real) (~ rewrites/second)
***result WASMGlobalSim: < nil | EmptyStack | empty > # "gb1" |-> 0 <-> 0 |-> {type mut i32, value 20}

*** The following test should not insert the value (global variable is const, not mutable):
rew < (global.set "gb1") | 20 | empty > # ("gb1" |-> 0) <-> (0 |-> {type const i32 , value 10}) .

*** Test to call a function, creating its own local store based on the function definition (local spec) and without losing old local store and using it again.
*** It can be followed step by step
*** This should create a local store of 4 values after calling function 0 (1 param + 3 locals)
rew < (i32.const 20) (local.set 0) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 i32))  ((i32.const 10) (local.set 0)) end) .


*** Test i32 and i64 bitstring
*** Max i32
red int-to-i32(4294967295) .
red int-to-i32(4294967296) .
*** Max i64
red int-to-i64(18446744073709551615) .
red int-to-i64(18446744073709551616) .

*** Test conversion and reconversion int <-> bitval
red bitstring-to-int(get-bitstring-bitval(int-to-i32(2)), 32) .
***reduce in WASMMOD : bitstring-to-int(get-bitstring-bitval(int-to-i32(2)), 32) .
***rewrites: 418 in 0ms cpu (0ms real) (~ rewrites/second)
***result NzNat: 2

red i32-to-int(int-to-i32(4294967295)) .
***reduce in WASMMOD : i32-to-int(int-to-i32(4294967295)) .
***rewrites: 689 in 0ms cpu (0ms real) (~ rewrites/second)
***result NzNat: 4294967295

red signed(10, 32) .
***reduce in WASMMOD : signed(10, 32) .
***rewrites: 6 in 0ms cpu (0ms real) (~ rewrites/second)
***result NzNat: 10
red signed(4294967295, 32) .
***reduce in WASMMOD : signed(4294967295, 32) .
***rewrites: 13 in 0ms cpu (0ms real) (~ rewrites/second)
***result NzInt: -1
red signed(4294967294, 32) .
***reduce in WASMMOD : signed(4294967294, 32) .
***rewrites: 13 in 0ms cpu (0ms real) (~ rewrites/second)
***result NzInt: -2

red unsigned(signed(4294967295, 32), 32) .

*** TEST OPERATIONS WITH INTS AND FLOATS
Maude> rew < (i32 .const 20) (i32 .const 10) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrite in WASMMOD : < (i32 .const 20) (i32 .const 10) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrites: 51 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMLocalSim: < nil | const(i32, val(30)) | empty >
Maude> rew < (i32 .const 20) (i32 .const 10) (i32 . mul) | EmptyStack | EmptyLocalStore > .
rewrite in WASMMOD : < (i32 .const 20) (i32 .const 10) (i32 . mul) | EmptyStack | EmptyLocalStore > .
rewrites: 51 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMLocalSim: < nil | const(i32, val(200)) | empty >
Maude> rew < (i32 .const 20) (i32 .const 10.0) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrite in WASMMOD : < (i32 .const 20) (i32 .const 1.0e+1) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrites: 1 in 0ms cpu (0ms real) (~ rewrites/second)
result [Rat,WASMLocalSim,FindResult,ValRef,Addr,Id,Arity]: < (i32 .const 20) (i32 .const 1.0e+1) (i32 . add) | EmptyStack | empty >
Maude> rew < (i32 .const 20) (f32 .const 10.0) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrite in WASMMOD : < (i32 .const 20) (f32 .const 1.0e+1) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrites: 25 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMLocalSim: < i32 . add | const(f32, val(1.0e+1)) $ const(i32, val(20)) | empty >
Maude> rew < (f32 .const 20) (f32 .const 10.0) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrite in WASMMOD : < (f32 .const 20) (f32 .const 1.0e+1) (i32 . add) | EmptyStack | EmptyLocalStore > .
rewrites: 20 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMLocalSim: < i32 . add | const(f32, val(1.0e+1)) $ const(f32, val(2.0e+1)) | empty >

rew run-nomodule((f32 .const 0) (f32 .const 30.0) (f32 . sub)) .
rew run-nomodule((f32 .const 10) (f32 .const 30.0) (f32 . mul)) .

Maude> rew run-nomodule((i32 .const 10) (i32 .const 30) (i32 . eq)) .
rewrite in WASMMOD : run-nomodule((i32 .const 10) (i32 .const 30) (i32 . eq)) .
rewrites: 47 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((0).Zero)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((i32 .const 30) (i32 .const 30) (i32 . eq)) .
rewrite in WASMMOD : run-nomodule((i32 .const 30) (i32 .const 30) (i32 . eq)) .
rewrites: 47 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((1).NzNat)) | empty > # empty <-> empty # empty

*** More tests on comparisons with FLOATS
Maude> rew run-nomodule((f32 .const 30) (f32 .const 30) (i32 . ne)) .
rewrite in WASMMOD : run-nomodule((f32 .const 30) (f32 .const 30) (i32 . ne)) .
rewrites: 53 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < i32 . ne | const(f32, val(3.0e+1)) $ const(f32, val(3.0e+1)) | empty > # empty <->   
    empty # empty
Maude> rew run-nomodule((f32 .const 30) (f32 .const 30) (f32 . ne)) .
rewrite in WASMMOD : run-nomodule((f32 .const 30) (f32 .const 30) (f32 . ne)) .
rewrites: 63 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(f32, val((0).Zero)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f32 .const 30) (f32 .const 30.0) (f32 . ne)) .
rewrite in WASMMOD : run-nomodule((f32 .const 30) (f32 .const 3.0e+1) (f32 . ne)) .
rewrites: 62 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(f32, val((0).Zero)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f32 .const 30) (f32 .const 30.1) (f32 . ne)) .
rewrite in WASMMOD : run-nomodule((f32 .const 30) (f32 .const 3.0100000000000001e+1) (f32 . ne)) .
rewrites: 62 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(f32, val((1).NzNat)) | empty > # empty <-> empty # empty


*** TEST BR IF NEW SYNTAX
Maude> rew run-nomodule((i32 .const 20) (block "l1" (i32 .const 15) (i32 .const 0) ("br_if" 0) (local.set 1) (i32 .const 1)  end)) .
rewrite in WASMMOD : run-nomodule((i32 .const 20) block "l1" (i32 .const 15) (i32 .const (0).Zero) "br_if" 0 local.set 1 (i32 .const (1).NzNat) end) .
rewrites: 77 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((1).NzNat)) $ const(i32, val(20)) | 1 |-> const(i32, val(15)) > # empty <-> empty # empty
Maude> rew run-nomodule((i32 .const 20) (block "l1" (i32 .const 15) (i32 .const 1) ("br_if" 0) (local.set 1) (i32 .const 1)  end)) .
rewrite in WASMMOD : run-nomodule((i32 .const 20) block "l1" (i32 .const 15) (i32 .const (1).NzNat) "br_if" 0 local.set 1 (i32 .const (1).NzNat) end) .
rewrites: 56 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(15)) $ const(i32, val(20)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((i32 .const 20) (block "l1" (i32 .const 15) (f32 .const 0) ("br_if" 0) (local.set 1) (i32 .const 1)  end)) .
rewrite in WASMMOD : run-nomodule((i32 .const 20) block "l1" (i32 .const 15) (f32 .const (0).Zero) "br_if" 0 local.set 1 (i32 .const (1).NzNat) end) .
rewrites: 47 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < "br_if" 0 local.set 1 (i32 .const (1).NzNat) end | const(f32, val(zero(pos))) $ const(i32, val(15)) $ label("l1", nil) $ const(i32, val(20)) |
    empty > # empty <-> empty # empty


rew run-nomodule((i32 .const 10) (i32 .const 10) (i32 . and)) .
rew run-nomodule((f32 .const 10) (f32 .const 10) (f32 . div)) .
rew run-nomodule((f32 .const 10) (f32 .const 11) (f32 . min)) .
rew run-nomodule((f32 .const 10) (f32 .const -11) (f32 . copysign)) .
rew run-nomodule((f32 .const -1) (f32 . sqrt)) .

*** TEST COMPARISON FLOATS
Maude> rew run-nomodule((f32 .const 8) (f32 .const 7) (f32 . gt)) .
rewrite in WASMMOD : run-nomodule((f32 .const 8) (f32 .const 7) (f32 . gt)) .
rewrites: 69 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((1).NzNat)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f32 .const 8) (f32 .const 7) (f32 . lt)) .
rewrite in WASMMOD : run-nomodule((f32 .const 8) (f32 .const 7) (f32 . lt)) .
rewrites: 69 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((0).Zero)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f32 .const 8) (f32 .const 8.0) (f32 . ge)) .
rewrite in WASMMOD : run-nomodule((f32 .const 8) (f32 .const 8.0) (f32 . ge)) .
rewrites: 68 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val((1).NzNat)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f32 .const 8) (f32 .const 8.0) (f32 . ge)) . 

*** TEST PARAMETRIC FUNCTIONS
rewrite in WASMMOD : run-nomodule((f32 .const 30) (f32 .const 20) (f32 .const 10) drop (i32 .const 5) select) .
rewrites: 98 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(f32, val(3.0e+1)) | empty > # empty <-> empty # empty

*** TEST BITWISE OPERATORS
rewrite in WASMMOD : run-nomodule((i32 .const 8) (i32 .const 7) (i32 . xor)) .
rewrites: 797 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(15)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((i32 .const 8) (i32 .const 1) (i32 . or)) .
rewrite in WASMMOD : run-nomodule((i32 .const 8) (i32 .const (1).NzNat) (i32 . or)) .
rewrites: 779 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(9)) | empty > # empty <-> empty # empty

*** TEST TYPE CONVERSIONS
Maude> rew run-nomodule((i64 .const 10) (i32 . "wrap_" i64)) .
rewrite in WASMMOD : run-nomodule((i64 .const 10) (i32 . "wrap_" i64)) .
rewrites: 34 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(10)) | empty > # empty <-> empty # empty
Maude> rew run-nomodule((f64 .const 10) (f32 . "demote_" f64)) .
rewrite in WASMMOD : run-nomodule((f64 .const 10) (f32 . "demote_" f64)) .
rewrites: 50 in 0ms cpu (0ms real) (~ rewrites/second)
result [WASMFuncGlobalSim]: < nil | const(i32, val(const(f32, val(1.0e+1)))) | empty > # empty <-> empty # empty 
Maude> rew run-nomodule((f32 .const 10) (f64 . "promote_" f32)) .
rewrite in WASMMOD : run-nomodule((f32 .const 10) (f64 . "promote_" f32)) .
rewrites: 42 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(1.0e+1)) | empty > # empty <-> empty # empty

*** TEST TYPED FUNCTION CALL
Maude> rew < (i32 .const 20) (local.set 0) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 i32))  ((i32 .const 10) (local.set 0)) end) .
rewrite in WASMMOD : < (i32 .const 20) local.set 0 call 0 local.get 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 i32)) ((i32 .const 10) local.set 0) end .
rewrites: 143 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(20)) | 0 |-> const(i32, val(20)) > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 i32)) ((i32 .const 10) local.set 0) end

***
rew < (i32 .const 20) (local.set 0) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 f32))  ((i32 .const 10) (local.set 0)) end) .
*** AT SOME POINT: < local.set 0 exit-func end | st-push(label("func", local.get 0), const(i32, val(10))) | (0 |-> const(i32, val((0).Zero)), 1 |-> const(f32, val(0.0)), 2 |-> const(i32, val((0).Zero)), 3 |-> const(i32, val((0).Zero))) (0 |-> const(i32, val(20))) >

*** Calls only reduce when assert over the stack is true
Maude> rew < (i32 .const 20) (local.set 0) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 f32))  ((i32 .const 10) (local.set 0)) end) .
rewrite in WASMMOD : < (i32 .const 20) local.set 0 call 0 local.get 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end .
rewrites: 28 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < call 0 local.get 0 | EmptyStack | 0 |-> const(i32, val(20)) > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end
Maude> rew < (i32 .const 20) (local.set 0) (i32 .const 15) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 f32))  ((i32 .const 10) (local.set 0)) end) .
rewrite in WASMMOD : < (i32 .const 20) local.set 0 (i32 .const 15) call 0 local.get 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end .
rewrites: 151 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(20)) $ st-popN(EmptyStack, 0) | 0 |-> const(i32, val(20)) > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end

*** TEST WITH CONSUMABLE TYPED PARAMS
Maude> rew < (i32 .const 20) (local.set 0) (i32 .const 15) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param i32) (result i32) (local (i32 i32 f32))  ((i32 .const 10) (local.set 0)) end) .
rewrite in WASMMOD : < (i32 .const 20) local.set 0 (i32 .const 15) call 0 local.get 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end .
rewrites: 140 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(20)) | 0 |-> const(i32, val(20)) > # empty <-> empty # 0 |-> func 0 (type 0) (param i32) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end
Maude> rew < (i32 .const 20) (local.set 0) (i32 .const 15) (f32 .const 25.5) call 0 (local.get 0) | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> (func (0) (type 0) (param (f32 i32)) (result i32) (local (i32 i32 f32))  ((i32 .const 10) (local.set 0)) end) .
rewrite in WASMMOD : < (i32 .const 20) local.set 0 (i32 .const 15) (f32 .const 2.55e+1) call 0 local.get 0 | EmptyStack | EmptyLocalStore > # empty <-> empty # 0 |-> func 0 (type 0) (param (f32 i32)) (result i32) (local (i32 i32 f32)) ((i32 .const 10)
    local.set 0) end .
rewrites: 174 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMFuncGlobalSim: < nil | const(i32, val(20)) | 0 |-> const(i32, val(20)) > # empty <-> empty # 0 |-> func 0 (type 0) (param (f32 i32)) (result i32) (local (i32 i32 f32)) ((i32 .const 10) local.set 0) end

*** TEST EXECUTE MODULES
rew run-module-func((module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 0 (type 4) (param (i32 i32)) (result i32) (local i32) nop end)), 0) .

rew run-module-func((module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 4 (type 0) (param nil) (result i32) (local i32) nop end)), 0) .


{start N, indctr Ctr} # (module (TypeDef TypeDefL) FuncDefL GlobalDefL) # < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
rew {start 4, indctr 0} # (module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1")) end) (global "gb1" (mut i32) (i32 .const 1))) # < uninitialized | EmptyStack | empty > # empty <-> empty # empty # empty # .

*** TEST MODULE WITH GLOBALS
Maude> rew run-module-func((module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1")) end) (global "gb1" (mut i32) (i32 .const 1))), 0) .
rewrites: 85 in 10ms cpu (7ms real) (8500 rewrites/second)
result WASMSimTrigger: {start 0, indctr 0} # module nil nil nil # < nil | EmptyStack | empty > # "gb1" |-> 1 <-> 1 |-> {type mut i32, value const(i32, val(10))} # 0 |-> func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1") end 
    # (0 |-> type 3 func param i32 result i32, 1 |-> type 4 func param (i32 i32) result i32, 2 |-> type 5 func param (i32 i32 i32) result i32, 3 |-> type 6 func param (i32 i64 i32) result i64) #

*** Now functions are stored by their id
rew run-module-func((module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1")) end) (global "gb1" (mut i32) (i32 .const 1))), 4) .
rewrite in WASMMOD : run-module-func(module (type 3 func param i32 result i32) (type 4 func param (i32 i32) result i32) (type 5 func param (i32 i32 i32) result i32) (
    type 6 func param (i32 i64 i32) result i64) func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1") end global "gb1"(mut i32)(i32
    .const (1).NzNat), 4) .
rewrites: 94 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMSimTrigger: {start 4, indctr 0} # module nil nil nil # < nil | EmptyStack | empty > # "gb1" |-> 0 <-> 0 |-> {type mut i32, value const(i32, val(10))} # 4
    |-> func 4 (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1") end # (0 |-> type 3 func param i32 result i32, 1 |-> type 4 func param
    (i32 i32) result i32, 2 |-> type 5 func param (i32 i32 i32) result i32, 3 |-> type 6 func param (i32 i64 i32) result i64) #

*** TEST resolve function name
Maude> rew run-module-func((module  (type 3 (func (param i32) (result i32)))  (type 4 (func (param (i32 i32)) (result i32)))  (type 5 (func (param (i32 i32 i32)) (result i32)))  (type (6) (func (param (i32 i64 i32)) (result i64)))  (func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1")) end) (global "gb1" (mut i32) (i32 .const 1))), "start") .
rewrite in WASMMOD : run-module-func(module (type 3 func param i32 result i32) (type 4 func param (i32 i32) result i32) (type 5 func param (i32 i32 i32) result i32) (
    type 6 func param (i32 i64 i32) result i64) func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1") end global "gb1"(mut
    i32)(i32 .const (1).NzNat), "start") .
rewrites: 99 in 1ms cpu (0ms real) (99000 rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {funcIndCtx "start" |-> 0} < nil | EmptyStack | empty > # "gb1" |-> 0 <-> 0 |-> {type mut i32,
    value const(i32, val(10))} # 0 |-> func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1") end # (0 |-> type 3 func param
    i32 result i32, 1 |-> type 4 func param (i32 i32) result i32, 2 |-> type 5 func param (i32 i32 i32) result i32, 3 |-> type 6 func param (i32 i64 i32) result i64)
    #

rew run-module-func((module  (type 3 (func (param i32) (result i32))) (func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1") (global.get "gb1") (call "isEven") ) end) (func "isEven" (type 0) (param i32) (result i32) (local i32) ((local.get 0) (i32 .const 2) (i32 . "rem_u") (i32 . eqz) (global.set "gb1") ) end) (global "gb1" (mut i32) (i32 .const 1))), "start") .

*** [IMP] TEST isEven:
*** - Start function puts a number in stack, then calls isEven function. isEven loads the number as a local parameter, computes the operation to check if it is even and stores the result in global variable "gb1"
Maude> rew run-module-func((module  (type 3 (func (param i32) (result i32))) (func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) (global.set "gb1") (global.get "gb1") (call "isEven") ) end) (func "isEven" (type 0) (param i32) (result i32) (local i32) ((local.get 0) (i32 .const 2) (i32 . "rem_u") (i32 . eqz) (global.set "gb1") ) end) (global "gb1" (mut i32) (i32 .const 1))), "start") .
rewrite in WASMMOD : run-module-func(module type 3 func param i32 result i32 func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set
    "gb1" global.get "gb1" call "isEven") end func "isEven" (type 0) (param i32) (result i32) (local i32) (local.get 0 (i32 .const 2) (i32 . ("rem_u").IBinopToken) (
    i32 . eqz) global.set "gb1") end global "gb1"(mut i32)(i32 .const (1).NzNat), "start") .
rewrites: 184 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {funcIndCtx "isEven" |-> 2, "start" |-> 1} < nil | EmptyStack | empty > # "gb1" |-> 0 <-> 0
    |-> {type mut i32, value const(i32, val((1).NzNat))} # (1 |-> func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 10) global.set "gb1"
    global.get "gb1" call "isEven") end, 2 |-> func "isEven" (type 0) (param i32) (result i32) (local i32) (local.get 0 (i32 .const 2) (i32 . ("rem_u").IBinopToken) (
    i32 . eqz) global.set "gb1") end) # 0 |-> type 3 func param i32 result i32 #
Maude> rew run-module-func((module  (type 3 (func (param i32) (result i32))) (func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 11) (global.set "
gb1") (global.get "gb1") (call "isEven") ) end) (func "isEven" (type 0) (param i32) (result i32) (local i32) ((local.get 0) (i32 .const 2) (i32 . "rem_u") (i32 . eqz) 
(global.set "gb1") ) end) (global "gb1" (mut i32) (i32 .const 1))), "start") .
rewrite in WASMMOD : run-module-func(module type 3 func param i32 result i32 func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 11) global.set
    "gb1" global.get "gb1" call "isEven") end func "isEven" (type 0) (param i32) (result i32) (local i32) (local.get 0 (i32 .const 2) (i32 . ("rem_u").IBinopToken) (
    i32 . eqz) global.set "gb1") end global "gb1"(mut i32)(i32 .const (1).NzNat), "start") .
rewrites: 184 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {funcIndCtx "isEven" |-> 2, "start" |-> 1} < nil | EmptyStack | empty > # "gb1" |-> 0 <-> 0
    |-> {type mut i32, value const(i32, val((0).Zero))} # (1 |-> func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 11) global.set "gb1"
    global.get "gb1" call "isEven") end, 2 |-> func "isEven" (type 0) (param i32) (result i32) (local i32) (local.get 0 (i32 .const 2) (i32 . ("rem_u").IBinopToken) (
    i32 . eqz) global.set "gb1") end) # 0 |-> type 3 func param i32 result i32 #

*** Structured
*** IsEven
rew run-module-func(
    (module
      (type 3 (func (param i32) (result i32)))
      (func "start" (type 0) (param nil) (result i32)
       (local i32)
        (
            (i32 .const 10) (global.set "gb1") (global.get "gb1") (call "isEven")
        )
        end)
      (func "isEven" (type 0) (param i32) (result i32)
       (local i32)
        (
            (local.get 0) (i32 .const 2) (i32 . "rem_u") (i32 . eqz) (global.set "gb1")
        )
        end)
      (global "gb1" (mut i32) (i32 .const 1)))
    , "start") .


***Previous test:
*** TEST PASSED!!! (computes factorial of number introduced by start function (could be retrieved directly from global var) and stores it in global var "result")
rewrites: 758 in 340ms cpu (1591ms real) (2229 rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {funcIndCtx "factorial" |-> 2, "start" |-> 1} < nil | EmptyStack | empty > # "gb1" |-> 0, "result" |-> 1 <-> (0 |-> {type mut i32, value const(i32, val(5))}, 1 |-> {type    
    mut i32, value const(i32, val(120))}) # (1 |-> func "start" (type 0) (param nil) (result i32) (local i32) ((i32 .const 5) global.set "gb1" global.get "gb1" call "factorial" global.set "result") end, 2 |-> func "factorial" (type 0) (param    
    i32) (result i32) (local i32) ((i32 .const (0).Zero) local.get 0 (i32 . eq) (if i32 .const (1).NzNat else local.get 0 local.get 0 (i32 .const (1).NzNat) (i32 . sub) call "factorial" (i32 . mul) end)) end) # 0 |-> type 3 func param i32       
    result i32 #      

*** Factorial (recursive)
rew run-module-func(
    (module
      (type "type0" (func ((result i32))))
      (type "type1" (func ((param i32) (result i32))))
      (func "start"
       (local i32)
        (
            (i32 .const 5)
            (global.set "gb1")
            (global.get "gb1")
            (call "factorial")
            (global.set "result")
        )
        end)
      (func "factorial" ((type "type1"))
       (local i32)
        (
            (i32 .const 0)
            (local.get 0)
            (i32 . eq)
            (if (type 0)
                (i32 .const 1)
            else
                (local.get 0)
                (local.get 0)
                (i32 .const 1)
                (i32 . sub)
                (call "factorial")
                (i32 . mul)
            end)
        )
        end)
      (global "gb1" (mut i32) (i32 .const 1))
      (global "result" (mut i32) (i32 .const 1)))
    , "start") .


[NEW] Now results are checked on return from function and on blocks
Maude> rew run-module-func(    (module      (type "type0" (func ((result i32))))      (type "type1" (func ((param i32) (result i32))))      (func "start"       (local i32)        (            (i32 .const 5)            (global.set "gb1")            (global.get "gb1")            (call "factorial")            (global.set "result")        )        end)      (func "factorial" ((type "type1"))       (local i32)        (            (i32 .const 0)            (local.get 0)            (i32 . eq)            (if (type 0)        
        (i32 .const 1)            else                (local.get 0)                (local.get 0)                (i32 .const 1)                (i32 . sub)                (call "factorial")                (i32 . mul)            end)        )        end)      (global "gb1" (mut i32) (i32 .const 1))      (global "result" (mut i32) (i32 .const 1)))    , "start") .
rewrite in WASMMOD : run-module-func(module (type "type0" func result i32) (type "type1" func (param i32 result i32)) func "start" (local i32) ((i32 .const 5) global.set "gb1" global.get "gb1" call "factorial" global.set "result") end func "factorial" (type
    "type1") (local i32) ((i32 .const (0).Zero) local.get 0 (i32 . eq) (if type (0).Zero i32 .const (1).NzNat else local.get 0 local.get 0 (i32 .const (1).NzNat) (i32 . sub) call "factorial" (i32 . mul) end)) end global "gb1"(mut i32)(i32 .const (1).NzNat)     
    global "result"(mut i32)(i32 .const (1).NzNat), "start") .
rewrites: 851 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {typeIndCtx "type0" |-> 0, "type1" |-> 1} {funcIndCtx "factorial" |-> 1, "start" |-> 0} < nil | EmptyStack | empty > # ("gb1" |-> 0, "result" |-> 1) <-> (0 |-> {type mut i32, value const(  
    i32, val(5))}, 1 |-> {type mut i32, value const(i32, val(120))}) # (0 |-> func "start" (param nil result nil) (local i32) ((i32 .const 5) global.set "gb1" global.get "gb1" call "factorial" global.set "result") end, 1 |-> func "factorial" (param i32 result  
    i32) (local i32) ((i32 .const (0).Zero) local.get 0 (i32 . eq) (if type (0).Zero i32 .const (1).NzNat else local.get 0 local.get 0 (i32 .const (1).NzNat) (i32 . sub) call "factorial" (i32 . mul) end)) end) # (0 |-> type "type0" func result i32, 1 |-> type  
    "type1" func (param i32 result i32)) #


*** [OLD] [09/03] TEST PASSED: Factorial function execution with function type-checking. Possibility to declare type reference or inline type definition

 Maude> rew run-module-func(    (module      (type "type0" (func ((result i32))))      (type "type1" (func ((param i32))))      (func "start" ((type "type0") (result i32))       (local i32)        (            (i32 .const 5)            (global.set "gb1")        
    (global.get "gb1")            (call "factorial")            (global.set "result")        )        end)      (func "factorial" ((type "type1"))       (local i32)        (            (i32 .const 0)            (local.get 0)            (i32 . eq)            (if                (i32 .const 1)            else                (local.get 0)                (local.get 0)                (i32 .const 1)                (i32 . sub)                (call "factorial")                (i32 . mul)            end)        )        end)  
    (global "gb1" (mut i32) (i32 .const 1))      (global "result" (mut i32) (i32 .const 1)))    , "start") .
rewrite in WASMMOD : run-module-func(module (type "type0" func result i32) (type "type1" func param i32) func "start" (type "type0" result i32) (local i32) ((i32 .const 5) global.set "gb1" global.get "gb1" call "factorial" global.set "result") end func
    "factorial" (type "type1") (local i32) ((i32 .const (0).Zero) local.get 0 (i32 . eq) (if i32 .const (1).NzNat else local.get 0 local.get 0 (i32 .const (1).NzNat) (i32 . sub) call "factorial" (i32 . mul) end)) end global "gb1"(mut i32)(i32 .const (1).NzNat) 
    global "result"(mut i32)(i32 .const (1).NzNat), "start") .
rewrites: 788 in 0ms cpu (0ms real) (~ rewrites/second)
result WASMSimTrigger: {start "start", indctr 0} # module nil nil nil # {typeIndCtx "type0" |-> 0, "type1" |-> 1} {funcIndCtx "factorial" |-> 1, "start" |-> 0} < nil | EmptyStack | empty > # "gb1" |-> 0, "result" |-> 1 <-> (0 |-> {type mut i32, value const(    
    i32, val(5))}, 1 |-> {type mut i32, value const(i32, val(120))}) # (0 |-> func "start" (result i32) (local i32) ((i32 .const 5) global.set "gb1" global.get "gb1" call "factorial" global.set "result") end, 1 |-> func "factorial" (param i32) (local i32) ((   
    i32 .const (0).Zero) local.get 0 (i32 . eq) (if i32 .const (1).NzNat else local.get 0 local.get 0 (i32 .const (1).NzNat) (i32 . sub) call "factorial" (i32 . mul) end)) end) # (0 |-> type "type0" func result i32, 1 |-> type "type1" func param i32) #

*** erew metaParse(['WASMMOD], tokenize-wasm(run-func-from-file("examples/factorial_adapt.wat")), 'WASMModule) .
*** red downTerm('module___['__['type__['"type0".String, 'func_['result_['i32.IntTypeToken]]], 'type__['"type1".String, 'func_['__['param_['i32.IntTypeToken], 'result_['i32.IntTypeToken]]]]], '__['func___end['"start".String, 'local_[    'i32.IntTypeToken], '__['_.const_['i32.IntTypeToken, 's_^5['0.Zero]], '__['global.set_['"gb1".String], '__['global.get_['"gb1".String], '__['call_['"factorial".String], 'global.set_['"result".String]]]]]], 'func____end['"factorial".String,      'type_['"type1".String], 'local_['i32.IntTypeToken], '__['_.const_['i32.IntTypeToken, '0.Zero], '__['local.get_['0.Zero], '__['_._['i32.IntTypeToken, 'eq.RelopToken], 'if__else_['type_['0.Zero], '_.const_['i32.IntTypeToken, 's_['0.Zero]],       '__['local.get_['0.Zero], '__['local.get_['0.Zero], '__['_.const_['i32.IntTypeToken, 's_['0.Zero]], '__['_._['i32.IntTypeToken, 'sub.BinopToken], '__['call_['"factorial".String], '__['_._['i32.IntTypeToken, 'mul.BinopToken],    'end.Inst]]]]]]]]]]]], '__['global_`(_`)`(_`)['"gb1".String, 'mut_['i32.IntTypeToken], '_.const_['i32.IntTypeToken, 's_['0.Zero]]], 'global_`(_`)`(_`)['"result".String, 'mut_['i32.IntTypeToken], '_.const_['i32.IntTypeToken, 's_[    '0.Zero]]]]], 'error) .


[NOTE]
Due to file parser using rew rules, it messes up with the downTerm eq logic. In 2 steps it works:
erew getTerm(metaParse(['WASMMOD], tokenize-wasm(run-func-from-file("examples/factorial_adapt.wat")), 'WASMModule)) .

search run-module-func(downTerm('module_['__['type__['"type0".String, 'func_['result_['i32.IntTypeToken]]], '__['type__['"type1".String, 'func_['__['param_['i32.IntTypeToken], 'result_['i32.IntTypeToken]]]], '__['func___end['"start".String, 'local_['i32.IntTypeToken], '__[     '_.const_['i32.IntTypeToken, 's_^5['0.Zero]], '__['global.set_['"gb1".String], '__['global.get_['"gb1".String], '__['call_['"factorial".String], 'global.set_['"result".String]]]]]], '__['func____end['"factorial".String, 'type_['"type1".String], 'local_[     'i32.IntTypeToken], '__['_.const_['i32.IntTypeToken, '0.Zero], '__['local.get_['0.Zero], '__['_._['i32.IntTypeToken, 'eq.RelopToken], 'if__else_['i32.IntTypeToken, '_.const_['i32.IntTypeToken, 's_['0.Zero]], '__['local.get_['0.Zero], '__['local.get_[ '0.Zero], '__['_.const_['i32.IntTypeToken, 's_['0.Zero]], '__['_._['i32.IntTypeToken, 'sub.BinopToken], '__['call_['"factorial".String], '__['_._['i32.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]]]]]]]], '__['global_`(_`)`(_`)['"gb1".String, '__[   
 'mut.MutGlobalTypeIndicator, 'i32.IntTypeToken], '_.const_['i32.IntTypeToken, 's_['0.Zero]]], 'global_`(_`)`(_`)['"result".String, '__['mut.MutGlobalTypeIndicator, 'i32.IntTypeToken], '_.const_['i32.IntTypeToken, 's_['0.Zero]]]]]]]]], error), "start") =>! w:[WASMSimTrigger] .

search run-module-func(downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm(run-func-from-file("examples/factorial_adapt.wat")), 'WASMModule)), error), "start") =>! w:[WASMSimTrigger] .

erew search-with-func-from-file("examples/factorial_adapt.wat", "start", '_['w:WASMSimTrigger], nil, '!, unbounded, 0) .

red downTerm('__['`{_`,indctr_`}['start_['"start".String], '`[_`,_`,_`]['s_^2['0.Zero], 's_^2['0.Zero], 's_^2['0.Zero]]], '#_#_#['module_['EmptyMod.EmptyMod], '__['`{typeIndCtx_`}['_`,_['_|->_['"type0".String, '0.Zero], '_|->_['"type1".String, 's_[      
 '0.Zero]]]], '_#_['__['`{funcIndCtx_`}['_`,_['_|->_['"factorial".String, '0.Zero], '_|->_['"start".String, 's_['0.Zero]]]], '_#_['_#_['<_|_|_>['nil.List`{Inst`}, 'EmptyStack.EmptyStack, 'empty.Map`{ValRef`,Value`}], '_<->_['_`,_['_|->_['"gb1".String,
 '0.Zero], '_|->_['"result".String, 's_['0.Zero]]], '_`,_['_|->_['0.Zero, '`{type_`,value_`}['__['mut.MutGlobalTypeIndicator, 'i32.IntTypeToken], 'const['i32.IntTypeToken, 'val['s_^5['0.Zero]]]]], '_|->_['s_['0.Zero], '`{type_`,value_`}['__[    'mut.MutGlobalTypeIndicator, 'i32.IntTypeToken], 'const['i32.IntTypeToken, 'val['s_^120['0.Zero]]]]]]]], '_`,_['_|->_['0.Zero, 'func____end['"factorial".String, '__['param_['i32.IntTypeToken], 'result_['i32.IntTypeToken]], 'local_['i32.IntTypeToken], '__[      '_.const_['i32.IntTypeToken, '0.Zero], 'local.get_['0.Zero], '_._['i32.IntTypeToken, 'eq.RelopToken], 'if__else_['result_['i32.IntTypeToken], '_.const_['i32.IntTypeToken, 's_['0.Zero]], '__['local.get_['0.Zero], 'local.get_['0.Zero], '_.const_[    'i32.IntTypeToken, 's_['0.Zero]], '_._['i32.IntTypeToken, 'sub.BinopToken], 'call_['"factorial".String], '_._['i32.IntTypeToken, 'mul.BinopToken], 'end.Inst]]]]], '_|->_['s_['0.Zero], 'func____end['"start".String, '__['param_['nil.List`{TypeToken`}],           'result_['nil.List`{TypeToken`}]], 'local_['i32.IntTypeToken], '__['_.const_['i32.IntTypeToken, 's_^5['0.Zero]], 'global.set_['"gb1".String], 'global.get_['"gb1".String], 'call_['"factorial".String], 'global.set_['"result".String]]]]]]], '_`,_['_|->_[          '0.Zero, 'type__['"type0".String, 'func_['result_['i32.IntTypeToken]]]], '_|->_['s_['0.Zero], 'type__['"type1".String, 'func_['__['param_['i32.IntTypeToken], 'result_['i32.IntTypeToken]]]]]]]]]], errorWASMSimTrigger) .

*** Loads from file and searches with =>!
erew search-with-func-from-file("examples/factorial_adapt.wat", "$start", 'w:WASMSimTrigger, nil, '!, unbounded, 0) . 


[NOTE] Get partial result from search over test with custom syntax:
search [,45] run-factorial =>* w:[WASMSimTrigger] .

search run-factorial =>! w:WASMSimTrigger .

search run-br-test =>! w:WASMSimTrigger .

[Individual parses]
Maude> red downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(global $gb1 (mut i64) (i64.const 1))"), 'GlobalDef)), err:GlobalDef) .
reduce in WASM-FILE-MOD : downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(global $gb1 (mut i64) (i64.const 1))"), 'GlobalDef)), err:GlobalDef) .
rewrites: 310 in 0ms cpu (0ms real) (~ rewrites/second)
result GlobalDef: global "$gb1"(mut i64)(i64 .const (1).NzNat
)
Maude> match (global Id:String (GbType:GlobalType) (ConstInst:ConstInst)) <=? global "$gb1"(mut i64)(i64 .const (1).NzNat) .
match in WASM-FILE-MOD : global Id:String(GbType:GlobalType)(ConstInst:ConstInst) <=? global "$gb1"(mut i64)(i64 .const (1).NzNat
) .
Decision time: 0ms cpu (0ms real)

Matcher 1
Id:String --> "$gb1"
GbType:GlobalType --> mut i64
ConstInst:ConstInst --> i64 .const (1).NzNat


(func $factorial (type $type1)
    (local i32)
    (
        i32.const 0
        local.get 0
        i32.eq
        (if (i32)
            i32.const 1
        else
            local.get 0
            local.get 0
            i32.const 1
            i32. sub
            call $factorial
            i32. mul
        end)
    )
end)

red downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm(
"(func $factorial (type $type1)
    (local i32)
    (
        i32.const 0
        local.get 0
        i32.eq
        (if (i32)
            i32.const 1
        else
            local.get 0
            local.get 0
            i32.const 1
            i32.sub
            call $factorial
            i32.mul
        end)
    )
end)"), 'FuncDef)), err:FuncDef) .

Maude> red downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(func $factorial (type $type1)    (local i32)   
 (        i32.const 0        local.get 0        i32.eq        (if (i32)            i32.const 1        else       
     local.get 0            local.get 0            i32.const 1            i32.sub            call $factorial     
       i32.mul        end)    )end)"), 'FuncDef)), err:FuncDef) .
reduce in WASM-FILE-MOD : downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(func $factorial (type $type1)   
 (local i32)    (        i32.const 0        local.get 0        i32.eq        (if (i32)            i32.const 1    
    else            local.get 0            local.get 0            i32.const 1            i32.sub            call 
$factorial            i32.mul        end)    )end)"), 'FuncDef)), err:FuncDef) .
rewrites: 1085 in 10ms cpu (9ms real) (108500 rewrites/second)
result FuncDef:
func "$factorial" (type "$type1") (local i32)
  (i32 .const (0).Zero
   local.get 0
   i32 . eq
   (if (result i32)
  i32 .const (1).NzNat
   else
  local.get 0
   local.get 0
   i32 .const (1).NzNat
   i32 . sub
   call "$factorial"
   i32 . mul
   (end).Inst
  ))
end

match (func Id:String Type:FuncTypeDef Locals:LocalsRef InstList:List{Inst} end) <=? 
func "$factorial" (type "$type1") (local i32)
  (i32 .const (0).Zero
   local.get 0
   i32 . eq
   (if (result i32)
  i32 .const (1).NzNat
   else
  local.get 0
   local.get 0
   i32 .const (1).NzNat
   i32 . sub
   call "$factorial"
   i32 . mul
   (end).Inst
  ))
end .

red downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm(
"(func $mult (type $type1)
    (local i32)
    (
        local.get 0
        local.get 1
        i32.mul
    )
end)"), 'FuncDef)), err:FuncDef) .

Maude> red downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(func $mult (type $type1)    (local i32)    (        local.get 0        local.get 1        i32.mul    )end)"), 'FuncDef)), err:FuncDef) .
reduce in WASM-FILE-MOD : downTerm(getTerm(metaParse(['WASMMOD], tokenize-wasm("(func $mult (type $type1)    (local i32)    (        local.get 0        local.get 1        i32.mul    )end)"), 'FuncDef)), err:FuncDef) .
rewrites: 516 in 10ms cpu (0ms real) (51600 rewrites/second)
result FuncDef:
func "$mult" (type "$type1") (local i32)
  (local.get 0
   local.get 1
   i32 . mul
  )
end

match (func Id:String Type:FuncTypeDef Locals:LocalsRef InstList:List{Inst} end) <=? 
func "$mult" (type "$type1") (local i32)
  (local.get 0
   local.get 1
   i32 . mul
  )
end .

*** TEST SUITE
erew search-with-func-from-file("test-suite/t.const.wat", "$func0", 'w:WASMSimTrigger, nil, '!, unbounded, 0) .
erew search-with-func-from-file("test-suite/t.unop_0param.wat", "$func0", 'w:WASMSimTrigger, nil, '!, unbounded, 0) .
erew search-with-func-from-file("test-suite/t.unop_1param.wat", "$func0", 'w:WASMSimTrigger, nil, '!, unbounded, 0) .