mod WASMMOD is
  *** RAFAEL MORALES PALACIOS - TFM - SEMANTICS OF WEBASSEMBLY IN MAUDE
  
  *** IMPORT DATATYPE MODULES TO BE USED
  protecting NAT .
  protecting INT .
  protecting STRING .
  
  *** Declare sorts to be used and hierarchy between them.
  sorts WASMSim WASMModule TypeVec NeTypeVec TypeDef Id FuncType FuncVec NeFuncVec FuncDef FuncParamList FuncResult FuncExport ExportVec NeExportVec ExportDef InstList NeInstList Inst EmptyList InstTag ParamList Param Stack EmptyStack NeStack StackElem ValRef ValRefList NeValRefList LocalStore EmptyLocalStore NeLocalStore Assign Value Type IntValue Und Trap Label Arity .
  
  *** Simulator components
  subsorts Stack InstList < WASMSim .
  subsorts EmptyStack NeStack < Stack .
  subsorts EmptyLocalStore NeLocalStore < LocalStore .
  subsorts Assign < NeLocalStore .

  *** Module sections sorts
  subsorts NeTypeVec EmptyList < TypeVec .
  subsorts TypeDef < NeTypeVec .
  subsorts NeFuncVec EmptyList < FuncVec .
  subsorts FuncDef < NeFuncVec .
  subsorts NeExportVec EmptyList < ExportVec .
  subsorts ExportDef < NeExportVec .

  *** Instruction lists sorts
  subsorts NeInstList EmptyList < InstList .
  subsorts Trap < Inst < NeInstList .
  *** TODO: Maybe not needed: 
  subsorts Param < ParamList .
  *** TODO: Include variable references as ValRef 
  subsorts Nat < ValRef < NeValRefList < ValRefList .
  *** TODO: Include support for Labels and Activations as Stack values. Problem now: collision of operator definition on Nat and String
  subsorts Int Und < IntValue < Value < StackElem < NeStack .
  ***subsorts String < Label < StackElem .
  subsorts Nat < Arity .
  subsorts EmptyList < ValRefList .

  op trap : String -> Trap [ctor] .

  op label : String Arity InstList -> Label [ctor] .
 

  op und : -> Und [ctor] .
  op EmptyList : -> EmptyList [ctor] .

  *** TODO: check associativity on funcVec...

  ***op __ : InstList Stack -> WASMSim [assoc comm ctor] .
  *** < InstList | Stack | LocalStore >
  op <_|_|_> : InstList Stack LocalStore -> WASMSim .

  *** LocalStore definition
  op [_<-_] : ValRef Value -> Assign [ctor] .
  op EmptyLocalStore : -> LocalStore [ctor] .
  op __ : Assign LocalStore -> NeLocalStore [assoc comm ctor id: EmptyLocalStore] .  *** Store[n <- v] means local n = v

  *** Module sections
  op (module _ _ _) : TypeVec FuncVec ExportVec -> WASMModule [ctor] .
  op __ : TypeDef TypeVec -> NeTypeVec [assoc ctor id: EmptyList] .
  op __ : FuncDef FuncVec -> NeFuncVec [assoc ctor id: EmptyList] .
  op __ : ExportDef ExportVec -> NeExportVec [assoc ctor id: EmptyList] .

  op (type _ _) : Id FuncType -> TypeDef [ctor] .
  op (func _ _ _ _) : Id FuncParamList FuncResult NeInstList -> FuncDef [ctor] .
  op (export _ _) : Id FuncExport -> ExportDef [ctor] .

  
  *** InstList definition

  op __ : Inst InstList -> NeInstList [assoc ctor id: EmptyList] .
  
  ***op __ : InstTag ParamList -> Inst [ctor] .

  *** op __ : Param ParamList -> ParamList [assoc ctor] .

  *** Stack definition
  op EmptyStack : -> EmptyStack [ctor] .
  op _$_ : StackElem Stack -> NeStack [ctor id: EmptyStack] .


  *** Instruction ops declarations
  op local.get _ : ValRef -> Inst [ctor] .
  op local.set _ : ValRef -> Inst [ctor] .
  op local.tee _ : ValRef -> Inst [ctor] .


  *** TODO: maybe fix to use it as a template??
  *** - The problem is that I think Maude obligues to separate the tokens so it would be like "i32 .const, not i32.const"
  ***op _.const _ : Type Value -> Inst [ctor] .
  op i32.const _ : IntValue -> Inst [ctor] .
  *** TODO: Include more valid types
  ops i32 : -> Type [ctor] .


  *** binop (Binary Operations)
  *** ibinop (Integer binop) - add | sub | mul | div_sx | rem_sx | and | or | xor | shl | shr_sx | rotl | rotr
  op i32.add : -> Inst [ctor] .
  op i32.sub : -> Inst [ctor] .
  op i32.mul : -> Inst [ctor] .
  *** Insts with underscores (_) need to be preprocessed so that Maude does not misinterpret the _ symbol
  op "i32.div_u" : -> Inst [ctor] .
  op "i32.div_s" : -> Inst [ctor] .
  op "i32.rem_u" : -> Inst [ctor] .
  op "i32.rem_s" : -> Inst [ctor] .
  
  *** lookup: auxiliar op to lookup values from store
  op lookup : NeLocalStore ValRef -> Value .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = Val if ValR == ValR2 .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = lookup(LocalSTR, ValR) if ValR =/= ValR2 .
  *** TODO: error otherwise or leave undefined??


  *** Variable definition

  vars I1 S1 : Inst .
  var ValR ValR2 : ValRef .
  var Val : Value .
  var IL : InstList .
  var ST : Stack .
  var NeST : NeStack .
  var LocalSTR : LocalStore .
  var T : Type .
  var IntVal IntVal2 : IntValue .
  var Int1 Int2 : Int .
  var STElem : StackElem .

  *** LocalStore is a Set
  eq [ValR <- Val][ValR <- Val] = [ValR <- Val] .



  *** Rules
  
  *** TODO: Include validation in rules as eqs in preconditions
  *** TODO: Maybe create rules to transform an input of the form of a usual program to this representation with initial empty stack and store??

  *** local.get rule: push to stack the value from ValR from the local store
  rl [local-get] : < (local.get ValR) IL | ST | LocalSTR >   =>   < IL | st-push(ST, lookup(LocalSTR, ValR)) | LocalSTR > .

  *** local.set rule: pop value from stack and store it in ValR in the local store
  rl [local-set] : < (local.set ValR) IL | ST | LocalSTR >   =>   < IL | st-pop(ST) | [ValR <- st-head(ST)]LocalSTR > .
  crl [local-set-ow] : < (local.set ValR) IL | ST | [ValR <- Val]LocalSTR >   =>   < IL | st-pop(ST) | [ValR <- st-head(ST)]LocalSTR > if Val =/= st-head(ST) .
  crl [local-set-ow] : < (local.set ValR) IL | ST | [ValR <- Val]LocalSTR >   =>   < IL | st-pop(ST) | [ValR <- Val]LocalSTR > if Val == st-head(ST)  .

  *** local.tee rule: pop from stack, push value from ValR two times to stack, then execute local.set ValR
  *** TODO: leave the double push like that or use a different op to double push with only one lookup ??
  rl [local.tee] : < (local.tee ValR) IL | ST | LocalSTR >   =>   < (local.set ValR) IL | st-push(st-push(st-pop(ST), lookup(LocalSTR, ValR)), lookup(LocalSTR, ValR)) | LocalSTR > .

  *** t.const rule: push Val of type T to stack
  *** TODO: maybe fix to use it as a template??
  ***rl [t.const] : < (T .const Val) IL | ST | LocalSTR >   =>   < IL | st-push(ST, Val) | LocalSTR > .
  rl [i32.const] : < (i32.const IntVal) IL | ST | LocalSTR >   =>   < IL | st-push(ST, IntVal) | LocalSTR > .

  *** ibinop: pop two int values from stack, operate and push the result to stack
  rl [i32.add] : < (i32.add) IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, (IntVal + IntVal2) rem 2 ^ (32) ) | LocalSTR > .
  *** TODO: check "multiple distinct parses for statement" in sub
  ***rl [i32.sub] : < (i32.sub) IL | IntVal $ IntVal2 $ ST | LocalSTR >   =>   < IL | st-push(ST, (IntVal - IntVal2) rem 2^(32)) | LocalSTR > .
  rl [i32.mul] : < (i32.mul) IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, (IntVal * IntVal2) rem 2 ^ (32)) | LocalSTR > .
  *** Insts with underscores (_) need to be preprocessed so that Maude does not misinterpret the _ symbol
  crl [i32.div_u-und] : < ("i32.div_u") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   trap("Binop result undefined") if IntVal2 == 0 .
  crl [i32.div_u] : < ("i32.div_u") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, abs(IntVal quo IntVal2)) | LocalSTR > if IntVal2 =/= 0 .
  *** TODO: check "multiple distinct parses for statement" in div_s
  ***crl [i32.div_s-und] : < ("i32.div_s") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, und) | LocalSTR > if IntVal2 == 0 or (IntVal quo IntVal2) == 2 ^ (32 - 1) .
  ***crl [i32.div_s] : < ("i32.div_s") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, IntVal quo IntVal2) | LocalSTR > if IntVal2 =/= 0 and (IntVal quo IntVal2) =/= 2 ^ (32 - 1) .
  crl [i32.rem_u-und] : < ("i32.rem_u") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   trap("Binop result undefined")  if IntVal2 == 0 .
  crl [i32.rem_u] : < ("i32.rem_u") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, abs(IntVal rem IntVal2)) | LocalSTR > if IntVal2 =/= 0 .
  crl [i32.rem_s-und] : < ("i32.rem_s") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   trap("Binop result undefined") if IntVal2 == 0 .
  *** By definition: return the rem of dividing the signed representations of j1/j2 w/ the sign of j1 (design decision: compute sign of j1 as (IntVal quo abs(IntVal)))
  crl [i32.rem_s] : < ("i32.rem_s") IL | IntVal2 $ IntVal $ ST | LocalSTR >   =>   < IL | st-push(ST, (IntVal quo abs(IntVal)) * abs((IntVal rem IntVal2))) | LocalSTR > if IntVal2 =/= 0 .


  *** lookup rule: get value from reference from local store
  rl [lookup] : lookup([ValR <- Val] LocalSTR, ValR) => Val .


  *** InstList operations 
  op head : NeInstList -> Inst .
  eq head(I1 IL) = I1 .

  op tail : InstList -> InstList .
  eq tail(I1 IL) = IL .
  eq tail(EmptyList) = EmptyList .

  *** Stack operations
  op st-push : Stack StackElem -> NeStack .
  eq st-push(ST, STElem) = STElem $ ST .
  eq st-push(EmptyStack, STElem) = STElem $ EmptyStack .

  op st-head : NeStack -> StackElem .
  eq st-head(STElem $ ST) = STElem .

  op st-pop : NeStack -> Stack .
  eq st-pop(STElem $ ST) = ST .

  *** Alt def of sub
  ***op sub _ _ : IntValue IntValue -> IntValue [ctor] .
  ***eq sub IntVal IntVal2 = IntVal - IntVal2 .

endm

