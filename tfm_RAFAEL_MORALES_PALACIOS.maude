
mod WASM-FILE-MOD is
  inc FILE . 

  sort CustomOid NullOid .
  subsorts NullOid Oid < CustomOid .
  op nullOid : -> NullOid [ctor] .

  op myClass : -> Cid . 
  op myObj : -> Oid . 
  ops in:_ : CustomOid -> Attribute . 
  ops inFile:_ outText:_ : String -> Attribute . 
  
  vars Text Acc WASMModFile Reason : String . 
  vars FHIn : Oid . 
  var  Attrs : AttributeSet .

  op gen-config : String -> Configuration [ctor] .
  eq gen-config(WASMModFile) = <> 
                               < myObj : myClass | in: nullOid, inFile: WASMModFile, outText: "" > 
                               openFile(fileManager, myObj, WASMModFile, "r") .

  op run-func-from-file : String -> String .
  eq run-func-from-file(WASMModFile) = get-config-text(gen-config(WASMModFile)) .
  
  op get-config-text : Configuration -> String .
  eq get-config-text(<> closedFile(myObj, FHIn) < myObj : myClass | outText: Acc, Attrs > ) = Acc .

  rl < myObj : myClass | in: nullOid, outText: Acc, Attrs > 
      openedFile(myObj, fileManager, FHIn) 
  => < myObj : myClass | in: FHIn, outText: Acc, Attrs > 
      getLine(FHIn, myObj) .
  rl < myObj : myClass | in: nullOid, outText: Acc, Attrs > 
      fileError(myObj, fileManager, Reason) 
  => < myObj : myClass | in: nullOid, outText: Acc, Attrs > .
  rl < myObj : myClass | in: FHIn, outText: Acc, Attrs > 
      gotLine(myObj, FHIn, Text) 
  => < myObj : myClass | in: FHIn, outText: (Acc + Text), Attrs > 
      if Text == "" 
      then closeFile(FHIn, myObj)
      else getLine(FHIn, myObj)
      fi .


endm

fmod WASM-TYPETOKEN-MOD is

  protecting NAT .

  sorts TypeToken IntTypeToken FloatTypeToken .
  subsorts FloatTypeToken IntTypeToken < TypeToken .

  ops i32 i64 : -> IntTypeToken [ctor] .
  ops f32 f64 : -> FloatTypeToken [ctor] .

  var T : TypeToken .

  op bit-width : TypeToken -> Nat .
  eq bit-width(i32) = 32 .
  eq bit-width(f32) = 32 .
  eq bit-width(T) = 64 [owise] .

endfm

view TypeToken from TRIV to WASM-TYPETOKEN-MOD is
  sort Elt to TypeToken .
endv

fmod WASM-BIT-MOD is

  protecting INT .

  sorts Bit .
  ***subsorts Bit < Int .

  ops 0 1 : -> Bit [ctor] .

endfm

view Bit from TRIV to WASM-BIT-MOD is
  sort Elt to Bit .
endv

fmod WASM-BITVAL-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-BIT-MOD .
  protecting INT .
  protecting LIST{Bit} .
  ***protecting FLOAT .
  ***protecting CONVERSION .

  sorts Bini Bini32 Bini64 BitStringSize BitVal .
  ***sorts Binf Binf32 Binf64 ..
  ***subsorts Binf32 Binf64 < Binf < String .
  ***subsort BitStringSize < Int .

  var I I2 : Int .
  var N : Nat .
  var B B1 B2 : Bit .
  var TypeToken : TypeToken .
  var BitList BS BS1 BS2 : List{Bit} .
  ***var F : Float .
  ***var BitStringSize : BitStringSize .

  *** BitVal representation (valid for int and float): contains typetoken for type-checking and bitstring. 
  op {valtype _, bitstring _} : TypeToken List{Bit} -> BitVal [ctor] .

  *** Auxliary functions for getting BitVal propperty values
  op get-type-bitval : BitVal -> TypeToken .
  eq get-type-bitval({valtype TypeToken, bitstring BitList}) = TypeToken .
  op get-bitstring-bitval : BitVal -> List{Bit} .
  eq get-bitstring-bitval({valtype TypeToken, bitstring BitList}) = BitList .

  *** Convert Maude Int to i32 bitstring
  op int-to-i32 : Int -> BitVal [ctor] .
  eq int-to-i32(I) = {valtype i32 , bitstring int-to-bitstring(I, 32)} .

  *** Convert Maude Int to i64 bitstring  
  op int-to-i64 : Int -> BitVal [ctor] .
  eq int-to-i64(I) = {valtype i64, bitstring int-to-bitstring(I, 64)} .

  *** Auxiliary op to convert int to bitstring of certain size
  *** TODO: Manage overflow
  op int-to-bitstring : Int Nat -> List{Bit} [ctor] .
  eq int-to-bitstring(0, 1) = 0 .
  eq int-to-bitstring(0, I2) = padding(I2) 0 [owise] .
  eq int-to-bitstring(1, 1) = 1 .
  eq int-to-bitstring(1, I2) = padding(I2) 1 [owise] .
  ceq int-to-bitstring(I, I2) = int-to-bitstring(I quo 2, I2 - 1) 0 if I rem 2 == 0 and I2 > 1 .
  ceq int-to-bitstring(I, I2) = int-to-bitstring(I quo 2, I2 - 1) 1 if I rem 2 =/= 0 and I2 > 1 .

  *** Front padding for bitstrings
  op padding : Nat -> List{Bit} .
  eq padding(1) = 0 .
  eq padding(N) = padding(N - 1) 0 .


  *** Convert i32 bitstring to Maude Int
  op i32-to-int : BitVal -> Int [ctor] .
  eq i32-to-int({valtype i32 , bitstring BitList}) = bitstring-to-int(BitList, 32) .

  *** Convert i64 bitstring to Maude Int
  op i64-to-int : BitVal -> Int [ctor] .
  eq i64-to-int({valtype i64 , bitstring BitList}) = bitstring-to-int(BitList, 64) .

  *** Convert bitstring to int
  op bitstring-to-int : List{Bit} Nat -> Int .
  eq bitstring-to-int(0 BitList, 1) = 0 .
  eq bitstring-to-int(1 BitList, 1) = 1 .
  ceq bitstring-to-int(0 BitList, I) = bitstring-to-int(BitList, I - 1) if I > 1 .
  ceq bitstring-to-int(1 BitList, I) = ((2 ^ (I - 1)) * 1) + bitstring-to-int(BitList, I - 1) if I > 1 .

  *** Logic operations
  op not _ : List{Bit} -> List{Bit} [ctor] .
  eq not (0) = 1 .
  eq not (1) = 0 .
  eq not (BS 0) = not(BS) 1 .
  eq not (BS 1) = not(BS) 0 .

  op iand : List{Bit} List{Bit} -> List{Bit} [ctor] .
  eq iand(B, 0) = 0 .
  eq iand(0, B) = 0 .
  eq iand(1, 1) = 1 .
  eq iand(BS1 B1, BS2 B2) = iand(BS1, BS2) iand(B1, B2) .

  op ior : List{Bit} List{Bit} -> List{Bit} [ctor] .
  eq ior(B, 0) = B .
  eq ior(0, B) = B .
  eq ior(1, 1) = 1 .
  eq ior(BS1 B1, BS2 B2) = ior(BS1, BS2) ior(B1, B2) .

  op ixor : List{Bit} List{Bit} -> List{Bit} [ctor] .
  eq ixor(0, 0) = 0 .
  eq ixor(0, 1) = 1 .
  eq ixor(1, 0) = 1 .
  eq ixor(1, 1) = 0 .
  eq ixor(BS1 B1, BS2 B2) = ixor(BS1, BS2) ixor(B1, B2) .

  *** string() conversion allows to modify the base of the representation
  ***eq int-to-bitstring(I, BitStringSize) = string(I , 2) .
  ***eq int-to-bitstring(I, BitStringSize) = 
  
  ***op float-to-bitstring : Float BitStringSize -> Binf [ctor] .
  ***eq float-to-bitstring(F, BitStringSize) = string(F) .

endfm


fmod WASM-FUNCTYPE-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting LIST{TypeToken} .

  sorts ParamType ResultType .

  *** NOTE: List{TypeToken} needs to be wrapped on parenthesis for Maude to parse it correctly
  op (param _) : List{TypeToken} -> ParamType [ctor prec 50] .
  op (result _) : List{TypeToken} -> ResultType [ctor prec 50] .

  var T : TypeToken .
  var TList1 TList2 : List{TypeToken} .

  *** Reduce param/result lists when parsing
  ***op _ _ : ParamType ParamType -> ParamType [assoc ctor] .
  ***eq (param TList1) (param TList2) = (param (TList1 TList2)) .
***
  ***op _ _ : ResultType ResultType -> ResultType [assoc ctor] .
  ***eq (result TList1) (result TList2) = (result (TList1 TList2)) .


endfm

view ParamType from TRIV to WASM-FUNCTYPE-MOD is
  sort Elt to ParamType .
endv
view ResultType from TRIV to WASM-FUNCTYPE-MOD is
  sort Elt to ResultType .
endv

fmod WASM-PARAMRESULTTYPE-MOD is

  protecting WASM-FUNCTYPE-MOD .
  ***protecting LIST{ParamType} .
  ***protecting LIST{ResultType} .

  sorts ParamResultType .
  subsorts ParamType ResultType < ParamResultType .

  var ParamType : ParamType .
  var ResultType : ResultType .
  var TList1 TList2 : List{TypeToken} .

  op _ _ : ParamType ResultType -> ParamResultType [ctor] .
  eq (param TList1) (param TList2) = (param (TList1 TList2)) .
  eq (result TList1) (result TList2) = (result (TList1 TList2)) .  

  op getParamType : ParamResultType -> ParamType .
  eq getParamType((param TList1) (result TList2)) = (param TList1) .
  eq getParamType((result TList2)) = (param nil) .

  op getResultType : ParamResultType -> ResultType .
  eq getResultType((param TList1) (result TList2)) = (result TList2) .

  mb (param (TList1 TList2)) : ParamType .
  mb (result (TList1 TList2)) : ResultType .

endfm

fmod WASM-TYPEDEF-MOD is

  protecting NAT .
  protecting STRING .
  protecting WASM-PARAMRESULTTYPE-MOD .

  sorts TypeDef TypeRef Id FuncType ParamResultFuncType .
  subsorts Nat < Id .

  op (type _) : Id -> TypeRef [ctor] .
  op (type _) : String -> TypeRef [ctor] .

  op (func _) : ParamResultType -> FuncType [ctor prec 50] .

  op (type _ _) : Id FuncType -> TypeDef [ctor] .
  op (type _ _) : String FuncType -> TypeDef [ctor] .

  var Id : Id .
  var Str : String .
  var ParamResultType : ParamResultType .

  op get-functype-typedef : TypeDef -> ParamResultType .
  eq get-functype-typedef(type Id (func ParamResultType)) = ParamResultType .
  eq get-functype-typedef(type Str (func ParamResultType)) = ParamResultType .

endfm

view TypeDef from TRIV to WASM-TYPEDEF-MOD is
  sort Elt to TypeDef .
endv

fmod WASM-BLOCKTYPE-MOD is

  protecting WASM-TYPEDEF-MOD .

  sorts BlockType .
  subsorts TypeRef ResultType < BlockType .

endfm

fmod WASM-VALREF-MOD is

  protecting NAT .
  protecting QID .

  sorts ValRef Addr .

  subsorts Nat Qid < ValRef .
  subsorts Nat < Addr .

endfm

view Addr from TRIV to WASM-VALREF-MOD is
  sort Elt to Addr .
endv

fmod WASM-SIGN-MOD is

  sorts Sign .

  ops pos neg : -> Sign [ctor] .

endfm

fmod WASM-NANS-MOD is

  protecting WASM-SIGN-MOD .
  protecting FLOAT .

  sorts NaN NaNFloat NFloat .
  subsorts NaN NFloat < NaNFloat .

  op nanF : Float -> NFloat [ctor] .
  *** TODO: To be more exact, NaN values include the value of the mantissa in the binary representation
  *** TODO: Take into account canon NaNs
  op nan : Sign -> NaN [ctor] .

endfm

view NaNFloat from TRIV to WASM-NANS-MOD is
  sort Elt to NaNFloat .
endv

fmod WASM-FLOAT-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-NANS-MOD .
  protecting LIST{NaNFloat} .

  sorts NaNs InfF ZeroF .

  var F1 F2 : Float .

  *** Proposition for wrapper for sign-carrying floats
  ***op wasmF : Sign Float -> WASMFloat .
  ***op _+_ : WASMFloat WASMFloat -> WASMFloat [ctor] .
  ***eq wasmF(pos, F1) + wasmF(pos, F2) = wasmF(pos, F1 + F2) .
  ***eq wasmF(pos, F1) + wasmF(neg, F2) = wasmF(pos, F1) - wasmF(pos, F2) .
  ***eq wasmF(neg, F1) + wasmF(pos, F2) = wasmF(pos, F2) - wasmF(neg, F1) .
  ***eq wasmF(neg, F1) + wasmF(neg, F2) = wasmF(neg, F1 + F2) .
  ***op _-_ : WASMFloat WASMFloat -> WASMFloat [ctor] .
  ***eq wasmF(pos, F1) - wasmF(pos, F2) = wasmF(pos, F1 - F2) if F1 >= F2 .
  ***eq wasmF(pos, F1) - wasmF(pos, F2) = wasmF(neg, F1 - F2) if F1 < F2 .
  ***eq wasmF(F1) - wasmF(F2) = wasmF(F1 - F2) .
  ***op _*_ : WASMFloat WASMFloat -> WASMFloat [ctor] .
  ***eq wasmF(F1) * wasmF(F2) = wasmF(F1 * F2) .
  ***op _rem_ : WASMFloat WASMFloat -> WASMFloat [ctor] .
  ***eq wasmF(F1) rem wasmF(F2) = wasmF(F1 rem F2) .

  op get-sign : Float -> Sign .
  ceq get-sign(F1) = pos if F1 > 0.0 .
  eq get-sign(F1) = neg [owise] .

  op opposite : Sign -> Sign [ctor] .
  eq opposite(pos) = neg .
  eq opposite(neg) = pos .

  op nans : List{NaNFloat} -> NaNs [ctor] .
  op inf : Sign -> InfF [ctor] .
  op zero : Sign -> ZeroF [ctor] .
  
  var FType : FloatTypeToken .

  op expon : FloatTypeToken -> Nat .
  eq expon(f32) = 8 .
  eq expon(f64) = 11 .
  op signif : FloatTypeToken -> Nat .
  eq signif(f32) = 23 .
  eq signif(f64) = 52 .

  op limitF : FloatTypeToken -> Nat .
  eq limitF(FType) = (2 ^ (2 ^ expon(FType))) .

endfm

fmod WASM-VALUE-MOD is

  protecting WASM-FLOAT-MOD .
  protecting FLOAT .
  protecting INT .
  protecting CONVERSION .

  sorts Value IntValue Int32Value Int64Value UInt SInt FloatValue ValWrapper Und .

  subsorts IntValue < Value .
  subsorts FloatValue < Value .
  subsorts Und < Value .
  ***subsorts Int32Value Int64Value < IntValue .

  op und : -> Und [ctor] .

  var T : TypeToken .
  var IntT : IntTypeToken .
  var FloatT : FloatTypeToken .
  var ValWrapper VW1 ValW1 VW2 ValW2 : ValWrapper .
  var I1 I2 : Int . 
  var F1 F2 : Float .
  var FType : FloatTypeToken .
  var FVal : FloatValue .
  var Sg1 : Sign .

  *** Wrapper for values
  op val : Int -> ValWrapper [ctor] .
  op val : Float -> ValWrapper [ctor] .
  op val : NaN -> ValWrapper [ctor] .
  op val : NaNs -> ValWrapper [ctor] .
  op val : InfF -> ValWrapper [ctor] .
  op val : ZeroF -> ValWrapper [ctor] .

  op get-type : Value -> TypeToken .
  eq get-type(const(IntT, ValW1)) = IntT .
  eq get-type(const(FloatT, ValW1)) = FloatT .

  op get-valW : Value -> ValWrapper .
  eq get-valW(const(IntT, ValW1)) = ValW1 .
  eq get-valW(const(FloatT, ValW1)) = ValW1 .

  op correctFloat : FloatValue -> FloatValue [ctor] .
  ceq correctFloat(const(FType, val(F1))) = const(FType, val(inf(pos))) if F1 >= float(limitF(FType)) .
  ceq correctFloat(const(FType, val(F1))) = const(FType, val(inf(neg))) if F1 <= - float(limitF(FType)) .
  eq correctFloat(const(FType, val(0))) = const(FType, val(zero(pos))) .
  eq correctFloat(FVal) = FVal [owise] .

  op -_ : ValWrapper -> ValWrapper [ctor] .
  eq - val(inf(Sg1)) = val(inf(opposite(Sg1))) .
  eq - val(zero(Sg1)) = val(zero(opposite(Sg1))) .
  eq - val(F1) = val(- F1) .
  op _+_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) + val(I2) = val(I1 + I2) .
  eq val(F1) + val(F2) = val(F1 + F2) .
  op _-_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) - val(I2) = val(I1 - I2) .
  eq val(F1) - val(F2) = val(F1 - F2) .
  op _*_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) * val(I2) = val(I1 * I2) .
  eq val(F1) * val(F2) = val(F1 * F2) .
  op _quo_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) quo val(I2) = val(I1 quo I2) .
  ***eq val(F1) quo val(F2) = val(F1 quo F2) .
  op _rem_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) rem val(I2) = val(I1 rem I2) .
  eq val(F1) rem val(F2) = val(F1 rem F2) .
  op abs : ValWrapper -> ValWrapper [ctor] .
  eq abs(val(I1)) = val(abs(I1)) .
  eq abs(val(F1)) = val(abs(F1)) .
  op _<_ : ValWrapper ValWrapper -> Bool [ctor] .
  eq val(I1) < val(I2) = I1 < I2 .
  eq val(F1) < val(F2) = F1 < F2 .
  op _>_ : ValWrapper ValWrapper -> Bool [ctor] .
  eq val(I1) > val(I2) = I1 > I2 .
  eq val(F1) > val(F2) = F1 > F2 .
  op _<=_ : ValWrapper ValWrapper -> Bool [ctor] .
  eq val(I1) <= val(I2) = I1 <= I2 .
  eq val(F1) <= val(F2) = F1 <= F2 .
  op _>=_ : ValWrapper ValWrapper -> Bool [ctor] .
  eq val(I1) >= val(I2) = I1 >= I2 .
  eq val(F1) >= val(F2) = F1 >= F2 .
  ***op _==_ : ValWrapper ValWrapper -> Bool [ctor] .
  ***eq val(I1) == val(I2) = (I1 == I2) .
  ***eq val(F1) == val(F2) = (F1 == F2) .
  ***op _=/=_ : ValWrapper ValWrapper -> Bool [ctor] .
  ***eq val(I1) =/= val(I2) = (I1 =/= I2) .
  ***eq val(F1) =/= val(F2) = (F1 =/= F2) .

  op _+_ : ValWrapper Int -> ValWrapper [ctor] .
  eq val(I1) + I2 = val(I1 + I2) .
  ***eq val(F1) + I2 = val(F1 + I2) .  
  op _rem_ : ValWrapper Int -> ValWrapper [ctor] .
  eq val(I1) rem I2 = val(I1 rem I2) .
  ***eq val(F1) rem I2 = val(F1 rem I2) .

  *** Represent values "(type).const (value)" pushed to stack
  op const : TypeToken ValWrapper -> Value [ctor] .

  op get-type : Value -> TypeToken .
  eq get-type(const(T, ValWrapper)) = T .

  op get-val : Value -> ValWrapper .
  eq get-val(const(T, ValWrapper)) = ValWrapper .
  
  op defaultVal : TypeToken -> Value [ctor] .
  eq defaultVal(IntT) = const(IntT, val(0)) .
  eq defaultVal(FloatT) = const(FloatT, val(0.0)) .

  *** Memberships of different types
  mb const(IntT, ValWrapper) : IntValue . 
  mb const(FloatT, ValWrapper) : FloatValue . 

endfm

fmod WASM-IOPS-MOD is

  protecting WASM-VALUE-MOD .

  var N : Nat .
  var Int1 Int2 : Int .
  var ValW1 ValW2 : ValWrapper .
  var IntT : IntTypeToken .

  *** Auxiliary op for arithmetic instructions
  *** signed op : integer operators can be interpreted as if they had sign by some instructions.
  *** signed takes the number and the number of bits in its representation (32/64) 
  op signed : ValWrapper Nat -> ValWrapper .
  ceq signed(val(Int1), N) = val(Int1) if 0 <= Int1 and Int1 < (2 ^ (N - 1)) .
  ceq signed(val(Int1), N) = val(Int1 - (2 ^ (N))) if (2 ^ (N - 1)) <= Int1 and Int1 < (2 ^ (N)) .

  *** inverted function from signed
  op unsigned : ValWrapper Nat -> ValWrapper .
  ceq unsigned(val(Int1), N) = val(Int1) if 0 <= Int1 and Int1 < (2 ^ (N - 1)) .
  ceq unsigned(val(Int1), N) = val(Int1 + (2 ^ (N))) if ((2 ^ (N - 1)) - (2 ^ (N))) <= Int1 and Int1 < 0 .

  *** Auxiliary op for ibinop
  op iadd : Nat ValWrapper ValWrapper -> ValWrapper .
  eq iadd(N, ValW1, ValW2) = (ValW1 + ValW2) rem 2 ^ (N) .

  op isub : Nat ValWrapper ValWrapper -> ValWrapper .
  eq isub(N, ValW1, ValW2) = ((ValW1 - ValW2) + (2 ^ (N))) rem (2 ^ (N)) .

  op imul : Nat ValWrapper ValWrapper -> ValWrapper .
  eq imul(N, ValW1, ValW2) = (ValW1 * ValW2) rem 2 ^ (N) .

  op idivu : IntTypeToken Nat ValWrapper ValWrapper -> Value .
  eq idivu(IntT, N, val(Int1), val(0)) = und .
  eq idivu(IntT, N, val(Int1), val(Int2)) = const(IntT, val(Int1 quo Int2)) [owise] .

  op idivs : IntTypeToken Nat ValWrapper ValWrapper -> Value .
  eq idivs(IntT, N, val(Int1), val(0)) = und .
  ceq idivs(IntT, N, val(Int1), val(Int2)) = und if (signed(val(Int1), N) quo signed(val(Int2), N)) == val(2 ^ (N - 1)) .
  eq idivs(IntT, N, ValW1, ValW2) = const(IntT, unsigned(signed(ValW1, N) quo signed(ValW2, N), N)) [owise] .

  op iremu : IntTypeToken Nat ValWrapper ValWrapper -> Value .
  eq iremu(IntT, N, val(Int1), val(0)) = und .
  eq iremu(IntT, N, val(Int1), val(Int2)) = const(IntT, val(Int1 rem Int2)) [owise] .
  
  *** By specification: return the rem of dividing the signed representations of j1/j2 w/ the sign of j1 (design decision: compute sign of j1 as (Int1 quo abs(Int1)))
  op irems : IntTypeToken Nat ValWrapper ValWrapper -> Value .
  eq irems(IntT, N, val(Int1), val(0)) = und .
  eq irems(IntT, N, ValW1, ValW2) = const(IntT, unsigned(signed(ValW1, N) - (signed(ValW2, N) * (signed(ValW1, N) quo signed(ValW2, N))), N)) [owise] .

  *** Auxiliary op for logic instructions
  op ieq : ValWrapper ValWrapper -> ValWrapper .
  eq ieq(ValW1, ValW1) = val(1) .
  eq ieq(ValW1, ValW2) = val(0) [owise] .
  
  op ine : ValWrapper ValWrapper -> ValWrapper .
  ceq ine(ValW1, ValW2) = val(1) if ValW1 =/= ValW2 .
  eq ine(ValW1, ValW2) = val(0) [owise] .
  
  op "ilt_u" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ilt_u"(ValW1, ValW2) = val(1) if abs(ValW1) < abs(ValW2) .
  eq "ilt_u"(ValW1, ValW2) = val(0) [owise] .
  
  op "ilt_s" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ilt_s"(ValW1, ValW2) = val(1) if ValW1 < ValW2 .
  eq "ilt_s"(ValW1, ValW2) = val(0) [owise] .
  
  op "igt_u" : ValWrapper ValWrapper -> ValWrapper .
  ceq "igt_u"(ValW1, ValW2) = val(1) if abs(ValW1) > abs(ValW2) .
  eq "igt_u"(ValW1, ValW2) = val(0) [owise] .
  
  op "igt_s" : ValWrapper ValWrapper -> ValWrapper .
  ceq "igt_s"(ValW1, ValW2) = val(1) if ValW1 > ValW2 .
  eq "igt_s"(ValW1, ValW2) = val(0) [owise] .

  op "ile_u" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ile_u"(ValW1, ValW2) = val(1) if abs(ValW1) <= abs(ValW2) .
  eq "ile_u"(ValW1, ValW2) = val(0) [owise] .
  
  op "ile_s" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ile_s"(ValW1, ValW2) = val(1) if ValW1 <= ValW2 .
  eq "ile_s"(ValW1, ValW2) = val(0) [owise] .
  
  op "ige_u" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ige_u"(ValW1, ValW2) = val(1) if abs(ValW1) >= abs(ValW2) .
  eq "ige_u"(ValW1, ValW2) = val(0) [owise] .
  
  op "ige_s" : ValWrapper ValWrapper -> ValWrapper .
  ceq "ige_s"(ValW1, ValW2) = val(1) if ValW1 >= ValW2 .
  eq "ige_s"(ValW1, ValW2) = val(0) [owise] .

endfm

fmod WASM-FOPS-MOD is

  protecting WASM-VALUE-MOD .

  var FloatN F1 F2 : Float .
  var ValW1 ValW2 : ValWrapper .
  var Sg Sg1 Sg2 : Sign .
  var InfF InfF1 InfF2 : InfF .
  var ZeroF ZeroF1 ZeroF2 : ZeroF .
  var NaN : NaN .

  *** FLOAT Binops
  *** fadd
  op fadd : ValWrapper ValWrapper -> ValWrapper .
  eq fadd(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fadd(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  ceq fadd(val(inf(Sg1)), val(inf(Sg2))) = val(nans(nil)) if Sg1 =/= Sg2 .
  eq fadd(val(inf(Sg1)), val(inf(Sg1))) = val(inf(Sg1)) .
  eq fadd(val(InfF), val(F1)) = val(InfF) .
  eq fadd(val(F1), val(InfF)) = val(InfF) .
  ceq fadd(val(zero(Sg1)), val(zero(Sg2))) = val(zero(pos)) if Sg1 =/= Sg2 .
  eq fadd(val(zero(Sg1)), val(zero(Sg1))) = val(zero(Sg1)) .
  eq fadd(val(ZeroF), val(F1)) = val(F1) .
  eq fadd(val(F1), val(ZeroF)) = val(F1) .
  *** TODO: Take into account "rounded to the nearest representable value"??
  eq fadd(val(F1), val(F2)) = val(F1 + F2) .

  ***fsub
  op fsub : ValWrapper ValWrapper -> ValWrapper .
  eq fsub(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fsub(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  eq fsub(val(InfF), val(ZeroF)) = val(nans(nil)) .
  eq fsub(val(ZeroF), val(InfF)) = val(nans(nil)) .
  eq fsub(val(InfF), val(InfF)) = val(inf(pos)) .
  ceq fsub(val(inf(Sg1)), val(inf(Sg2))) = val(inf(neg)) if Sg1 =/= Sg2 .
  eq fsub(val(F1), val(inf(Sg1))) = val(inf(opposite(Sg1))) .
  eq fsub(val(InfF), val(F1)) = val(InfF) .
  eq fsub(val(zero(Sg1)), val(zero(Sg1))) = val(zero(pos)) .
  ceq fsub(val(zero(Sg1)), val(zero(Sg2))) = val(zero(Sg1)) if Sg1 =/= Sg2 .
  eq fsub(val(F1), val(ZeroF)) = val(F1) .
  eq fsub(val(ZeroF), val(F1)) = val(- F1) .
  *** TODO: Take into account "rounded to the nearest representable value"??
  eq fsub(val(F1), val(F2)) = val(F1 - F2) .

  ***fmul
  op fmul : ValWrapper ValWrapper -> ValWrapper .
  eq fmul(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fmul(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  eq fmul(val(inf(Sg1)), val(inf(Sg1))) = val(nans(nil)) .
  ceq fmul(val(inf(Sg1)), val(inf(Sg2))) = val(inf(neg)) if Sg1 =/= Sg2 .
  ceq fmul(val(F1), val(inf(Sg1))) = val(inf(pos)) if get-sign(F1) == Sg1 .
  ceq fmul(val(F1), val(inf(Sg1))) = val(inf(neg)) if get-sign(F1) =/= Sg1 .
  ceq fmul(val(inf(Sg1)), val(F1)) = val(inf(pos)) if get-sign(F1) == Sg1 .
  ceq fmul(val(inf(Sg1)), val(F1)) = val(inf(neg)) if get-sign(F1) =/= Sg1 .
  eq fmul(val(zero(Sg1)), val(zero(Sg1))) = val(zero(pos)) .
  ceq fmul(val(zero(Sg1)), val(zero(Sg2))) = val(zero(neg)) if Sg1 =/= Sg2 .
  ceq fmul(val(F1), val(zero(Sg2))) = val(zero(pos)) if get-sign(F1) == Sg2 .
  ceq fmul(val(F1), val(zero(Sg2))) = val(zero(neg)) if get-sign(F1) =/= Sg2 .
  ceq fmul(val(zero(Sg2)), val(F1)) = val(zero(pos)) if get-sign(F1) == Sg2 .
  ceq fmul(val(zero(Sg2)), val(F1)) = val(zero(neg)) if get-sign(F1) =/= Sg2 .
  *** TODO: Take into account "rounded to the nearest representable value"??
  eq fmul(val(F1), val(F2)) = val(F1 * F2) .

  ***fdiv
  op fdiv : ValWrapper ValWrapper -> ValWrapper .
  eq fdiv(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fdiv(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  eq fdiv(val(InfF1), val(InfF2)) = val(nans(nil)) .
  eq fdiv(val(ZeroF1), val(ZeroF2)) = val(nans(nil)) .
  ceq fdiv(val(F1), val(inf(Sg1))) = val(zero(pos)) if get-sign(F1) == Sg1 .
  ceq fdiv(val(F1), val(inf(Sg1))) = val(zero(neg)) if get-sign(F1) =/= Sg1 .
  ceq fdiv(val(inf(Sg1)), val(F1)) = val(inf(pos)) if get-sign(F1) == Sg1 .
  ceq fdiv(val(inf(Sg1)), val(F1)) = val(inf(neg)) if get-sign(F1) =/= Sg1 .
  ceq fdiv(val(F1), val(zero(Sg2))) = val(inf(pos)) if get-sign(F1) == Sg2 .
  ceq fdiv(val(F1), val(zero(Sg2))) = val(inf(neg)) if get-sign(F1) =/= Sg2 .
  ceq fdiv(val(zero(Sg2)), val(F1)) = val(zero(pos)) if get-sign(F1) == Sg2 .
  ceq fdiv(val(zero(Sg2)), val(F1)) = val(zero(neg)) if get-sign(F1) =/= Sg2 .
  *** TODO: Take into account "rounded to the nearest representable value"??
  eq fdiv(val(F1), val(F2)) = val(F1 / F2) .

  ***fmin
  op fmin : ValWrapper ValWrapper -> ValWrapper .
  eq fmin(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fmin(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  eq fmin(val(inf(pos)), val(F2)) = val(F2) .
  eq fmin(val(inf(neg)), val(F2)) = val(inf(neg)) .
  eq fmin(val(F1), val(inf(pos))) = val(F1) .
  eq fmin(val(F1), val(inf(neg))) = val(inf(neg)) .
  ceq fmin(val(zero(Sg1)), val(zero(Sg2))) = val(zero(neg)) if Sg1 =/= Sg2 .
  eq fmin(val(F1), val(F2)) = val(min(F1, F2)) .

  ***fmax
  op fmax : ValWrapper ValWrapper -> ValWrapper .
  eq fmax(val(NaN), val(F1)) = val(nans(NaN nanF(F1))) .
  eq fmax(val(F1), val(NaN)) = val(nans(NaN nanF(F1))) .
  eq fmax(val(inf(pos)), val(F2)) = val(inf(pos)) .
  eq fmax(val(inf(neg)), val(F2)) = val(F2) .
  eq fmax(val(F1), val(inf(pos))) = val(inf(pos)) .
  eq fmax(val(F1), val(inf(neg))) = val(F1) .
  ceq fmax(val(zero(Sg1)), val(zero(Sg2))) = val(zero(pos)) if Sg1 =/= Sg2 .
  eq fmax(val(F1), val(F2)) = val(max(F1, F2)) .

  ***fcopysign
  op fcopysign : ValWrapper ValWrapper -> ValWrapper .
  eq fcopysign(val(zero(Sg)), val(zero(Sg))) = val(zero(Sg)) .
  eq fcopysign(val(inf(Sg)), val(inf(Sg))) = val(inf(Sg)) .
  ceq fcopysign(val(F1), val(F2)) = val(F1) if get-sign(F1) == get-sign(F2) .
  eq fcopysign(ValW1, ValW2) = - ValW1 .

  *** FUNOPS
  ***fabs
  op fabs : ValWrapper -> ValWrapper .
  eq fabs(val(nan(Sg1))) = val(nan(pos)) .
  eq fabs(val(inf(Sg1))) = val(inf(pos)) .
  eq fabs(val(zero(Sg1))) = val(zero(pos)) .
  eq fabs(val(F1)) = val(abs(F1)) .

  ***fneg
  op fneg : ValWrapper -> ValWrapper .
  eq fneg(val(nan(Sg1))) = val(nan(opposite(Sg1))) .
  eq fneg(val(inf(Sg1))) = val(inf(opposite(Sg1))) .
  eq fneg(val(zero(Sg1))) = val(zero(opposite(Sg1))) .
  eq fneg(val(F1)) = val(- F1) .

  ***fsqrt
  op fsqrt : ValWrapper -> ValWrapper .
  eq fsqrt(val(NaN)) = val(nans(NaN)) .
  eq fsqrt(val(inf(neg))) = val(nans(nil)) .
  eq fsqrt(val(inf(pos))) = val(inf(pos)) .
  eq fsqrt(val(ZeroF)) = val(ZeroF) .
  ceq fsqrt(val(F1)) = val(nans(nil)) if F1 < 0.0 .
  eq fsqrt(val(F1)) = val(sqrt(F1)) [owise] .

  ***fceil
  op fceil : ValWrapper -> ValWrapper .
  eq fceil(val(NaN)) = val(nans(NaN)) .
  eq fceil(val(InfF)) = val(InfF) .
  eq fceil(val(ZeroF)) = val(ZeroF) .
  ceq fceil(val(F1)) = val(zero(neg)) if F1 < 0.0 and -1.0 < F1 .
  eq fceil(val(F1)) = val(ceiling(F1)) [owise] .

  ***ffloor
  op ffloor : ValWrapper -> ValWrapper .
  eq ffloor(val(NaN)) = val(nans(NaN)) .
  eq ffloor(val(InfF)) = val(InfF) .
  eq ffloor(val(ZeroF)) = val(ZeroF) .
  ceq ffloor(val(F1)) = val(zero(pos)) if F1 > 0.0 and F1 < 1.0 .
  eq ffloor(val(F1)) = val(floor(F1)) [owise] .

  *** COMPARISON FUNCTIONS
  ***feq
  op feq : ValWrapper ValWrapper -> ValWrapper .
  ceq feq(val(zero(Sg1)), val(zero(Sg2))) = val(1) if Sg1 =/= Sg2 .
  eq feq(ValW1, ValW1) = val(1) .
  eq feq(ValW1, ValW2) = val(0) [owise] .

  ***fne
  op fne : ValWrapper ValWrapper -> ValWrapper .
  eq fne(val(NaN), ValW2) = val(1) .
  eq fne(ValW1, val(NaN)) = val(1) .
  ceq fne(val(zero(Sg1)), val(zero(Sg2))) = val(0) if Sg1 =/= Sg2 .
  ceq fne(ValW1, ValW2) = val(1) if ValW1 =/= ValW2 .
  eq fne(ValW1, ValW2) = val(0) [owise] .

  ***flt
  op flt : ValWrapper ValWrapper -> ValWrapper .
  eq flt(val(inf(neg)), val(F2)) = val(1) .
  eq flt(val(F1), val(inf(pos))) = val(1) .
  ceq flt(val(F1), val(F2)) = val(1) if F1 < F2 .
  eq flt(ValW1, ValW2) = val(0) [owise] .

  ***fgt
  op fgt : ValWrapper ValWrapper -> ValWrapper .
  eq fgt(val(inf(pos)), val(F2)) = val(1) .
  eq fgt(val(F1), val(inf(neg))) = val(1) .
  ceq fgt(val(F1), val(F2)) = val(1) if F1 > F2 .
  eq fgt(ValW1, ValW2) = val(0) [owise] .

  ***fle
  op fle : ValWrapper ValWrapper -> ValWrapper .
  eq fle(val(inf(neg)), val(F2)) = val(1) .
  eq fle(val(F1), val(inf(pos))) = val(1) .
  eq fle(val(ZeroF1), val(ZeroF2)) = val(1) .
  eq fle(ValW1, ValW1) = val(1) .
  ceq fle(val(F1), val(F2)) = val(1) if F1 < F2 .
  eq fle(ValW1, ValW2) = val(0) [owise] .

  ***fge
  op fge : ValWrapper ValWrapper -> ValWrapper .
  eq fge(val(inf(pos)), val(F2)) = val(1) .
  eq fge(val(F1), val(inf(neg))) = val(1) .
  eq fge(val(ZeroF1), val(ZeroF2)) = val(1) .
  eq fge(ValW1, ValW1) = val(1) .
  ceq fge(val(F1), val(F2)) = val(1) if F1 > F2 .
  eq fge(ValW1, ValW2) = val(0) [owise] .

endfm

fmod WASM-CONVERSIONOPS-MOD is

  protecting WASM-VALUE-MOD .

  var Int1 : Int .
  var F1 : Float .
  var NaN : NaN .
  var InfF : InfF .
  var ZeroF : ZeroF .
  var ValW : ValWrapper .

  op wrap : IntTypeToken IntTypeToken ValWrapper -> ValWrapper .
  eq wrap(i64, i32, val(Int1)) = val(Int1 rem (2 ^ (bit-width(i32)))) .

  op demote : FloatTypeToken FloatTypeToken ValWrapper -> ValWrapper .
  *** TODO: Take into account canon NaNs
  eq demote(f64, f32, val(NaN)) = val(nans(nil)) .
  eq demote(f64, f32, val(InfF)) = val(InfF) .
  eq demote(f64, f32, val(ZeroF)) = val(ZeroF) .
  eq demote(f64, f32, val(F1)) = get-valW(correctFloat(const(f32, val(F1)))) .

  op promote : FloatTypeToken FloatTypeToken ValWrapper -> ValWrapper .
  *** TODO: Take into account canon NaNs
  eq promote(f32, f64, val(NaN)) = val(nans(nil)) .
  eq promote(f32, f64, ValW) = ValW .

endfm

fmod WASM-GLOBALINSTANCE-MOD is
  
  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-VALUE-MOD .

  sorts GlobalInstance GlobalType MutGlobalType .
  subsorts MutGlobalType < GlobalType .

  *** Included mut because of emscripten-compiled example. Not included in the standard...
  op const_ : TypeToken -> GlobalType [ctor] .
  ops var_ mut_ : TypeToken -> MutGlobalType [ctor] .

  op {type _, value _} : GlobalType Value -> GlobalInstance [ctor] .

endfm

view GlobalInstance from TRIV to WASM-GLOBALINSTANCE-MOD is
  sort Elt to GlobalInstance .
endv

fmod WASM-INST-MOD is

  protecting WASM-BITVAL-MOD .
  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-BLOCKTYPE-MOD .
  protecting WASM-FOPS-MOD .
  protecting WASM-IOPS-MOD .
  protecting WASM-VALREF-MOD .
  protecting WASM-VALUE-MOD .

  sorts Inst ConstInst .
  sorts BinopToken IBinopToken FBinopToken UnopToken FUnopToken IUnopToken RelopToken IRelopToken FRelopToken TestopToken CvtopToken .
  subsorts IBinopToken FBinopToken < BinopToken .
  subsorts IUnopToken FUnopToken < UnopToken .
  subsorts IRelopToken FRelopToken < RelopToken .

  subsorts ConstInst < Inst .

  *** Instruction ops declarations
  op local.get _ : ValRef -> Inst [ctor prec 24] .
  op local.set _ : ValRef -> Inst [ctor prec 24] .
  op local.tee _ : ValRef -> Inst [ctor prec 24] .

  *** global insts
  op global.get _ : String -> Inst [ctor prec 24] .
  op global.set _ : String -> Inst [ctor prec 24] .

  ***op _.const _ : TypeToken Value -> Inst [ctor] .
  op _.const_ : TypeToken Int -> ConstInst [ctor prec 24] .
  op _.const_ : FloatTypeToken Float -> ConstInst [ctor prec 24] .


  *** binop (Binary Operations)
  *** ibinop (Integer binop) - add | sub | mul | div_sx | rem_sx | and | or | xor | shl | shr_sx | rotl | rotr
  ops add sub mul : -> BinopToken [ctor] .
  op _._ : TypeToken BinopToken -> Inst [ctor prec 24] . *** Valid for ints and floats
  *** Insts with underscores (_) need to be preprocessed so that Maude does not misinterpret the _ symbol
  *** TODO: Change _ to ~ 
  ops "div_u" "div_s" "rem_u" "rem_s" : -> IBinopToken [ctor] .
  op _._ : IntTypeToken IBinopToken -> Inst [ctor prec 24] .

  *** bitstring representation ops
  ops and or xor : -> IBinopToken [ctor] .
  op _._ : IntTypeToken IBinopToken -> Inst [ctor prec 24] .

  ops div min max copysign : -> FBinopToken [ctor] .
  op _._ : FloatTypeToken FBinopToken -> Inst [ctor prec 24] .
  
  ops abs neg sqrt ceil floor : -> FUnopToken [ctor] .
  op _._ : FloatTypeToken FUnopToken -> Inst [ctor prec 24] .

  var T : TypeToken .
  var IntT : IntTypeToken .
  var FloatT : FloatTypeToken .
  var ValW1 ValW2 : ValWrapper .
  var Int1 Int2 : Int .

  op binop : TypeToken BinopToken ValWrapper ValWrapper -> Value .
  *** Int instructions
  eq binop(IntT, add, ValW1, ValW2) = const(IntT, iadd(bit-width(IntT), ValW1, ValW2)) .
  eq binop(IntT, sub, ValW1, ValW2) = const(IntT, isub(bit-width(IntT), ValW1, ValW2)) .
  eq binop(IntT, mul, ValW1, ValW2) = const(IntT, imul(bit-width(IntT), ValW1, ValW2)) .
  eq binop(IntT, "div_u", ValW1, ValW2) = idivu(IntT, bit-width(IntT), ValW1, ValW2) .
  eq binop(IntT, "div_s", ValW1, ValW2) = idivs(IntT, bit-width(IntT), ValW1, ValW2) .
  eq binop(IntT, "rem_s",ValW1, ValW2) = irems(IntT, bit-width(IntT), ValW1, ValW2) .
  eq binop(IntT, "rem_u", ValW1, ValW2) = iremu(IntT, bit-width(IntT), ValW1, ValW2) .
  *** instructions with bitstring representation
  eq binop(IntT, and, val(Int1), val(Int2)) = const(IntT, val(bitstring-to-int((iand((int-to-bitstring(Int1, bit-width(IntT))), (int-to-bitstring(Int2, bit-width(IntT))))), bit-width(IntT)))) .
  eq binop(IntT, or, val(Int1), val(Int2)) = const(IntT, val(bitstring-to-int((ior((int-to-bitstring(Int1, bit-width(IntT))), (int-to-bitstring(Int2, bit-width(IntT))))), bit-width(IntT)))) .
  eq binop(IntT, xor, val(Int1), val(Int2)) = const(IntT, val(bitstring-to-int((ixor((int-to-bitstring(Int1, bit-width(IntT))), (int-to-bitstring(Int2, bit-width(IntT))))), bit-width(IntT)))) .
  *** Float instructions
  eq binop(FloatT, add, ValW1, ValW2) = correctFloat(const(FloatT, fadd(ValW1, ValW2))) .
  eq binop(FloatT, sub, ValW1, ValW2) = correctFloat(const(FloatT, fsub(ValW1, ValW2))) .
  eq binop(FloatT, mul, ValW1, ValW2) = correctFloat(const(FloatT, fmul(ValW1, ValW2))) .
  eq binop(FloatT, div, ValW1, ValW2) = correctFloat(const(FloatT, fdiv(ValW1, ValW2))) .
  eq binop(FloatT, min, ValW1, ValW2) = correctFloat(const(FloatT, fmin(ValW1, ValW2))) .
  eq binop(FloatT, max, ValW1, ValW2) = correctFloat(const(FloatT, fmax(ValW1, ValW2))) .
  eq binop(FloatT, copysign, ValW1, ValW2) = correctFloat(const(FloatT, fcopysign(ValW1, ValW2))) .

  op unop : TypeToken UnopToken ValWrapper -> Value .
  eq unop(FloatT, abs, ValW1) = correctFloat(const(FloatT, fabs(ValW1))) .
  eq unop(FloatT, neg, ValW1) = correctFloat(const(FloatT, fneg(ValW1))) .
  eq unop(FloatT, sqrt, ValW1) = correctFloat(const(FloatT, fsqrt(ValW1))) .
  eq unop(FloatT, ceil, ValW1) = correctFloat(const(FloatT, fceil(ValW1))) .
  eq unop(FloatT, floor, ValW1) = correctFloat(const(FloatT, ffloor(ValW1))) .

  *** relop
  ops eq ne : -> RelopToken [ctor] .
  op _._ : TypeToken RelopToken -> Inst [ctor prec 24] .
  
  ops "lt_s" "lt_u" "gt_s" "gt_u" "le_s" "le_u" "ge_s" "ge_u" : -> IRelopToken [ctor] .
  op _._ : IntTypeToken IRelopToken -> Inst [ctor prec 24] .

  ops lt gt le ge : -> FRelopToken [ctor] .
  op _._ : FloatTypeToken FRelopToken -> Inst [ctor prec 24] .

  op relop : TypeToken RelopToken ValWrapper ValWrapper -> ValWrapper .
  eq relop(IntT, eq, ValW1, ValW2) = ieq(ValW1, ValW2) .
  eq relop(IntT, ne, ValW1, ValW2) = ine(ValW1, ValW2) .
  eq relop(IntT, "lt_s", ValW1, ValW2) = "ilt_s"(signed(ValW1, bit-width(IntT)), signed(ValW2, bit-width(IntT))) .
  eq relop(IntT, "lt_u", ValW1, ValW2) = "ilt_u"(ValW1, ValW2) .
  eq relop(IntT, "gt_s", ValW1, ValW2) = "igt_s"(signed(ValW1, bit-width(IntT)), signed(ValW2, bit-width(IntT))) .
  eq relop(IntT, "gt_u", ValW1, ValW2) = "igt_u"(ValW1, ValW2) .
  eq relop(IntT, "le_s", ValW1, ValW2) = "ile_s"(signed(ValW1, bit-width(IntT)), signed(ValW2, bit-width(IntT))) .
  eq relop(IntT, "le_u", ValW1, ValW2) = "ile_u"(ValW1, ValW2) .
  eq relop(IntT, "ge_s", ValW1, ValW2) = "ige_s"(signed(ValW1, bit-width(IntT)), signed(ValW2, bit-width(IntT))) .
  eq relop(IntT, "ge_u", ValW1, ValW2) = "ige_u"(ValW1, ValW2) .
  eq relop(FloatT, eq, ValW1, ValW2) = feq(ValW1, ValW2) .
  eq relop(FloatT, ne, ValW1, ValW2) = fne(ValW1, ValW2) .
  eq relop(FloatT, lt, ValW1, ValW2) = flt(ValW1, ValW2) .
  eq relop(FloatT, gt, ValW1, ValW2) = fgt(ValW1, ValW2) .
  eq relop(FloatT, le, ValW1, ValW2) = fle(ValW1, ValW2) .
  eq relop(FloatT, ge, ValW1, ValW2) = fge(ValW1, ValW2) .

  *** testop
  ops eqz : -> TestopToken [ctor] .
  op _._ : IntTypeToken TestopToken -> Inst [ctor prec 24] .

  *** conversions
  ops "wrap_" "demote_" "promote_" : -> CvtopToken [ctor] .
  op _._ _ : TypeToken CvtopToken TypeToken -> Inst [ctor prec 24] .

  *** Parametric instructions
  ops drop select : -> Inst [ctor] .

  *** Control Instructions
  op nop : -> Inst [ctor] .
  op unreachable : -> Inst [ctor] .

  op block _ : BlockType -> Inst [ctor prec 24] .
  op loop _ : BlockType -> Inst [ctor prec 24] .
  op br _ : Nat -> Inst [ctor prec 24] .
  op "br_if" _ : Nat -> Inst [ctor prec 24] .
  op end : -> Inst [ctor] .

  op call _ : Addr -> Inst [ctor prec 24] .
  op call _ : String -> Inst [ctor prec 24] .

endfm

view Inst from TRIV to WASM-INST-MOD is
  sort Elt to Inst .
endv

view ValRef from TRIV to WASM-VALREF-MOD is
  sort Elt to ValRef .
endv

view Value from TRIV to WASM-VALUE-MOD is
  sort Elt to Value .
endv

fmod WASM-FUNCDEF-MOD is

  protecting WASM-TYPEDEF-MOD .
  protecting LIST{Inst} .
  protecting MAP{String, Addr} .
  protecting MAP{Addr, TypeDef} . 

  sorts FuncDef FuncTypeDef LocalsRef .
  subsorts ParamResultType TypeRef < FuncTypeDef .

  op (local _) : List{TypeToken} -> LocalsRef [ctor prec 50] .

  op _ _ : TypeRef ParamResultType -> FuncTypeDef [ctor] .

  *** TODO: look for a way of making ParamType, ResultType lists and LocalsRef optional
  op (func _ _ _ _ end) : Id FuncTypeDef LocalsRef List{Inst} -> FuncDef [ctor] .
  op (func _ _ _ _ end) : String FuncTypeDef LocalsRef List{Inst} -> FuncDef [ctor] .
  op (func _ _ _ end) : Id LocalsRef List{Inst} -> FuncDef [ctor] .
  op (func _ _ _ end) : String LocalsRef List{Inst} -> FuncDef [ctor] .

  var FuncTypeDef : FuncTypeDef .
  var TypeRef : TypeRef .
  var ParamResultType : ParamResultType .
  var TypeStore : Map{Addr, TypeDef} .
  var IndTypeCtxSTR : Map{String, Addr} .
  var Id : Id .
  var Str : String .
  var LocalsRef : LocalsRef .
  var IL : List{Inst} .

  eq (func Id LocalsRef IL end) = (func Id ((param nil) (result nil)) LocalsRef IL end) .
  eq (func Str LocalsRef IL end) = (func Str ((param nil) (result nil)) LocalsRef IL end) .

  *** TODO: Check whether this should be simplified
  op get-functype : FuncTypeDef Map{Addr, TypeDef} Map{String, Addr} -> ParamResultType .
  ceq get-functype(TypeRef ParamResultType, TypeStore, IndTypeCtxSTR) = ParamResultType if coherent-typedef(TypeRef, ParamResultType, TypeStore, IndTypeCtxSTR) .
  eq get-functype((type Id), TypeStore, IndTypeCtxSTR) = get-functype-typedef(TypeStore[Id]) .
  eq get-functype((type Str), TypeStore, IndTypeCtxSTR) = get-functype-typedef(TypeStore[IndTypeCtxSTR[Str]]) .
  eq get-functype(ParamResultType, TypeStore, IndTypeCtxSTR) = ParamResultType .

  op coherent-typedef : TypeRef ParamResultType Map{Addr, TypeDef} Map{String, Addr} -> Bool .
  ceq coherent-typedef((type Id), ParamResultType, TypeStore, IndTypeCtxSTR) = true if ParamResultType == get-functype-typedef(TypeStore[Id]) .
  ceq coherent-typedef((type Str), ParamResultType, TypeStore, IndTypeCtxSTR) = true if ParamResultType == get-functype-typedef(TypeStore[IndTypeCtxSTR[Str]]) .
  eq coherent-typedef(TypeRef, ParamResultType, TypeStore, IndTypeCtxSTR) = false [owise] .

  op valid-functype : FuncTypeDef Map{Addr, TypeDef} Map{String, Addr} -> Bool .
  ceq valid-functype(TypeRef ParamResultType, TypeStore, IndTypeCtxSTR) = false if  not coherent-typedef(TypeRef, ParamResultType, TypeStore, IndTypeCtxSTR) .
  eq valid-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) = true [owise] .


endfm

view FuncDef from TRIV to WASM-FUNCDEF-MOD is
  sort Elt to FuncDef .
endv

fmod WASM-GLOBALDEF-MOD is

  protecting WASM-TYPEDEF-MOD .
  protecting WASM-GLOBALINSTANCE-MOD .
  protecting WASM-INST-MOD .

  sorts GlobalDef .

  op (global _ (_) (_)) : String GlobalType ConstInst -> GlobalDef [ctor] .

endfm

view GlobalDef from TRIV to WASM-GLOBALDEF-MOD is
  sort Elt to GlobalDef .
endv

mod WASMMOD is
  *** RAFAEL MORALES PALACIOS - TFM - SEMANTICS OF WEBASSEMBLY IN MAUDE
  
  *** IMPORT DATATYPE MODULES TO BE USED
  ***protecting NAT .
  ***protecting INT .
  ***protecting STRING .
  ***protecting QID .
  protecting WASM-BITVAL-MOD .
  protecting WASM-INST-MOD .
  protecting WASM-IOPS-MOD .
  protecting WASM-FOPS-MOD .
  protecting WASM-CONVERSIONOPS-MOD .
  protecting LIST{Inst} .
  protecting MAP{ValRef, Value} .
  protecting LIST{Map{ValRef, Value}} .
  protecting MAP{String, Addr} .
  protecting MAP{Addr, GlobalInstance} .
  protecting MAP{Addr, FuncDef} .
  protecting MAP{Addr, TypeDef} .

  protecting WASM-TYPEDEF-MOD .
  protecting LIST{TypeDef} .
  protecting WASM-FUNCDEF-MOD .
  protecting LIST{FuncDef} .
  protecting WASM-GLOBALDEF-MOD .
  protecting LIST{GlobalDef} .

  *** File parsing is not fully developed yet
  protecting WASM-FILE-MOD .

  ***protecting MAP{Addr, String} .

  
  
  *** Declare sorts to be used and hierarchy between them.
  sorts WASMSim WasmTrigger WASMSimTrigger WASMTypeFuncGlobalSim WASMTypeFuncGlobalIndSim WASMFuncGlobalSim WASMFuncGlobalIndSim GlobalInventory WASMGlobalSim WASMGlobalIndSim WASMLocalSim WASMLocalIndSim WASMModule FuncExport ExportVec NeExportVec ExportDef Stack EmptyStack NeStack StackElem EmptyLocalStore NeLocalStore Assign Trap Arity Label StackAndLabel FuncStore .
  sorts IndCtx LocalIndCtx GlobalIndCtx FuncIndCtx TypeIndCtx .
  sorts Starter .

  *** Simulator components
  subsorts Stack List{Inst} < WASMLocalSim .
  subsorts EmptyStack NeStack < Stack .
  subsorts EmptyLocalStore NeLocalStore < Map{ValRef, Value} .
  subsorts Assign < NeLocalStore .

  *** Instruction lists sorts
  subsorts Trap < Inst .
  *** TODO: Include variable references as ValRef 
  *** Temporal solution: Use Qid, forces to use ' before the token...check to use $ instead
  ***subsorts Nat Qid < ValRef < NeValRefList < ValRefList .
  *** TODO: Include support for Labels and Activations as Stack values. Problem: collision of operator definition on Nat and String
  *** Temporal solution: Use Qid, forces to use ' before the token...check to use $ instead
  subsorts Value < StackElem < NeStack . ***subsorts Int Und < IntValue < Value < StackElem < NeStack .
  subsorts Und < Label < StackElem . ***subsorts Qid < Label < StackElem .
  subsorts Nat < Arity .

  subsorts LocalIndCtx GlobalIndCtx FuncIndCtx TypeIndCtx < IndCtx .

  op trap : String -> Trap [ctor] . 
  
  op label : String List{Inst} -> Label [ctor] .

  op if _ _ else _ : BlockType List{Inst} List{Inst} -> Inst [ctor] .

  *** Indices stores
  *** TODO: Some are left (types, etc.)
  op {localIndCtx _} : Map{String, Addr} -> LocalIndCtx [ctor] .
  op {globalIndCtx _} : Map{String, Addr} -> GlobalIndCtx [ctor] .
  op {funcIndCtx _} : Map{String, Addr} -> FuncIndCtx [ctor] .
  op {typeIndCtx _} : Map{String, Addr} -> TypeIndCtx [ctor] .

  *** Local environment
  *** < InstList(List{Inst}) | Stack | LocalStore(Map{ValRef, Value}) >
  op <_|_|_> : List{Inst} Stack Map{ValRef, Value} -> WASMLocalSim [ctor] .

  op _ _ : LocalIndCtx WASMLocalSim -> WASMLocalIndSim [ctor] .

  *** Global environment
  *** WASMLocalSim # GlobalAddrs(Map{ValRef, Nat} <-> GlobalStore(Map{ValRef, Value})
  op _ <-> _ : Map{String, Addr} Map{Addr, GlobalInstance} -> GlobalInventory [ctor] .
  op _ # _ : WASMLocalSim GlobalInventory -> WASMGlobalSim [ctor] .

  op _ _ : GlobalIndCtx WASMGlobalSim -> WASMGlobalIndSim [ctor] .

  *** Functions + Global enviroment
  op _ # _ : WASMGlobalSim Map{Addr, FuncDef} -> WASMFuncGlobalSim [ctor] .

  op _ _ : FuncIndCtx WASMFuncGlobalSim -> WASMFuncGlobalIndSim [ctor] .

  *** Types + Functions + Global enviroment
  op _ # _ : WASMFuncGlobalIndSim Map{Addr, TypeDef} -> WASMTypeFuncGlobalSim [ctor] .

  op _ _ : TypeIndCtx WASMTypeFuncGlobalSim -> WASMTypeFuncGlobalIndSim [ctor] .

  *** WASM Simulator
  *** # WASMModule # WASMGlobalSim # FuncStore #
  op # _ # _ # : WASMModule WASMTypeFuncGlobalIndSim -> WASMSim [ctor] .

  op start _ : Nat -> Starter [ctor] .
  op start _ : String -> Starter [ctor] .

  op {_, indctr _} : Starter Nat -> WasmTrigger [ctor] .

  op _ _ : WasmTrigger WASMSim -> WASMSimTrigger [ctor] .
  

  *** Empty Map{ValRef, Value} definition
  op EmptyLocalStore : -> Map{ValRef, Value} [ctor] .
  eq EmptyLocalStore = empty .

  *** Module sections
  *** TODO: complete module parts (global, exports, etc.)
  *** TODO: These components should probably be a multiset
  op (module _ _ _) : List{TypeDef} List{FuncDef} List{GlobalDef} -> WASMModule [ctor] .

  ***op __ : ExportDef ExportVec -> NeExportVec [assoc ctor id: EmptyList] .

  ***op (export _ _) : Id FuncExport -> ExportDef [ctor] .


  *** Stack definition
  op EmptyStack : -> EmptyStack [ctor] .
  op _$_ : StackElem Stack -> NeStack [ctor id: EmptyStack] .


  *** lookup: auxiliar op to lookup values from store
  op lookup : Map{ValRef, Value} ValRef -> Value .
  *** TODO: error otherwise or leave undefined??
  op jump-to-L : StackAndLabel -> Inst [ctor] .


  *** Variable definition

  var WASMModule : WASMModule .
  var WASMTypeFuncGlobalSim : WASMTypeFuncGlobalSim .
  var WASMTypeFuncGlobalIndSim : WASMTypeFuncGlobalIndSim .
  vars I1 S1 : Inst .
  var ConstInst : ConstInst .
  vars ValR ValR2 : ValRef .
  vars Val Val1 Val2 : Value .
  vars IL IL1 IL2 : List{Inst} .
  vars ST TempST ST1 : Stack .
  var NeST : NeStack .
  var LocalSTRList : List{Map{ValRef, Value}} .
  var NeLocalSTRList : NeList{Map{ValRef, Value}} .
  var LocalSTR : Map{ValRef, Value} .
  var T : TypeToken .
  var FloatT : FloatTypeToken .
  var IntT : IntTypeToken .
  vars IntVal IntVal1 IntVal2 : IntValue .
  vars Int1 Int2 : Int .
  var STElem : StackElem .
  var Str : String .
  var Label : Label .
  var N N1 N2 Ctr : Nat .
  var GlobalAddrs : Map{String, Addr} .
  var GlobalsStore : Map{Addr, GlobalInstance} .
  var GlobalType : GlobalType .
  var MutGlobalType : MutGlobalType .
  var GlobalInstance : GlobalInstance .
  var Addr : Addr .
  var FuncStore : Map{Addr, FuncDef} .
  var TypeStore : Map{Addr, TypeDef} .
  var TypeRef : TypeRef .
  var ParamType : ParamType .
  var ResultType : ResultType .
  var LocalsRef : LocalsRef .
  var TypeTokenList TList : List{TypeToken} .
  var NeTList : NeList{TypeToken} .
  var IntN : Int .
  var FloatN F1 F2 : Float .
  var ValW1 ValW2 : ValWrapper .
  var Sg1 Sg2 : Sign .
  var InfF : InfF .
  var ZeroF ZeroF1 ZeroF2 : ZeroF .
  var NaN : NaN .
  var FuncDef : FuncDef .
  var TypeDef : TypeDef .
  var FuncDefL : List{FuncDef} .
  var NeFuncDefL : NeList{FuncDef} .
  var TypeDefL : List{TypeDef} .
  var NeTypeDefL : NeList{TypeDef} .
  var GlobalDefL : List{GlobalDef} .
  var NeGlobalDefL : NeList{GlobalDef} .
  var Id : Id .
  var IndFuncCtx : FuncIndCtx .
  var IndTypeCtx : TypeIndCtx .
  vars IndFuncCtxSTR IndTypeCtxSTR : Map{String, Addr} .
  var StartFunc : Starter .
  var FuncType : FuncType .
  var FuncTypeDef : FuncTypeDef .
  var BlockType : BlockType .
  var GlobalInventory : GlobalInventory .
  var binopT : BinopToken .
  var unopT : UnopToken .
  var relopT : RelopToken .


  *** Run trigger
  op run-nomodule : List{Inst} -> WASMTypeFuncGlobalSim .
  eq run-nomodule(IL) = {funcIndCtx empty} < IL | EmptyStack | empty > # empty <-> empty # empty # empty .

  op uninitialized : -> Inst [ctor] .

  op run-module-func : WASMModule Nat -> WASMSimTrigger .
  eq run-module-func(WASMModule, N) = {start N, indctr 0} # WASMModule # {typeIndCtx empty} {funcIndCtx empty} < uninitialized | EmptyStack | empty > # empty <-> empty # empty # empty # .

  op run-module-func : WASMModule String -> WASMSimTrigger .
  eq run-module-func(WASMModule, Str) = {start Str, indctr 0} # WASMModule # {typeIndCtx empty} {funcIndCtx empty} < uninitialized | EmptyStack | empty > # empty <-> empty # empty # empty # .


  op simulate-wasm : WASMTypeFuncGlobalIndSim -> WASMTypeFuncGlobalIndSim .
  eq simulate-wasm(WASMTypeFuncGlobalIndSim) = WASMTypeFuncGlobalIndSim .

  op insert : String Nat IndCtx -> IndCtx .
  eq insert(Str, Ctr, {funcIndCtx IndFuncCtxSTR}) = {funcIndCtx insert(Str, Ctr, IndFuncCtxSTR)} .
  eq insert(Str, Ctr, {typeIndCtx IndTypeCtxSTR}) = {typeIndCtx insert(Str, Ctr, IndTypeCtxSTR)} .

  *** Rules
  
  *** TODO: Include validation in rules as eqs in preconditions
  ***TypeDefL should be NeTypeDefL
  rl [parse-typedef] : {StartFunc, indctr Ctr} # (module ((type Id FuncType) NeTypeDefL) FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr Ctr + 1} # (module NeTypeDefL FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # insert(Ctr, (type Id FuncType), TypeStore) # .

  rl [parse-typedef-last] : {StartFunc, indctr Ctr} # (module ((type Id FuncType)) FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr 0} # (module nil FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # insert(Ctr, (type Id FuncType), TypeStore) # .
  
  rl [parse-typedef-str] : {StartFunc, indctr Ctr} # (module ((type Str FuncType) NeTypeDefL) FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr Ctr + 1} # (module NeTypeDefL FuncDefL GlobalDefL) # insert(Str, Ctr, IndTypeCtx) IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # insert(Ctr, (type Str FuncType), TypeStore) # .

  rl [parse-typedef-last-str] : {StartFunc, indctr Ctr} # (module (type Str FuncType) FuncDefL GlobalDefL) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr 0} # (module nil FuncDefL GlobalDefL) # insert(Str, Ctr, IndTypeCtx) IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # insert(Ctr, (type Str FuncType), TypeStore) # .

  crl [parse-funcdef] : {StartFunc, indctr Ctr} # (module nil ((func Id FuncTypeDef LocalsRef IL end) NeFuncDefL) GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr Ctr + 1} # (module nil NeFuncDefL GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # insert(Id, (func Id get-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) LocalsRef IL end), FuncStore) # TypeStore # 
                      if valid-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) .

  crl [parse-funcdef-last] : {StartFunc, indctr Ctr} # (module nil (func Id FuncTypeDef LocalsRef IL end) GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr 0} # (module nil nil GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # insert(Id, (func Id get-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) LocalsRef IL end), FuncStore) # TypeStore #
                      if valid-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) .

  crl [parse-funcdef-str] : {StartFunc, indctr Ctr} # (module nil ((func Str FuncTypeDef LocalsRef IL end) NeFuncDefL) GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr Ctr + 1} # (module nil NeFuncDefL GlobalDefL) # {typeIndCtx IndTypeCtxSTR} insert(Str, Ctr, IndFuncCtx) < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # insert(Ctr, (func Str get-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) LocalsRef IL end), FuncStore) # TypeStore #
                      if valid-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) .

  crl [parse-funcdef-last-str] : {StartFunc, indctr Ctr} # (module nil (func Str FuncTypeDef LocalsRef IL end) GlobalDefL) # {typeIndCtx IndTypeCtxSTR} IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr 0} # (module nil nil GlobalDefL) # {typeIndCtx IndTypeCtxSTR} insert(Str, Ctr, IndFuncCtx) < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # insert(Ctr, (func Str get-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) LocalsRef IL end), FuncStore) # TypeStore #
                      if valid-functype(FuncTypeDef, TypeStore, IndTypeCtxSTR) .

  rl [parse-globaldef] : {StartFunc, indctr Ctr} # (module nil nil ((global Str (GlobalType) (ConstInst)) NeGlobalDefL) ) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr Ctr + 1} # (module nil nil NeGlobalDefL) # IndTypeCtx IndFuncCtx < ConstInst (global.set Str) uninitialized | ST | empty > # insert(Str, Ctr, GlobalAddrs) <-> GlobalsStore # FuncStore # TypeStore # .

  rl [parse-globaldef-last] : {StartFunc, indctr Ctr} # (module nil nil (global Str (GlobalType) (ConstInst))) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                      =>
                      {StartFunc, indctr 0} # (module nil nil nil) # IndTypeCtx IndFuncCtx < ConstInst (global.set Str) uninitialized | ST | empty > # insert(Str, Ctr, GlobalAddrs) <-> GlobalsStore # FuncStore # TypeStore # .


  rl [start-sim] : {start N, indctr Ctr} # (module nil nil nil) # IndTypeCtx IndFuncCtx < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                   =>
                   {start N, indctr 0} # (module nil nil nil) # simulate-wasm(IndTypeCtx IndFuncCtx < (call N) | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore) # .
  rl [start-sim-str] : {start Str, indctr Ctr} # (module nil nil nil) # {typeIndCtx IndTypeCtxSTR} {funcIndCtx IndFuncCtxSTR } < uninitialized | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore #
                        =>
                        {start Str, indctr 0} # (module nil nil nil) # simulate-wasm({typeIndCtx IndTypeCtxSTR} {funcIndCtx IndFuncCtxSTR} < (call (IndFuncCtxSTR[Str])) | ST | empty > # GlobalAddrs <-> GlobalsStore # FuncStore # TypeStore) # .

  *** local.get rule: push to stack the value from ValR from the local store
  rl [local.get] : < (local.get ValR) IL | ST | LocalSTR LocalSTRList >   =>   < IL | st-push(ST, lookup(LocalSTR, ValR)) | LocalSTR LocalSTRList > .

  *** local.set rule: pop value from stack and store it in ValR in the local store
  rl [local.set] : < (local.set ValR) IL | ST | LocalSTR LocalSTRList >   =>   < IL | st-pop(ST) | insert(ValR, st-head(ST), LocalSTR) LocalSTRList > .

  *** local.tee rule: pop from stack, push value from ValR two times to stack, then execute local.set ValR
  *** TODO: leave the double push like that or use a different op to double push with only one lookup ??
  rl [local.tee] : < (local.tee ValR) IL | ST | LocalSTR LocalSTRList >   =>   < (local.set ValR) IL | st-push(st-push(st-pop(ST), lookup(LocalSTR, ValR)), lookup(LocalSTR, ValR)) | LocalSTR LocalSTRList > .

  *** global variable rules

  rl [global.get] : < (global.get Str) IL | ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore
                  =>   
                  < IL | st-push(ST, global-val(GlobalsStore[GlobalAddrs[Str]])) | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore .

  *** TODO: generlize for all types of values (refs, labels, etc.)
  crl [global.set] : < (global.set Str) IL | const(T, ValW1) $ ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore
                  =>   
                  < IL | ST | NeLocalSTRList > # GlobalAddrs <-> insert(GlobalAddrs[Str], {type (mut T), value const(T, ValW1)}, GlobalsStore) 
                  if (global-type(GlobalsStore[GlobalAddrs[Str]]) == (mut T)) or GlobalsStore[GlobalAddrs[Str]] == undefined .

  *** Parametric Instructions
  rl [drop] : < (drop) IL | Val $ ST | NeLocalSTRList > 
                  =>   
                  < IL | ST | NeLocalSTRList > .
  rl [select] : < (select) IL | const(i32, ValW2) $ Val2 $ Val1 $ ST | NeLocalSTRList > 
                  =>   
                  < IL | selectVal(ValW2, Val1, Val2) $ ST | NeLocalSTRList > .


  *** t.const rule: push Val of type T to stack
  crl [int-const] : < (IntT .const IntN) IL | ST | NeLocalSTRList >   
                    =>   
                    < IL | st-push(ST, const(IntT, val(IntN))) | NeLocalSTRList > 
                    if 0 <= IntN and IntN < (2 ^ (bit-width(IntT))) .
  rl [int-as-float-const] : < (FloatT .const IntN) IL | ST | NeLocalSTRList >   =>   < (FloatT .const float(IntN)) IL | ST | NeLocalSTRList > .
  crl [float-const-nonZ] : < (FloatT .const FloatN) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, correctFloat(const(FloatT, val(FloatN)))) | NeLocalSTRList > 
                            if FloatN =/= 0.0 .
  rl [float-const-Z] : < (FloatT .const 0.0) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, correctFloat(const(FloatT, val(zero(pos))))) | NeLocalSTRList > .

  *** ibinop: pop two int values from stack, operate and push the result to stack
  rl [t.binop] : < (T . binopT) IL | const(T, ValW2) $ const(T, ValW1) $ ST | NeLocalSTRList >   
                   => 
                   if binop(T, binopT, ValW1, ValW2) =/= und
                   then
                      < IL | st-push(ST, binop(T, binopT, ValW1, ValW2)) | NeLocalSTRList >
                   else
                      trap("Binop result undefined")
                   fi .

  *** FUnops
  rl [t.unop] : < (T . unopT) IL | const(T, ValW1) $ ST | NeLocalSTRList >   
                   => 
                   < IL | st-push(ST, unop(T, unopT, ValW1) ) | NeLocalSTRList > .

  *** relop
  rl [t.relop] : < (T . relopT) IL | const(T, ValW2) $ const(T, ValW1) $ ST | NeLocalSTRList >   
            =>   
            < IL |  const(i32, relop(T, relopT, ValW1, ValW2)) $ ST | NeLocalSTRList > .

  *** testop
  rl [t.eqz] : < (IntT . eqz) IL | const(IntT, ValW1) $ ST | NeLocalSTRList >   
            =>   
            < IL |  const(i32, ieq(ValW1, val(0))) $ ST | NeLocalSTRList > .

  *** Conversions
  rl [i32.wrap_i64] : < (i32 . "wrap_" i64) IL | const(i64, ValW1) $ ST | NeLocalSTRList >   
                    =>   
                    < IL |  const(i32, wrap(i64, i32, ValW1)) $ ST | NeLocalSTRList > .
  rl [f32.demote_f64] : < (f32 . "demote_" f64) IL | const(f64, ValW1) $ ST | NeLocalSTRList >   
                    =>   
                    < IL |  const(f32, demote(f64, f32, ValW1)) $ ST | NeLocalSTRList > .
  rl [f64.promote_f32] : < (f64 . "promote_" f32) IL | const(f32, ValW1) $ ST | NeLocalSTRList >   
                    =>   
                    < IL |  const(f64, promote(f32, f64, ValW1)) $ ST | NeLocalSTRList > .
  

  *** Control instructions
  rl [nop] : < nop IL | ST | NeLocalSTRList >   
            =>   
            < IL | ST | NeLocalSTRList > .
  crl [block-resultT] : < ((block ResultType) IL2 end) IL end | ST | NeLocalSTRList >
               =>
               < IL2 end | st-push(ST, label("block", IL end)) | NeLocalSTRList >
               if valid-stack(ST, nil) .
  crl [block-tref] : {typeIndCtx IndTypeCtxSTR} IndFuncCtx < ((block TypeRef) IL2 end) IL end | ST | NeLocalSTRList > # GlobalInventory # FuncStore # TypeStore
               =>
               {typeIndCtx IndTypeCtxSTR} IndFuncCtx < IL2 end | st-push(ST, label("block", IL end)) | NeLocalSTRList > # GlobalInventory # FuncStore # TypeStore
               if valid-stack(ST, aux-get-paramlistTList-func(getParamType(expand(TypeRef, IndTypeCtxSTR, TypeStore)))) .
  rl [end] : < end | NeST | NeLocalSTRList >   =>   < get-inst-list-label(reset-st(NeST)) | get-st(reset-st(NeST)) | NeLocalSTRList > .
  rl [if-else] : < (if BlockType IL1 else IL2 end) IL | const(i32, ValW1) $ ST | NeLocalSTRList >   
                 =>
                 < if-else(ValW1, IL1, IL2, IL, BlockType) | ST | NeLocalSTRList > .
  *** loop is an infinite loop
  crl [loop-resultT] : < ((loop ResultType) IL2 end) IL | ST | NeLocalSTRList >
              =>
              < IL2 end | st-push(ST, label("loop", (loop ResultType) IL2 end)) | NeLocalSTRList >
              if valid-stack(ST, nil) .
  crl [loop-tref] : {typeIndCtx IndTypeCtxSTR} IndFuncCtx < ((loop TypeRef) IL2 end) IL | ST | NeLocalSTRList >  # GlobalInventory # FuncStore # TypeStore  
              =>
              {typeIndCtx IndTypeCtxSTR} IndFuncCtx < IL2 end | st-push(ST, label("loop", (loop TypeRef) IL2 end)) | NeLocalSTRList > # GlobalInventory # FuncStore # TypeStore
              if valid-stack(ST, aux-get-paramlistTList-func(getParamType(expand(TypeRef, IndTypeCtxSTR, TypeStore)))) .
  rl [br] : < (br N) IL | ST | NeLocalSTRList >   
            =>   
            < jump-to-L(get-ith-stackandlabel(ST, N, EmptyStack)) IL end | ST | NeLocalSTRList > .
  rl [jump-to-L] : < jump-to-L(ST1 || label(Str, IL1)) IL | ST | NeLocalSTRList > 
                  =>
                  < IL1 | ST1 | NeLocalSTRList > .
  crl [br_if] : < ("br_if" N) IL | const(i32, val(Int1)) $ ST | NeLocalSTRList >
               =>   
               < (br N) IL | ST | NeLocalSTRList > 
               if Int1 =/= 0 .
  rl [br_if-else] : < ("br_if" N) IL | const(i32, val(0)) $ ST | NeLocalSTRList >
                =>   
                < IL | ST | NeLocalSTRList > .

  *** According to Specification: param init precedes local vars init
  crl [call] : < (call Addr) IL | ST | LocalSTRList > # GlobalInventory # FuncStore
              =>   
              < get-IL-func(FuncStore[Addr]) exit-func(get-resultlistTList-func(FuncStore[Addr])) end | 
                label("func", IL) $ st-popN(ST, count-paramlist-func(FuncStore[Addr])) | 
                init-store(get-paramlistTList-func(FuncStore[Addr]) get-localsTList-func(FuncStore[Addr]), st-getTopVals(ST, get-paramlistTList-func(FuncStore[Addr])), (empty).Map{ValRef,Value}) LocalSTRList 
              > # GlobalInventory # FuncStore 
              if valid-stack(ST, get-paramlistTList-func(FuncStore[Addr])) .
  
  rl [call-by-name] : {funcIndCtx IndFuncCtxSTR } < (call Str) IL | ST | LocalSTRList > # GlobalInventory # FuncStore
              =>   
              {funcIndCtx IndFuncCtxSTR } < (call (IndFuncCtxSTR[Str])) IL | ST | LocalSTRList > # GlobalInventory # FuncStore .

  *** TODO: validation in this case should be with exact values? Stack shall only have TypeTokenList (n) values?
  crl [exit-func] : < exit-func(TypeTokenList) IL | ST | LocalSTR NeLocalSTRList > # GlobalInventory # FuncStore
                  =>   
                  < IL | ST | NeLocalSTRList > # GlobalInventory # FuncStore 
                  if valid-stack(ST, TypeTokenList) .
    

  *** lookup rule: get value from reference from local store
  ***rl [lookup] : lookup(LocalSTR, ValR) => LocalSTR[ValR] .
  eq lookup(LocalSTR, ValR) = LocalSTR[ValR] .

  *** List{Inst} operations 
  op head : NeList{Inst} -> Inst .
  eq head(I1 IL) = I1 .

  op tail : NeList{Inst} -> List{Inst} .
  eq tail(I1 IL) = IL .
  ***eq tail(EmptyList) = EmptyList .

  *** Stack operations
  op st-push : Stack StackElem -> NeStack .
  eq st-push(ST, STElem) = STElem $ ST .
  eq st-push(EmptyStack, STElem) = STElem $ EmptyStack .

  op st-head : NeStack -> StackElem .
  eq st-head(STElem $ ST) = STElem .

  op st-pop : NeStack -> Stack .
  eq st-pop(STElem $ ST) = ST .

  op st-rev : Stack -> Stack .
  eq st-rev(STElem $ ST) = st-rev(ST) $ STElem .
  eq st-rev(EmptyStack) = EmptyStack .

  op st-popN : Stack Nat -> Stack .
  eq st-popN(ST, 0) = ST .
  ceq st-popN(STElem $ ST, N) = st-popN(ST, N - 1) if N > 0 .

  op st-getTopVals : Stack List{TypeToken} -> Stack .
  eq st-getTopVals(ST, nil) = ST .
  eq st-getTopVals(const(T, ValW1) $ ST, T TList) = const(T, ValW1) $ st-getTopVals(ST, TList) .

  *** Globals auxiliary ops
  op global-val : GlobalInstance -> Value .
  eq global-val({type GlobalType, value Val}) = Val .

  op global-type : GlobalInstance -> GlobalType .
  eq global-type({type GlobalType, value Val}) = GlobalType .

  *** Only change value if it is marked as mutable (mut/var) global variable (due to validation requirements).
  ***op insert-gb-val : Addr Value Map{Addr, GlobalInstance} -> Map{Addr, GlobalInstance} .
  ***eq insert-gb-val(Addr, Val2, (Addr |-> {type MutGlobalType, value Val1}, GlobalsStore)) = (Addr |-> {type MutGlobalType, value Val2}, GlobalsStore) .

  *** reset stack to eliminate label
  op _||_ : Stack Label -> StackAndLabel .
  op reset-st : Stack -> StackAndLabel .
  eq reset-st(Val $ ST) = Val $ get-st(reset-st(ST)) || get-label(reset-st(ST)) .
  eq reset-st(Label $ ST) = ST || Label .
  eq reset-st(EmptyStack) = EmptyStack || und .

  op get-inst-list-label : StackAndLabel -> List{Inst} .
  eq get-inst-list-label(ST || label(Str, IL)) = IL .

  op get-st : StackAndLabel -> Stack .
  eq get-st(ST || Label) = ST .
  eq get-st(ST || und) = ST .

  op get-label : StackAndLabel -> Label .
  eq get-label(ST || Label) = Label .
  eq get-label(ST || und) = und .

  op get-ith-stackandlabel : Stack Nat Stack -> StackAndLabel .
  eq get-ith-stackandlabel(Val $ ST, N, TempST) = get-ith-stackandlabel(ST, N, Val $ TempST) .
  *** TODO: check multiple parses warning
  ceq get-ith-stackandlabel(Label $ ST, N, TempST) = get-ith-stackandlabel(ST, N - 1, TempST) if N > 0 .
  eq get-ith-stackandlabel(Label $ ST, 0, TempST) = TempST $ ST || Label .

  op if-else : ValWrapper List{Inst} List{Inst} List{Inst} BlockType -> List{Inst} .
  ceq if-else(val(Int1), IL1, IL2, IL, BlockType) = ((block BlockType) IL1 end) IL if Int1 =/= 0 .
  eq if-else(val(Int1), IL1, IL2, IL, BlockType) = ((block BlockType) IL2 end) IL [owise] .
  
  op get-IL-func : FuncDef -> List{Inst} .
  eq get-IL-func(func N FuncTypeDef LocalsRef IL end) = IL .
  eq get-IL-func(func Str FuncTypeDef LocalsRef IL end) = IL .

  op exit-func : List{TypeToken} -> Inst [ctor] .

  op get-localsref-func : FuncDef -> LocalsRef .
  eq get-localsref-func(func N FuncTypeDef LocalsRef IL end) = LocalsRef .
  eq get-localsref-func(func Str FuncTypeDef LocalsRef IL end) = LocalsRef .

  op get-localsTList-func : FuncDef -> List{TypeToken} .
  eq get-localsTList-func(func N FuncTypeDef (local TList) IL end) = TList .
  eq get-localsTList-func(func Str FuncTypeDef (local TList) IL end) = TList .

  op get-paramlist-func : FuncDef -> ParamType .
  eq get-paramlist-func(func N (ParamType ResultType) LocalsRef IL end) = ParamType .
  eq get-paramlist-func(func Str (ParamType ResultType) LocalsRef IL end) = ParamType .
  eq get-paramlist-func(func N (ParamType) LocalsRef IL end) = ParamType .
  eq get-paramlist-func(func Str (ParamType) LocalsRef IL end) = ParamType .
  eq get-paramlist-func(func N (ResultType) LocalsRef IL end) = (param nil) .
  eq get-paramlist-func(func Str (ResultType) LocalsRef IL end) = (param nil) .
  
  op get-resultlist-func : FuncDef -> ParamType .
  eq get-resultlist-func(func N (ParamType ResultType) LocalsRef IL end) = ResultType .
  eq get-resultlist-func(func Str (ParamType ResultType) LocalsRef IL end) = ResultType .
  eq get-resultlist-func(func N (ParamType) LocalsRef IL end) = (result nil) .
  eq get-resultlist-func(func Str (ParamType) LocalsRef IL end) = (result nil) .
  eq get-resultlist-func(func N (ResultType) LocalsRef IL end) = ResultType .
  eq get-resultlist-func(func Str (ResultType) LocalsRef IL end) = ResultType .

  op aux-get-paramlistTList-func : ParamType -> List{TypeToken} .
  eq aux-get-paramlistTList-func((param TList)) = TList .

  op get-paramlistTList-func : FuncDef -> List{TypeToken} .
  eq get-paramlistTList-func(FuncDef) = aux-get-paramlistTList-func(get-paramlist-func(FuncDef)) .

  op aux-get-resultlistTList-func : ResultType -> List{TypeToken} .
  eq aux-get-resultlistTList-func((result TList)) = TList .

  op get-resultlistTList-func : FuncDef -> List{TypeToken} .
  eq get-resultlistTList-func(FuncDef) = aux-get-resultlistTList-func(get-resultlist-func(FuncDef)) .

  op count-locals-localsref : LocalsRef -> Nat .
  eq count-locals-localsref(local nil) = 0 .
  eq count-locals-localsref(local (T TypeTokenList)) = 1 + count-locals-localsref(local TypeTokenList) .

  op count-locals-paramlist : ParamType -> Nat .
  eq count-locals-paramlist((param nil)) = 0 .
  eq count-locals-paramlist((param (T TypeTokenList))) = 1 + count-locals-paramlist((param TypeTokenList)) .

  op count-paramlist-func : FuncDef -> Nat .
  eq count-paramlist-func(FuncDef) = count-locals-paramlist(get-paramlist-func(FuncDef)) .

  op expand : BlockType Map{String, Addr} Map{Addr, TypeDef} -> ParamResultType .
  eq expand((type Id), IndTypeCtxSTR, TypeStore) = get-functype-typedef(TypeStore[Id]) .
  eq expand((type Str), IndTypeCtxSTR, TypeStore) = get-functype-typedef(TypeStore[IndTypeCtxSTR[Str]]) .

  *** Inizialize a LocalStore with typed variables
  op init-store : List{TypeToken} Stack Map{ValRef, Value} -> Map{ValRef, Value} .
  eq init-store(nil, ST, LocalSTR) = LocalSTR .
  eq init-store(NeTList, ST, LocalSTR) = inizialize-store(0, NeTList, ST, LocalSTR) .

  op inizialize-store : Nat List{TypeToken} Stack Map{ValRef, Value} -> Map{ValRef, Value} .
  eq inizialize-store(N, nil, ST, LocalSTR) = LocalSTR .
  eq inizialize-store(N, T TList, const(T, ValW1) $ ST, LocalSTR) = insert(N, const(T, ValW1), inizialize-store(N + 1, TList, ST, LocalSTR)) .
  eq inizialize-store(N, T TList, EmptyStack, LocalSTR) = insert(N, defaultVal(T), inizialize-store(N + 1, TList, EmptyStack, LocalSTR)) .

  *** Auxiliary parametric instructions
  op selectVal : ValWrapper Value Value -> Value .
  ceq selectVal(val(Int1), Val1, Val2) = Val1 if Int1 =/= 0 .
  eq selectVal(val(Int1), Val1, Val2) = Val2 [owise] .


  ****************
  *** Verification
  ****************
  
  *** Assert there are n values on top of stack with specific types
  op valid-stack : Stack List{TypeToken} -> Bool .
  eq valid-stack(ST, nil) = true .
  eq valid-stack(const(T, ValW1) $ ST, T TList) = valid-stack(ST, TList) .
  eq valid-stack(ST, TList) = false [owise] .

endm

fmod WASM-TOKENIZER-MOD is

  protecting LEXICAL .
	protecting STRING-OPS .

	*** Tokenize as WASM program for Maude
	op tokenize-wasm : String -> QidList .
	op tokenize-wasm : QidList -> QidList .

	var S C C2 : String .
	var Q  : Qid .
	var QL : QidList .
	var N? : FindResult .

	eq tokenize-wasm(S) = tokenize-wasm(tokenize(S)) .

	eq tokenize-wasm(nil) = nil .
	eq tokenize-wasm(Q QL) =
		if startsWith(string(Q), "\"") then
			Q
		else
			splitDot(removeChar(removeChar(string(Q), "_", "~"), "\n", " "))
		fi
		tokenize-wasm(QL) .

	*** Replace char by another non-problematic symbol
	op removeChar : String String String -> String .

	ceq removeChar(S, C, C2) =
		if N? :: Nat then
			removeChar(substr(S, 0, N?) + C2 + substr(S, s N?, sd(length(S), N?)), C, C2)
		else
			S
		fi
	 if N? := find(S, C, 0) .

	*** Split words by a dot
	op splitDot : String -> QidList .

	ceq splitDot(S) =
		if (startsWith(S, "i") or startsWith(S, "f")) and N? :: Nat then
			qid(substr(S, 0, N?))
      if substr(S, N?, sd(length(S), N?)) =/= ".const" then
        qid(substr(S, N?, 1))
        qid(substr(S, s(N?), sd(length(S), N?)))
      else
        qid(substr(S, N?, sd(length(S), N?)))
      fi
		else
			qid(S)
		fi
	 if N? := find(S, ".", 0) .

endfm

mod WASM-MAUDE is
  protecting WASM-TOKENIZER-MOD .
	protecting META-LEVEL .
  protecting WASM-FILE-MOD .

  ***protecting WASMMOD .
endm

*** erew metaParse(['WASMMOD], tokenize-wasm(run-func-from-file("examples/factorial_adapt.wat")), 'WASMModule) .
