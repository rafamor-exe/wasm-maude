mod WASMMOD is
  *** RAFAEL MORALES PALACIOS
  
  *** IMPORT DATATYPE MODULES TO BE USED
  protecting NAT .
  protecting INT .
  
  *** Declare sorts to be used and hierarchy between them.
  sorts WASMSim WASMModule TypeVec NeTypeVec TypeDef Id FuncType FuncVec NeFuncVec FuncDef FuncParamList FuncResult FuncExport ExportVec NeExportVec ExportDef InstList NeInstList Inst EmptyList InstTag ParamList Param Stack EmptyStack NeStack ValRef ValRefList NeValRefList LocalStore EmptyLocalStore NeLocalStore Assign Value .
  
  *** Simulator components
  subsorts Stack InstList < WASMSim .
  subsorts EmptyStack NeStack < Stack .
  subsorts EmptyLocalStore NeLocalStore < LocalStore .
  subsorts Assign < NeLocalStore .

  *** Module sections sorts
  subsorts NeTypeVec EmptyList < TypeVec .
  subsorts TypeDef < NeTypeVec .
  subsorts NeFuncVec EmptyList < FuncVec .
  subsorts FuncDef < NeFuncVec .
  subsorts NeExportVec EmptyList < ExportVec .
  subsorts ExportDef < NeExportVec .

  *** Instruction lists sorts
  subsorts NeInstList EmptyList < InstList .
  subsorts Inst < NeInstList .
  *** TODO: Maybe not needed: 
  subsorts Param < ParamList .
  *** TODO: Include variable references as ValRef 
  subsorts Nat < ValRef < NeStack NeValRefList < ValRefList .
  subsorts Int < Value .
  subsorts EmptyList < ValRefList .

  op EmptyList : -> EmptyList [ctor] .

  *** TODO: check associativity on funcVec...

  ***op __ : InstList Stack -> WASMSim [assoc comm ctor] .
  *** < InstList | Stack | LocalStore >
  op <_|_|_> : InstList Stack LocalStore -> WASMSim .

  op [_<-_] : ValRef Value -> Assign [ctor] .
  op EmptyLocalStore : -> LocalStore [ctor] .
  op __ : Assign LocalStore -> NeLocalStore [assoc comm ctor id: EmptyLocalStore] .  *** Store[n <- v] means local n = v
    *** lookup values from store
  op lookup : NeLocalStore ValRef -> Value .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = Val if ValR == ValR2 .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = lookup(LocalSTR, ValR) if ValR =/= ValR2 .
  *** TODO: error otherwise or leave undefined??

  *** Module sections
  op (module _ _ _) : TypeVec FuncVec ExportVec -> WASMModule [ctor] .
  op __ : TypeDef TypeVec -> NeTypeVec [assoc ctor id: EmptyList] .
  op __ : FuncDef FuncVec -> NeFuncVec [assoc ctor id: EmptyList] .
  op __ : ExportDef ExportVec -> NeExportVec [assoc ctor id: EmptyList] .

  op (type _ _) : Id FuncType -> TypeDef [ctor] .
  op (func _ _ _ _) : Id FuncParamList FuncResult NeInstList -> FuncDef [ctor] .
  op (export _ _) : Id FuncExport -> ExportDef [ctor] .

  
  *** InstList is a List of Instructions

  op __ : Inst InstList -> NeInstList [assoc ctor id: EmptyList] .
  
  ***op __ : InstTag ParamList -> Inst [ctor] .

  *** op __ : Param ParamList -> ParamList [assoc ctor] .

  op local.get _ : ValRef -> Inst [ctor] .
  op local.set _ : ValRef -> Inst [ctor] .

  *** Stack ops
  op EmptyStack : -> EmptyStack [ctor] .
  op _$_ : ValRef Stack -> NeStack [ctor id: EmptyStack] .

  vars I1 S1 : Inst .
  var ValR ValR2 : ValRef .
  var Val : Value .
  var IL : InstList .
  var ST : Stack .
  var LocalSTR : LocalStore .

  *** local.get rule: push to stack the value from ValR in the instruction
  rl [local-get] : < (local.get ValR) IL | ST | LocalSTR > => < IL | push(ST, lookup(LocalSTR, ValR)) | LocalSTR > .

  *** lookup rule: get value from reference from local store
  rl [lookup] : lookup([ValR <- Val] LocalSTR, ValR) => Val .

  op head : InstList -> Inst .
  eq head(I1 IL) = I1 .

  op tail : InstList -> InstList .
  eq tail(I1 IL) = IL .
  eq tail(EmptyList) = EmptyList .

  op push : Stack ValRef -> NeStack .
  eq push(ST, ValR) = ValR $ ST .
  eq push(EmptyStack, ValR) = ValR $ EmptyStack .




  

endm

