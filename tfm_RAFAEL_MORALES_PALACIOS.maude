fmod WASM-TYPETOKEN-MOD is

  sorts TypeToken IntTypeToken FloatTypeToken .
  subsorts FloatTypeToken IntTypeToken < TypeToken .

  ops i32 i64 : -> IntTypeToken [ctor] .
  ops f32 f64 : -> FloatTypeToken [ctor] .

endfm

view TypeToken from TRIV to WASM-TYPETOKEN-MOD is
  sort Elt to TypeToken .
endv

fmod WASM-BIT-MOD is

  protecting INT .

  sorts Bit .
  ***subsorts Bit < Int .

  ops 0 1 : -> Bit [ctor] .

endfm

view Bit from TRIV to WASM-BIT-MOD is
  sort Elt to Bit .
endv

fmod WASM-BITVAL-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-BIT-MOD .
  protecting INT .
  protecting LIST{Bit} .
  ***protecting FLOAT .
  ***protecting CONVERSION .

  sorts Bini Bini32 Bini64 BitStringSize BitVal .
  ***sorts Binf Binf32 Binf64 ..
  ***subsorts Binf32 Binf64 < Binf < String .
  ***subsort BitStringSize < Int .

  var I I2 : Int .
  var N : Nat .
  var B B1 B2 : Bit .
  var TypeToken : TypeToken .
  var BitList BS BS1 BS2 : List{Bit} .
  ***var F : Float .
  ***var BitStringSize : BitStringSize .

  
  ***mb 32 : BitStringSize .
  ***mb 64 : BitStringSize .

  *** BitVal representation (valid for int and float): contains typetoken for type-checking and bitstring. 
  op {valtype _, bitstring _} : TypeToken List{Bit} -> BitVal [ctor] .

  *** Auxliary functions for getting BitVal propperty values
  op get-type-bitval : BitVal -> TypeToken .
  eq get-type-bitval({valtype TypeToken, bitstring BitList}) = TypeToken .
  op get-bitstring-bitval : BitVal -> List{Bit} .
  eq get-bitstring-bitval({valtype TypeToken, bitstring BitList}) = BitList .

  *** Convert Maude Int to i32 bitstring
  op int-to-i32 : Int -> BitVal [ctor] .
  eq int-to-i32(I) = {valtype i32 , bitstring int-to-bitstring(I, 32)} .

  *** Convert Maude Int to i64 bitstring  
  op int-to-i64 : Int -> BitVal [ctor] .
  eq int-to-i64(I) = {valtype i64, bitstring int-to-bitstring(I, 64)} .

  *** Auxiliary op to convert int to bitstring of certain size
  *** TODO: Manage overflow
  op int-to-bitstring : Int Int -> List{Bit} [ctor] .
  ceq int-to-bitstring(0, I2) = 0 if I2 == 1 .
  eq int-to-bitstring(0, I2) = padding(I2) 0 [owise] .
  ceq int-to-bitstring(1, I2) = 1 if I2 == 1 .
  eq int-to-bitstring(1, I2) = padding(I2) 1 [owise] .
  ceq int-to-bitstring(I, I2) = int-to-bitstring(I quo 2, I2 - 1) 0 if I rem 2 == 0 and I2 > 1 .
  ceq int-to-bitstring(I, I2) = int-to-bitstring(I quo 2, I2 - 1) 1 if I rem 2 =/= 0 and I2 > 1 .

  *** Front padding for bitstrings
  op padding : Nat -> List{Bit} .
  eq padding(1) = 0 .
  eq padding(N) = padding(N - 1) 0 .


  *** Convert i32 bitstring to Maude Int
  op i32-to-int : BitVal -> Int [ctor] .
  eq i32-to-int({valtype i32 , bitstring BitList}) = bitstring-to-int(BitList, 32) .

  *** Convert i64 bitstring to Maude Int
  op i64-to-int : BitVal -> Int [ctor] .
  eq i64-to-int({valtype i64 , bitstring BitList}) = bitstring-to-int(BitList, 64) .

  *** Convert bitstring to int
  op bitstring-to-int : List{Bit} Int -> Int .
  ceq bitstring-to-int(B BitList, 1) = 0 if B == 0 .
  ceq bitstring-to-int(B BitList, 1) = 1 if B == 1 .
  ceq bitstring-to-int(B BitList, I) = bitstring-to-int(BitList, I - 1) if B == 0 and I > 1 .
  ceq bitstring-to-int(B BitList, I) = ((2 ^ (I - 1)) * 1) + bitstring-to-int(BitList, I - 1) if B == 1 and I > 1 .

  *** Logic operations
  op not _ : List{Bit} -> List{Bit} [ctor] .
  eq not (0) = 1 .
  eq not (1) = 0 .
  eq not (BS 0) = not(BS) 1 .
  eq not (BS 1) = not(BS) 0 .

  op iand : List{Bit} List{Bit} -> List{Bit} [ctor] .
  eq iand(B, 0) = 0 .
  eq iand(0, B) = 0 .
  eq iand(1, 1) = 1 .
  eq iand(BS1 B1, BS2 B2) = iand(BS1, BS2) iand(B1, B2) .

  *** string() conversion allows to modify the base of the representation
  ***eq int-to-bitstring(I, BitStringSize) = string(I , 2) .
  ***eq int-to-bitstring(I, BitStringSize) = 
  
  ***op float-to-bitstring : Float BitStringSize -> Binf [ctor] .
  ***eq float-to-bitstring(F, BitStringSize) = string(F) .

endfm


fmod WASM-FUNCTYPE-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting LIST{TypeToken} .

  sorts ParamType ResultType .

  *** NOTE: List{TypeToken} needs to be wrapped on parenthesis for Maude to parse it correctly
  op (param _) : List{TypeToken} -> ParamType [ctor] .
  op (result _) : List{TypeToken} -> ResultType [ctor] .


endfm

view ParamType from TRIV to WASM-FUNCTYPE-MOD is
  sort Elt to ParamType .
endv
view ResultType from TRIV to WASM-FUNCTYPE-MOD is
  sort Elt to ResultType .
endv

fmod WASM-TYPEDEF-MOD is

  protecting NAT .
  protecting WASM-FUNCTYPE-MOD .
  protecting LIST{ParamType} .
  protecting LIST{ResultType} .

  sorts TypeDef Id FuncType ParamResultFuncType .
  subsorts Nat < Id .

  *** TODO: (for syntax reasons) be able to declare only param or result or none (now nil is required)
  ***op _ _ : List{ParamType} List{ResultType} -> ParamResultFuncType [ctor] .
  ***op _ : List{ParamType} -> ParamResultFuncType [ctor] .
  ***op _ : List{ResultType} -> ParamResultFuncType [ctor] .

  ***op (func _) : ParamResultFuncType -> FuncType [ctor] .
  op (func _ _) : List{ParamType} List{ResultType} -> FuncType [ctor] .

  op (type _ _) : Id FuncType -> TypeDef [ctor] .

endfm

view TypeDef from TRIV to WASM-TYPEDEF-MOD is
  sort Elt to TypeDef .
endv

fmod WASM-VALREF-MOD is

  protecting NAT .
  protecting QID .

  sorts ValRef Addr .

  subsorts Nat Qid < ValRef .
  subsorts Nat < Addr .

endfm

view Addr from TRIV to WASM-VALREF-MOD is
  sort Elt to Addr .
endv

fmod WASM-NANS-MOD is

  protecting FLOAT .

  sorts NaN NaNFloat NFloat .
  subsorts NaN NFloat < NaNFloat .

  op nanF : Float -> NFloat [ctor] .
  *** TODO: To be more exact, NaN values include the value of the mantissa in the binary representation
  op nan : -> NaN [ctor] .

endfm

view NaNFloat from TRIV to WASM-NANS-MOD is
  sort Elt to NaNFloat .
endv

fmod WASM-VALUE-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-NANS-MOD .
  protecting LIST{NaNFloat} .
  protecting FLOAT .
  protecting INT .
  protecting CONVERSION .

  sorts Value IntValue Int32Value Int64Value UInt SInt FloatValue ValWrapper NaNs Inf Sign Zero .

  subsorts Int < UInt SInt IntValue < Value .
  subsorts FloatValue < Value .
  ***subsorts Int32Value Int64Value < IntValue .

  *** Initial proposal for restricting i32 value
  ***var IntValue : IntValue .
  ***var Val : Value .
  ***cmb IntValue : Int64Value if 0 < IntValue and IntValue < 18446744073709551616 .
  ***cmb IntValue : Int32Value if 0 < IntValue and IntValue < 4294967295 .
  ***cmb Val : FloatValue if (Val == (1 + ) * (2 ^ (e)) or (Val == (1 + ) * (2 ^ (e))) .

  var T : TypeToken .
  var ValWrapper VW1 VW2 : ValWrapper .
  var I1 I2 : Int . 
  var F1 F2 : Float . 

  op pos neg : -> Sign .

  op nans : List{NaNFloat} -> NaNs [ctor] .
  op inf : Sign -> Inf [ctor] .
  op zero : Sign -> Zero [ctor] .

  *** Wrapper for values
  op val : Int -> ValWrapper [ctor] .
  op val : Float -> ValWrapper [ctor] .
  op val : NaN -> ValWrapper [ctor] .
  op val : NaNs -> ValWrapper [ctor] .
  op val : Inf -> ValWrapper [ctor] .
  op val : Zero -> ValWrapper [ctor] .

  op _+_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) + val(I2) = val(I1 + I2) .
  eq val(F1) + val(F2) = val(F1 + F2) .
  op _-_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) - val(I2) = val(I1 - I2) .
  eq val(F1) - val(F2) = val(F1 - F2) .
  op _*_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) * val(I2) = val(I1 * I2) .
  eq val(F1) * val(F2) = val(F1 * F2) .
  op _quo_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) quo val(I2) = val(I1 quo I2) .
  ***eq val(F1) quo val(F2) = val(F1 quo F2) .
  op _rem_ : ValWrapper ValWrapper -> ValWrapper [ctor] .
  eq val(I1) rem val(I2) = val(I1 rem I2) .
  eq val(F1) rem val(F2) = val(F1 rem F2) .

  op _+_ : ValWrapper Int -> ValWrapper [ctor] .
  eq val(I1) + I2 = val(I1 + I2) .
  ***eq val(F1) + I2 = val(F1 + I2) .  
  op _rem_ : ValWrapper Int -> ValWrapper [ctor] .
  eq val(I1) rem I2 = val(I1 rem I2) .
  ***eq val(F1) rem I2 = val(F1 rem I2) .

  *** Represent values "(type).const (value)" pushed to stack
  op const : TypeToken ValWrapper -> Value [ctor] .
  op get-type : Value -> TypeToken .
  eq get-type(const(T, ValWrapper)) = T .
  op get-val : Value -> ValWrapper .
  eq get-val(const(T, ValWrapper)) = ValWrapper .

  *** Memberships of different types
  cmb const(T, ValWrapper) : IntValue if T == i32 or T == i64 . 
  cmb const(T, ValWrapper) : FloatValue if T == f32 or T == f64 . 

endfm

fmod WASM-GLOBALINSTANCE-MOD is
  
  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-VALUE-MOD .

  sorts GlobalInstance GlobalType MutGlobalType .
  subsorts MutGlobalType < GlobalType .

  *** Included mut because of emscripten-compiled example. Not included in the standard...
  op const_ : TypeToken -> GlobalType [ctor] .
  ops var_ mut_ : TypeToken -> MutGlobalType [ctor] .

  op {type _, value _} : GlobalType Value -> GlobalInstance [ctor] .

endfm

view GlobalInstance from TRIV to WASM-GLOBALINSTANCE-MOD is
  sort Elt to GlobalInstance .
endv

fmod WASM-INST-MOD is

  protecting WASM-TYPETOKEN-MOD .
  protecting WASM-VALREF-MOD .
  protecting WASM-VALUE-MOD .

  sorts Inst BinopToken .

  *** Instruction ops declarations
  op local.get _ : ValRef -> Inst [ctor] .
  op local.set _ : ValRef -> Inst [ctor] .
  op local.tee _ : ValRef -> Inst [ctor] .

  *** global insts
  op global.get _ : String -> Inst [ctor] .
  op global.set _ : String -> Inst [ctor] .

  *** TODO: maybe fix to use it as a template??
  *** - The problem is that I think Maude obligues to separate the tokens so it would be like "i32 .const, not i32.const"
  ***op _.const _ : TypeToken Value -> Inst [ctor] .
  op _ .const _ : TypeToken Int -> Inst [ctor] .
  op _ .const _ : FloatTypeToken Float -> Inst [ctor] .
  ***op i64.const _ : IntValue -> Inst [ctor] .
  *** TODO: Include more valid types
  ***ops i32 : -> Type [ctor] .


  *** binop (Binary Operations)
  *** ibinop (Integer binop) - add | sub | mul | div_sx | rem_sx | and | or | xor | shl | shr_sx | rotl | rotr
  ops add sub mul : -> BinopToken [ctor] .
  op _._ : TypeToken BinopToken -> Inst [ctor] .
  ***op _._ : TypeToken BinopToken -> Inst [ctor] .
  ***op _._ : TypeToken BinopToken -> Inst [ctor] .
  *** Insts with underscores (_) need to be preprocessed so that Maude does not misinterpret the _ symbol
  op "i32.div_u" : -> Inst [ctor] .
  op "i32.div_s" : -> Inst [ctor] .
  op "i32.rem_u" : -> Inst [ctor] .
  op "i32.rem_s" : -> Inst [ctor] .

  *** bitstring representation ops
  op i32.and : -> Inst [ctor] .

  *** relop
  op i32.eq : -> Inst [ctor] .
  op i32.ne : -> Inst [ctor] .
  op "i32.lt_s" : -> Inst [ctor] .
  op "i32.lt_u" : -> Inst [ctor] .
  op "i32.gt_s" : -> Inst [ctor] .
  op "i32.gt_u" : -> Inst [ctor] .
  op "i32.le_s" : -> Inst [ctor] .
  op "i32.le_u" : -> Inst [ctor] .
  op "i32.ge_s" : -> Inst [ctor] .
  op "i32.ge_u" : -> Inst [ctor] .

  *** testop
  op i32.eqz : -> Inst [ctor] .

  *** Control Instructions
  op nop : -> Inst [ctor] .
  op unreachable : -> Inst [ctor] .

  op block _ : String -> Inst [ctor] .
  op loop _ : String -> Inst [ctor] .
  op br _ : Nat -> Inst [ctor] .
  op "br_if" _ : Nat -> Inst [ctor] .
  op end : -> Inst [ctor] .

  op call _ : Nat -> Inst [ctor] .

endfm

view Inst from TRIV to WASM-INST-MOD is
  sort Elt to Inst .
endv

view ValRef from TRIV to WASM-VALREF-MOD is
  sort Elt to ValRef .
endv

view Value from TRIV to WASM-VALUE-MOD is
  sort Elt to Value .
endv

fmod WASM-FUNCDEF-MOD is

  protecting WASM-TYPEDEF-MOD .
  protecting LIST{Inst} .

  sorts FuncDef TypeRef LocalsRef .

  op (type _) : Id -> TypeRef [ctor] .
  op (local _) : List{TypeToken} -> LocalsRef [ctor] .

  *** TODO: look for a way of making ParamType, ResultType lists and LocalsRef optional
  op (func _ _ _ _ _ _ end) : Id TypeRef List{ParamType} List{ResultType} LocalsRef List{Inst} -> FuncDef [ctor] .

endfm

view FuncDef from TRIV to WASM-FUNCDEF-MOD is
  sort Elt to FuncDef .
endv

mod WASMMOD is
  *** RAFAEL MORALES PALACIOS - TFM - SEMANTICS OF WEBASSEMBLY IN MAUDE
  
  *** IMPORT DATATYPE MODULES TO BE USED
  ***protecting NAT .
  ***protecting INT .
  ***protecting STRING .
  ***protecting QID .
  protecting WASM-BITVAL-MOD .
  protecting WASM-INST-MOD .
  protecting LIST{Inst} .
  protecting MAP{ValRef, Value} .
  protecting LIST{Map{ValRef, Value}} .
  protecting MAP{String, Addr} .
  protecting MAP{Addr, GlobalInstance} .
  protecting MAP{Addr, FuncDef} .

  protecting WASM-TYPEDEF-MOD .
  protecting LIST{TypeDef} .
  protecting WASM-FUNCDEF-MOD .
  protecting LIST{FuncDef} .

  
  
  *** Declare sorts to be used and hierarchy between them.
  sorts WASMSim WASMFuncGlobalSim WASMGlobalSim WASMLocalSim WASMModule FuncExport ExportVec NeExportVec ExportDef Stack EmptyStack NeStack StackElem EmptyLocalStore NeLocalStore Assign Und Trap Arity Label StackAndLabel FuncStore .
  
  *** Simulator components
  subsorts Stack List{Inst} < WASMLocalSim .
  subsorts EmptyStack NeStack < Stack .
  subsorts EmptyLocalStore NeLocalStore < Map{ValRef, Value} .
  subsorts Assign < NeLocalStore .

  *** Instruction lists sorts
  subsorts Trap < Inst .
  *** TODO: Include variable references as ValRef 
  *** Temporal solution: Use Qid, forces to use ' before the token...check to use $ instead
  ***subsorts Nat Qid < ValRef < NeValRefList < ValRefList .
  *** TODO: Include support for Labels and Activations as Stack values. Problem: collision of operator definition on Nat and String
  *** Temporal solution: Use Qid, forces to use ' before the token...check to use $ instead
  subsorts Value < StackElem < NeStack . ***subsorts Int Und < IntValue < Value < StackElem < NeStack .
  subsorts Und < Label < StackElem . ***subsorts Qid < Label < StackElem .
  subsorts Nat < Arity .

  op trap : String -> Trap [ctor] . 
  
  op label : String List{Inst} -> Label [ctor] .

  op und : -> Und [ctor] .

  op if _ else _ : List{Inst} List{Inst} -> Inst [ctor] .
  ***op EmptyList : -> EmptyList [ctor] .


  *** Local environment
  *** < InstList(List{Inst}) | Stack | LocalStore(Map{ValRef, Value}) >
  op <_|_|_> : List{Inst} Stack Map{ValRef, Value} -> WASMLocalSim [ctor] .

  *** Global environment
  *** WASMLocalSim # GlobalAddrs(Map{ValRef, Nat} <-> GlobalStore(Map{ValRef, Value})
  op _ # _ <-> _ : WASMLocalSim Map{String, Addr} Map{Addr, GlobalInstance} -> WASMGlobalSim [ctor] .

  *** Functions + Global enviroment
  op _ # _ : WASMGlobalSim Map{Addr, FuncDef} -> WASMFuncGlobalSim .

  *** WASM Simulator
  *** # WASMModule # WASMGlobalSim # FuncStore #
  op # _ # _ # : WASMModule WASMFuncGlobalSim -> WASMSim [ctor] .
  

  *** Map{ValRef, Value} definition
  ***op [_<-_] : ValRef Value -> Assign [ctor] .
  op EmptyLocalStore : -> Map{ValRef, Value} [ctor] .
  eq EmptyLocalStore = empty .
  ***op __ : Assign Map{ValRef, Value} -> NeLocalStore [assoc comm ctor id: EmptyLocalStore] .  *** Store[n <- v] means local n = v

  *** Module sections
  *** TODO: complete module parts (global, exports, etc.)
  op (module _ _) : List{TypeDef} List{FuncDef} -> WASMModule [ctor] .

  ***op __ : ExportDef ExportVec -> NeExportVec [assoc ctor id: EmptyList] .

  ***op (export _ _) : Id FuncExport -> ExportDef [ctor] .


  *** Stack definition
  op EmptyStack : -> EmptyStack [ctor] .
  op _$_ : StackElem Stack -> NeStack [ctor id: EmptyStack] .


  *** lookup: auxiliar op to lookup values from store
  op lookup : Map{ValRef, Value} ValRef -> Value .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = Val if ValR == ValR2 .
  ***ceq lookup([ValR2 <- Val] LocalSTR, ValR) = lookup(LocalSTR, ValR) if ValR =/= ValR2 .
  *** TODO: error otherwise or leave undefined??
  op jump-to-L : StackAndLabel -> Inst [ctor] .


  *** Variable definition

  var WASMModule : WASMModule .
  vars I1 S1 : Inst .
  vars ValR ValR2 : ValRef .
  vars Val Val1 Val2 : Value .
  vars IL IL1 IL2 : List{Inst} .
  vars ST TempST ST1 : Stack .
  var NeST : NeStack .
  var LocalSTRList : List{Map{ValRef, Value}} .
  var NeLocalSTRList : NeList{Map{ValRef, Value}} .
  var LocalSTR : Map{ValRef, Value} .
  var T : TypeToken .
  var FloatT : FloatTypeToken .
  var IntT : IntTypeToken .
  vars IntVal IntVal1 IntVal2 : IntValue .
  vars Int1 Int2 : Int .
  var STElem : StackElem .
  var Str : String .
  var Label : Label .
  var N : Nat .
  var GlobalAddrs : Map{String, Addr} .
  var GlobalsStore : Map{Addr, GlobalInstance} .
  var GlobalType : GlobalType .
  var MutGlobalType : MutGlobalType .
  var GlobalInstance : GlobalInstance .
  var Addr : Addr .
  var FuncStore : Map{Addr, FuncDef} .
  var TypeRef : TypeRef .
  var ParamList : List{ParamType} .
  var ResultTypeList : List{ResultType} .
  var LocalsRef : LocalsRef .
  var TypeTokenList : List{TypeToken} .
  var IntN : Int .
  var FloatN F1 F2 : Float .
  var ValW1 ValW2 : ValWrapper .
  var Sg1 Sg2 : Sign .
  var Inf : Inf .
  var Zero : Zero .

  *** Map{ValRef, Value} is a Set
  ***eq [ValR <- Val][ValR <- Val] = [ValR <- Val] .



  *** Rules
  
  *** TODO: Include validation in rules as eqs in preconditions
  *** TODO: Maybe create rules to transform an input of the form of a usual program to this representation with initial empty stack and store??

  *** local.get rule: push to stack the value from ValR from the local store
  rl [local.get] : < (local.get ValR) IL | ST | LocalSTR LocalSTRList >   =>   < IL | st-push(ST, lookup(LocalSTR, ValR)) | LocalSTR LocalSTRList > .

  *** local.set rule: pop value from stack and store it in ValR in the local store
  rl [local.set] : < (local.set ValR) IL | ST | LocalSTR LocalSTRList >   =>   < IL | st-pop(ST) | insert(ValR, st-head(ST), LocalSTR) LocalSTRList > .
  ***crl [local-set-ow] : < (local.set ValR) IL | ST | [ValR <- Val]LocalSTR >   =>   < IL | st-pop(ST) | [ValR <- st-head(ST)]LocalSTR > if Val =/= st-head(ST) .
  ***crl [local-set-ow] : < (local.set ValR) IL | ST | [ValR <- Val]LocalSTR >   =>   < IL | st-pop(ST) | [ValR <- Val]LocalSTR > if Val == st-head(ST)  .

  *** local.tee rule: pop from stack, push value from ValR two times to stack, then execute local.set ValR
  *** TODO: leave the double push like that or use a different op to double push with only one lookup ??
  rl [local.tee] : < (local.tee ValR) IL | ST | LocalSTR LocalSTRList >   =>   < (local.set ValR) IL | st-push(st-push(st-pop(ST), lookup(LocalSTR, ValR)), lookup(LocalSTR, ValR)) | LocalSTR LocalSTRList > .

  *** global variable rules

  rl [global.get] : < (global.get Str) IL | ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore
                  =>   
                  < IL | st-push(ST, global-val(GlobalsStore[GlobalAddrs[Str]])) | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore .

  rl [global.set] : < (global.set Str) IL | Val $ ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore
                  =>   
                  < IL | ST | NeLocalSTRList > # GlobalAddrs <-> insert-gb-val(GlobalAddrs[Str], Val, GlobalsStore) .



  *** t.const rule: push Val of type T to stack
  *** TODO: maybe fix to use it as a template??
  ***rl [t.const] : < (T .const Val) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, Val) | NeLocalSTRList > .
  ***crl [i32.const] : < (i32.const IntVal) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, IntVal) | NeLocalSTRList > if verify-const(IntVal, 32) .
  *** TODO: push "i32 .const IntVal" s.t. we store the type too
  rl [int-const] : < (IntT .const IntN) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(IntT, val(IntN))) | NeLocalSTRList > .
  rl [int-as-float-const] : < (FloatT .const IntN) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(FloatT, val(float(IntN)))) | NeLocalSTRList > .
  rl [float-const] : < (FloatT .const FloatN) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(FloatT, val(FloatN))) | NeLocalSTRList > .
  ***crl [i64.const] : < (i64.const IntVal) IL | ST | NeLocalSTRList >   =>   < IL | st-push(ST, IntVal) | NeLocalSTRList > if verify-const(IntVal, 64) .

  *** ibinop: pop two int values from stack, operate and push the result to stack
  rl [int.add] : < (IntT . add) IL | const(IntT, ValW2) $ const(IntT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(IntT, (ValW1 + ValW2) rem 2 ^ (32)))  | NeLocalSTRList > .
  rl [int.sub] : < (IntT . sub) IL | const(IntT, ValW2) $ const(IntT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(IntT, ((ValW1 - ValW2) + (2 ^ (32))) rem (2 ^ (32)))) | NeLocalSTRList > .
  rl [int.mul] : < (IntT . mul) IL | const(IntT, ValW2) $ const(IntT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(IntT, (ValW1 * ValW2) rem 2 ^ (32))) | NeLocalSTRList > .
  rl [float.add] : < (FloatT . add) IL | const(FloatT, ValW2) $ const(FloatT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(FloatT, fadd(ValW1, ValW2)))  | NeLocalSTRList > .
  ***rl [float.sub] : < (FloatT . sub) IL | const(FloatT, ValW2) $ const(FloatT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(FloatT, ((ValW1 - ValW2) + (2 ^ (32))) rem (2 ^ (32)))) | NeLocalSTRList > .
  ***rl [float.mul] : < (FloatT . mul) IL | const(FloatT, ValW2) $ const(FloatT, ValW1) $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, const(FloatT, (ValW1 * ValW2) rem 2 ^ (32))) | NeLocalSTRList > .
   *** Insts with underscores (_) need to be preprocessed so that Maude does not misinterpret the _ symbol
  crl [i32.div_u-und] : < ("i32.div_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   trap("Binop result undefined") if IntVal2 == 0 .
  crl [i32.div_u] : < ("i32.div_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, abs(IntVal quo IntVal2)) | NeLocalSTRList > if IntVal2 =/= 0 .
  *** TODO: check "multiple distinct parses for statement" in div_s (Parses as String and Inst)
  crl [i32.div_s-und] : < ("i32.div_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   trap("Binop result undefined") if signed(IntVal2, 32) == 0 or (signed(IntVal, 32) quo signed(IntVal2, 32)) == 2 ^ (32 - 1) .
  crl [i32.div_s] : < ("i32.div_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, signed(IntVal, 32) quo signed(IntVal2, 32)) | NeLocalSTRList > if signed(IntVal2, 32) =/= 0 and (signed(IntVal, 32) quo signed(IntVal2, 32)) =/= 2 ^ (32 - 1) .
  crl [i32.rem_u-und] : < ("i32.rem_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   trap("Binop result undefined")  if IntVal2 == 0 .
  crl [i32.rem_u] : < ("i32.rem_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, abs(IntVal rem IntVal2)) | NeLocalSTRList > if IntVal2 =/= 0 .
  crl [i32.rem_s-und] : < ("i32.rem_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   trap("Binop result undefined") if signed(IntVal2, 32) == 0 .
  *** By definition: return the rem of dividing the signed representations of j1/j2 w/ the sign of j1 (design decision: compute sign of j1 as (IntVal quo abs(IntVal)))
  crl [i32.rem_s] : < ("i32.rem_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   =>   < IL | st-push(ST, unsigned(signed(IntVal, 32) - (signed(IntVal2, 32) * (signed(IntVal, 32) quo signed(IntVal2, 32))), 32)) | NeLocalSTRList > if signed(IntVal2, 32) =/= 0 .

  *** instructions with bitstring representation
  rl [i32.and] : < (i32.and) IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
                =>   
                < IL | st-push(ST, i32-to-int({valtype i32, bitstring (iand((get-bitstring-bitval(int-to-i32(IntVal))), (get-bitstring-bitval(int-to-i32(IntVal2)))))})) | NeLocalSTRList > .

  *** irelop
  rl [ieq] : < (i32.eq) IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | ieq(IntVal, IntVal2) $ ST | NeLocalSTRList > .
  rl [ine] : < (i32.ne) IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | ine(IntVal, IntVal2) $ ST | NeLocalSTRList > .
  rl [ilt_s] : < ("i32.lt_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ilt_s"(signed(IntVal, 32), signed(IntVal2, 32)) $ ST | NeLocalSTRList > .
  rl [ilt_u] : < ("i32.lt_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ilt_u"(IntVal, IntVal2) $ ST | NeLocalSTRList > .
  rl [igt_s] : < ("i32.gt_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "igt_s"(signed(IntVal, 32), signed(IntVal2, 32)) $ ST | NeLocalSTRList > .
  rl [igt_u] : < ("i32.gt_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "igt_u"(IntVal, IntVal2) $ ST | NeLocalSTRList > .
  rl [ile_s] : < ("i32.le_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ile_s"(signed(IntVal, 32), signed(IntVal2, 32)) $ ST | NeLocalSTRList > .
  rl [ile_u] : < ("i32.le_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ile_u"(IntVal, IntVal2) $ ST | NeLocalSTRList > .
  rl [ige_s] : < ("i32.ge_s") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ige_s"(signed(IntVal, 32), signed(IntVal2, 32)) $ ST | NeLocalSTRList > .
  rl [ige_u] : < ("i32.ge_u") IL | IntVal2 $ IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | "ige_u"(IntVal, IntVal2) $ ST | NeLocalSTRList > .

  *** testop
  rl [eqz] : < (i32.eqz) IL | IntVal $ ST | NeLocalSTRList >   
            =>   
            < IL | ieq(IntVal, 0) $ ST | NeLocalSTRList > .

  *** Control instructions
  *** block:
  *** TODO: Check what to do with values on stack previous to label. Should label be after some values? How to calculate it?
  rl [nop] : < nop IL | ST | NeLocalSTRList >   
            =>   
            < IL | ST | NeLocalSTRList > .
  rl [block] : < ((block Str) IL2 end) IL | ST | NeLocalSTRList >   =>   < IL2 end | st-push(ST, label(Str, IL)) | NeLocalSTRList > .
  rl [end] : < end | NeST | NeLocalSTRList >   =>   < get-inst-list-label(reset-st(NeST)) | get-st(reset-st(NeST)) | NeLocalSTRList > .
  rl [if-else] : < (if IL1 else IL2 end) IL | IntVal $ ST | NeLocalSTRList >   =>   < if-else(IntVal, IL1, IL2, IL) | ST | NeLocalSTRList > .
  *** loop is an infinite loop
  rl [loop] : < ((loop Str) IL2 end) IL | ST | NeLocalSTRList >   =>   < IL2 end | st-push(ST, label(Str, (loop Str) IL2 end)) | NeLocalSTRList > .
  rl [br] : < (br N) IL | ST | NeLocalSTRList >   
            =>   
            < jump-to-L(get-ith-stackandlabel(ST, N, EmptyStack)) IL end | ST | NeLocalSTRList > .
  rl [jump-to-L] : < jump-to-L(ST1 || label(Str, IL1)) IL | ST | NeLocalSTRList > 
                  =>
                  < IL1 | ST1 | NeLocalSTRList > .
  crl [br_if] : < ("br_if" N) IL | IntVal $ ST | NeLocalSTRList >
               =>   
               < (br N) IL | ST | NeLocalSTRList > if IntVal =/= 0 .
  crl [br_if-else] : < ("br_if" N) IL | IntVal $ ST | NeLocalSTRList >
              =>   
              < IL | ST | NeLocalSTRList > if IntVal == 0 .
  rl [call] : < (call N) IL | ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore # FuncStore
              =>   
              < get-IL-func(FuncStore[N]) exit-func end | 
                st-push(ST, label("func", IL)) | 
                inizialize-store-N(count-locals-localsref(get-localsref-func(FuncStore[N])) + count-locals-paramlist(get-paramlist-func(FuncStore[N])), (empty).Map{ValRef,Value}) NeLocalSTRList 
              > # GlobalAddrs <-> GlobalsStore # FuncStore .
  rl [exit-func] : < exit-func IL | ST | LocalSTR NeLocalSTRList > # GlobalAddrs <-> GlobalsStore # FuncStore
                  =>   
                  < IL | ST | NeLocalSTRList > # GlobalAddrs <-> GlobalsStore # FuncStore .
    


  *** lookup rule: get value from reference from local store
  rl [lookup] : lookup(LocalSTR, ValR) => LocalSTR[ValR] .


  *** List{Inst} operations 
  op head : NeList{Inst} -> Inst .
  eq head(I1 IL) = I1 .

  op tail : NeList{Inst} -> List{Inst} .
  eq tail(I1 IL) = IL .
  ***eq tail(EmptyList) = EmptyList .

  *** Stack operations
  op st-push : Stack StackElem -> NeStack .
  eq st-push(ST, STElem) = STElem $ ST .
  eq st-push(EmptyStack, STElem) = STElem $ EmptyStack .

  op st-head : NeStack -> StackElem .
  eq st-head(STElem $ ST) = STElem .

  op st-pop : NeStack -> Stack .
  eq st-pop(STElem $ ST) = ST .

  op st-rev : Stack -> Stack .
  eq st-rev(STElem $ ST) = st-rev(ST) $ STElem .
  eq st-rev(EmptyStack) = EmptyStack .

  *** Globals auxiliary ops
  op global-val : GlobalInstance -> Value .
  eq global-val({type GlobalType, value Val}) = Val .

  op global-type : GlobalInstance -> GlobalType .
  eq global-type({type GlobalType, value Val}) = GlobalType .

  *** Only change value if it is marked as mutable (mut/var) global variable (due to validation requirements).
  op insert-gb-val : Addr Value Map{Addr, GlobalInstance} -> Map{Addr, GlobalInstance} .
  eq insert-gb-val(Addr, Val2, (Addr |-> {type MutGlobalType, value Val1}, GlobalsStore)) = (Addr |-> {type MutGlobalType, value Val2}, GlobalsStore) .

  *** reset stack to eliminate label
  op _||_ : Stack Label -> StackAndLabel .
  op reset-st : Stack -> StackAndLabel .
  eq reset-st(Val $ ST) = Val $ get-st(reset-st(ST)) || get-label(reset-st(ST)) .
  eq reset-st(Label $ ST) = ST || Label .
  eq reset-st(EmptyStack) = EmptyStack || und .

  op get-inst-list-label : StackAndLabel -> List{Inst} .
  eq get-inst-list-label(ST || label(Str, IL)) = IL .

  op get-st : StackAndLabel -> Stack .
  eq get-st(ST || Label) = ST .
  eq get-st(ST || und) = ST .

  op get-label : StackAndLabel -> Label .
  eq get-label(ST || Label) = Label .
  eq get-label(ST || und) = und .

  op get-ith-stackandlabel : Stack Nat Stack -> StackAndLabel .
  eq get-ith-stackandlabel(Val $ ST, N, TempST) = get-ith-stackandlabel(ST, N, Val $ TempST) .
  *** TODO: check multiple parses warning
  ceq get-ith-stackandlabel(Label $ ST, N, TempST) = get-ith-stackandlabel(ST, N - 1, TempST) if N > 0 .
  ceq get-ith-stackandlabel(Label $ ST, N, TempST) = TempST $ ST || Label if N == 0 .

  op if-else : IntValue List{Inst} List{Inst} List{Inst} -> List{Inst} .
  ceq if-else(IntVal, IL1, IL2, IL) = ((block "$ifIL1") IL1 end) IL if IntVal == 0 .
  ceq if-else(IntVal, IL1, IL2, IL) = ((block "$ifIL2") IL2 end) IL if IntVal =/= 0 .
  
  op get-IL-func : FuncDef -> List{Inst} .
  eq get-IL-func(func N TypeRef ParamList ResultTypeList LocalsRef IL end) = IL .

  op exit-func : -> Inst .

  op get-localsref-func : FuncDef -> LocalsRef .
  eq get-localsref-func(func N TypeRef ParamList ResultTypeList LocalsRef IL end) = LocalsRef .

  op get-paramlist-func : FuncDef -> List{ParamType} .
  eq get-paramlist-func(func N TypeRef ParamList ResultTypeList LocalsRef IL end) = ParamList .

  op count-locals-localsref : LocalsRef -> Nat .
  eq count-locals-localsref(local nil) = 0 .
  eq count-locals-localsref(local (T TypeTokenList)) = 1 + count-locals-localsref(local TypeTokenList) .

  op count-locals-paramlist : List{ParamType} -> Nat .
  eq count-locals-paramlist((param nil) nil) = 0 .
  eq count-locals-paramlist((param nil) ParamList) = count-locals-paramlist(ParamList) .
  eq count-locals-paramlist((param (T TypeTokenList)) ParamList) = 1 + count-locals-paramlist((param TypeTokenList) ParamList) .

  *** Inizialize a LocalStore with N variables
  op inizialize-store-N : Nat Map{ValRef, Value} -> Map{ValRef, Value} .
  eq inizialize-store-N(0, LocalSTR) = LocalSTR .
  eq inizialize-store-N(1, LocalSTR) = insert(0, 0, LocalSTR) .
  ceq inizialize-store-N(N, LocalSTR) = insert(N - 1, 0, inizialize-store-N(N - 1, LocalSTR)) if N > 1 .


  *** Auxiliary op for arithmetic instructions
  *** signed op : integer operators can be interpreted as if they had sign by some instructions.
  *** signed takes the number and the number of bits in its representation (32/64) 
  *** TODO: FIX multiple parses for statement
  op signed : UInt Nat -> SInt .
  ceq signed(Int1, N) = Int1 if 0 <= Int1 and Int1 < (2 ^ (N - 1)) .
  ceq signed(Int1, N) = Int1 - (2 ^ (N)) if (2 ^ (N - 1)) <= Int1 and Int1 < (2 ^ (N)) .

  *** inverted function from signed
  op unsigned : SInt Nat -> UInt .
  ceq unsigned(Int1, N) = Int1 if 0 <= Int1 and Int1 < (2 ^ (N - 1)) .
  ceq unsigned(Int1, N) = Int1 + (2 ^ (N)) if ((2 ^ (N - 1)) - (2 ^ (N))) <= Int1 and Int1 < 0 .

  op fadd : ValWrapper ValWrapper -> ValWrapper .
  eq fadd(val(nan), val(F1)) = val(nans(nan nanF(F1))) .
  eq fadd(val(F1), val(nan)) = val(nans(nan nanF(F1))) .
  ceq fadd(val(inf(Sg1)), val(inf(Sg2))) = val(nans(nil)) if Sg1 =/= Sg2 .
  eq fadd(val(inf(Sg1)), val(inf(Sg1))) = val(inf(Sg1)) .
  eq fadd(val(Inf), val(F1)) = val(Inf) .
  eq fadd(val(F1), val(Inf)) = val(Inf) .
  *** TODO: check why error on result
  ***ceq fadd(val(zero(Sg1)), val(zero(Sg2))) = val(zero(pos)) if Sg1 =/= Sg2 .
  eq fadd(val(zero(Sg1)), val(zero(Sg1))) = val(zero(Sg1)) .
  eq fadd(val(Zero), val(F1)) = val(F1) .
  eq fadd(val(F1), val(Zero)) = val(F1) .
  *** TODO: Take into account "rounded to the nearest representable value"??
  eq fadd(val(F1), val(F2)) = val(F1 + F2) .

  *** Auxiliary op for logic instructions
  op ieq : IntValue IntValue -> IntValue .
  ceq ieq(IntVal1, IntVal2) = 1 if IntVal1 == IntVal2 .
  eq ieq(IntVal1, IntVal2) = 0 [owise] .
  
  op ine : IntValue IntValue -> IntValue .
  ceq ine(IntVal1, IntVal2) = 1 if IntVal1 =/= IntVal2 .
  eq ine(IntVal1, IntVal2) = 0 [owise] .
  
  op "ilt_u" : IntValue IntValue -> IntValue .
  ceq "ilt_u"(IntVal1, IntVal2) = 1 if abs(IntVal1) < abs(IntVal2) .
  eq "ilt_u"(IntVal1, IntVal2) = 0 [owise] .
  
  op "ilt_s" : IntValue IntValue -> IntValue .
  ceq "ilt_s"(IntVal1, IntVal2) = 1 if IntVal1 < IntVal2 .
  eq "ilt_s"(IntVal1, IntVal2) = 0 [owise] .
  
  op "igt_u" : IntValue IntValue -> IntValue .
  ceq "igt_u"(IntVal1, IntVal2) = 1 if abs(IntVal1) > abs(IntVal2) .
  eq "igt_u"(IntVal1, IntVal2) = 0 [owise] .
  
  op "igt_s" : IntValue IntValue -> IntValue .
  ceq "igt_s"(IntVal1, IntVal2) = 1 if IntVal1 > IntVal2 .
  eq "igt_s"(IntVal1, IntVal2) = 0 [owise] .

  op "ile_u" : IntValue IntValue -> IntValue .
  ceq "ile_u"(IntVal1, IntVal2) = 1 if abs(IntVal1) <= abs(IntVal2) .
  eq "ile_u"(IntVal1, IntVal2) = 0 [owise] .
  
  op "ile_s" : IntValue IntValue -> IntValue .
  ceq "ile_s"(IntVal1, IntVal2) = 1 if IntVal1 <= IntVal2 .
  eq "ile_s"(IntVal1, IntVal2) = 0 [owise] .
  
  op "ige_u" : IntValue IntValue -> IntValue .
  ceq "ige_u"(IntVal1, IntVal2) = 1 if abs(IntVal1) >= abs(IntVal2) .
  eq "ige_u"(IntVal1, IntVal2) = 0 [owise] .
  
  op "ige_s" : IntValue IntValue -> IntValue .
  ceq "ige_s"(IntVal1, IntVal2) = 1 if IntVal1 >= IntVal2 .
  eq "ige_s"(IntVal1, IntVal2) = 0 [owise] .

  ****************
  *** Verification
  ****************
  *** Should this be verified at constructor level??
  ***op verify-const : Value Nat -> Bool .
  ***ceq verify-const(IntVal, N) = true if 0 <= IntVal and IntVal <= ((2 ^ (N)) - 1) .
  ***eq verify-const(Val, N) = false .

endm

